

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jerry(姜源)">
  <meta name="keywords" content="Java,Html,CSS,JavaScript,Vue,React,SpringBoot,Linux,shell编程经验分享、技术总结、心得体会">
  
    <meta name="description" content="HTML123456789101112131415161718192021222324252627282930311. HTML5 结构语义化：	用正确的标签做正确的事情。p段落、h标题、aside边栏、main主要内容等...	对开发者：便于维护、较好的呈现内容结构和代码结构、易于阅读；	对浏览器：有利于SEO，搜索引擎爬虫依赖于标签、方便其他设备解析、提高可访问性2. HTML5 新特性：	新">
<meta property="og:type" content="article">
<meta property="og:title" content="00-面试题杂项整理（前端）">
<meta property="og:url" content="https://janycode.github.io/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01_%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/00-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%9D%82%E9%A1%B9%E6%95%B4%E7%90%86%20(%E5%89%8D%E7%AB%AF)/index.html">
<meta property="og:site_name" content="姜源の全栈云笔记">
<meta property="og:description" content="HTML123456789101112131415161718192021222324252627282930311. HTML5 结构语义化：	用正确的标签做正确的事情。p段落、h标题、aside边栏、main主要内容等...	对开发者：便于维护、较好的呈现内容结构和代码结构、易于阅读；	对浏览器：有利于SEO，搜索引擎爬虫依赖于标签、方便其他设备解析、提高可访问性2. HTML5 新特性：	新">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260214130820623.png">
<meta property="og:image" content="https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260220133616343.png">
<meta property="article:published_time" content="2017-05-02T16:09:33.000Z">
<meta property="article:modified_time" content="2026-02-20T05:47:12.537Z">
<meta property="article:author" content="Jerry(姜源)">
<meta property="article:tag" content="面试题">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260214130820623.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>00-面试题杂项整理（前端） - 姜源の全栈云笔记</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"janycode.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":50,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"bfff735c897eb60ea49b735096b20e47","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>姜源の全栈云笔记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tools/">
                <i class="iconfont icon-slack-fill"></i>
                工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://yuancodes.github.io/">
                <i class="iconfont icon-notebook"></i>
                Docsify
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="00-面试题杂项整理（前端）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Jerry(姜源)
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-05-03 00:09" pubdate>
          星期三, 2017/05/03 00:09:33
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          34k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          286 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">00-面试题杂项整理（前端）</h1>
            
            <div class="markdown-body">
              
              <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> <span class="hljs-title class_">HTML5</span> 结构语义化：<br>	用正确的标签做正确的事情。p段落、h标题、aside边栏、main主要内容等...<br>	对开发者：便于维护、较好的呈现内容结构和代码结构、易于阅读；<br>	对浏览器：有利于<span class="hljs-variable constant_">SEO</span>，搜索引擎爬虫依赖于标签、方便其他设备解析、提高可访问性<br><span class="hljs-number">2.</span> <span class="hljs-title class_">HTML5</span> 新特性：<br>	新增：主要是关于图像、位置、存储、多任务等功能的增加<br>	    媒体播放的 video/audio 元素<br>	    本地存储 <span class="hljs-variable language_">localStorage</span>长期(浏览器关闭不消失) / sessionStorage会话(数据浏览器关闭删除)<br>	    语义化更好的内容元素（article,footer,header,nav,section）<br>	    表单控件（calendar、date、time、email、url、search）<br>	    新的技术（webworker,websocket,geolocation）<br>    移除：纯表现的元素（basefont, big, center, font, s, strike, tt, u）、可用性有负面影响的元素（frame, frameset, noframes）<br><span class="hljs-number">3.</span> cookies, sessionStorage, <span class="hljs-variable language_">localStorage</span> 区别：<br>	<span class="hljs-title function_">cookies</span>(最大4k): 标识用户身份，存储在用户本地终端（通常经过加密），始终自动同源http请求中携带<br>	<span class="hljs-title function_">sessionStorage</span>(5M或更大): 数据在当前浏览器窗口关闭后自动删除<br>	<span class="hljs-title function_">localStorage</span>(5M或更大): 持久化存储数据，浏览器关闭不会丢失除非主动删除<br><span class="hljs-number">4.</span> 浏览器的渲染机制的步骤：<br>	处理<span class="hljs-variable constant_">HTML</span>并构建<span class="hljs-variable constant_">DOM</span>树 → 处理<span class="hljs-variable constant_">CSS</span>构建<span class="hljs-variable constant_">CSSOM</span>树 → 将<span class="hljs-variable constant_">DOM</span>与<span class="hljs-variable constant_">CSSOM</span>合并为一个渲染树 → 布局并计算每个节点的位置 → 调用<span class="hljs-variable constant_">GPU</span>绘制合成图层并显示在屏幕上<br>	注意：<span class="hljs-variable constant_">CSSOM</span>树会阻塞渲染，因此<span class="hljs-variable constant_">CSS</span>选择器要尽量层级扁平，减少过度层叠；<span class="hljs-variable constant_">JS</span>文件要按需加载，不在首页去全部加载<br><span class="hljs-number">5.</span> 重绘(<span class="hljs-title class_">Repaint</span>) 和 回流(<span class="hljs-title class_">Reflow</span>)<br>	重绘: 节点需要更改 外观(不影响布局)，如改变color就是重绘<br>	回流: 布局或者几何属性(影响布局) 改变就是回流<br>	减少重绘和回流：<br>	  <span class="hljs-number">1</span>)批量修改 <span class="hljs-variable constant_">DOM</span><br>	  <span class="hljs-number">2</span>)复杂动画效果，使用绝对定位使其脱离文档流<br>	  <span class="hljs-number">3</span>)<span class="hljs-title class_">CSS3</span>硬件加速（<span class="hljs-variable constant_">GPU</span>加速） transform/opacity/filters 这些动画不会引起回流重绘<br><span class="hljs-number">6.</span> <span class="hljs-attr">data</span>:属性的用法，有何优势？<br>    data-* 的值的获取和设置，<span class="hljs-number">2</span>种方法：<br>	<span class="hljs-number">1</span>)[无兼容性问题，不优雅] <span class="hljs-title function_">getAttribute</span>() 获取 data-属性值； <span class="hljs-title function_">setAttribute</span>() 设置 data-属性值<br>	<span class="hljs-number">2</span>)[有兼容性问题，更优雅] <span class="hljs-title class_">HTML5</span>新方法：如 data-jerry, dataset.<span class="hljs-property">jerry</span> 获取属性值； dataset.<span class="hljs-property">jerry</span>=<span class="hljs-string">&quot;张三&quot;</span> 设置属性值<br>	优势：自定义的数据可以让页面拥有更好的交互体验<br></code></pre></td></tr></table></figure>



<h2 id="CSS-★"><a href="#CSS-★" class="headerlink" title="CSS(★)"></a>CSS(★)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> <span class="hljs-attr">display</span>:none; 与 <span class="hljs-attr">visibility</span>:hidden; 的区别<br>    相同：都可以让元素不可见<br>    区别：<br>      <span class="hljs-number">1</span>)<span class="hljs-attr">display</span>:none 元素完全从渲染树中消失，渲染时不占空间；<span class="hljs-attr">visibility</span>:hidden 不会让元素从渲染树消失，渲染时占空间，内容不可见<br>      <span class="hljs-number">2</span>)修改常规常规流中的元素 display 会造成 文档重排(★) 、修改 visibility 属性只会造成本元素的 重绘(★)<br><span class="hljs-number">2.</span> 外边距折叠<br>    相邻的两个或多个 margin 会合并成一个 margin，叫做外边距折叠。规则如下：<br>    <span class="hljs-number">1</span>)两个或多个相邻的普通流中的【块元素垂直方向】上 margin 会折叠<br>    <span class="hljs-number">2</span>)【浮动】元素或【inline-block】元素或【绝对定位】元素 margin 不会和垂直方向上的其他元素 margin 折叠<br>    <span class="hljs-number">3</span>)创建了 块级格式上下文(<span class="hljs-variable constant_">BFC</span>) 的元素，不会和它的子元素发生margin折叠<br><span class="hljs-number">3.</span> z-index是什么？position的值什么时候可以触发？<br>    z-index 设置元素的堆叠顺序。<br>    注意：z-index 仅能在定位元素上有效，position = relative / absolute / fixed / sticky 时才会触发层级设置。<br><span class="hljs-number">4.</span> box-sizing 的有效值以及对应的盒模型规则: 内边距和边框(★)<br>    <span class="hljs-number">1</span>)box-<span class="hljs-attr">sizing</span>:content-box; 默认值，宽度和高度分别应用到元素的内容框；在宽度和高度 之外(★) 绘制元素的内边距和边框。<br>    <span class="hljs-number">2</span>)box-<span class="hljs-attr">sizing</span>:border-box; 内边距和边框都在已设定宽度和高度 之内(★) 进行绘制。内部元素宽高会被挤压，使我们更容易控制元素宽高。<br>    <span class="hljs-number">3</span>)box-<span class="hljs-attr">sizing</span>:inherit; 继承父元素的 box-sizing 属性的值。<br><span class="hljs-number">5.</span> 移动端适配怎么做？<br>    <span class="hljs-number">1</span>) meta标签<span class="hljs-title function_">viewport</span>(视口适配)<br>      移动端初始视口大小默认是 <span class="hljs-number">980</span> px，为了解决页面缩放体验问题，代码头部会加入一行 viewport 原标签，告诉浏览器视口的宽度为设备的宽度。<br>      属性含义：<br>        initial-<span class="hljs-attr">scale</span>: 第一次进入页面的初始比例<br>        minimum-<span class="hljs-attr">scale</span>: 允许缩小最小比例<br>        maximum-<span class="hljs-attr">scale</span>: 允许放大最大比例<br>        user-scalable：允许使用者缩放，<span class="hljs-number">1</span> or <span class="hljs-number">0</span>（yes or no）<br>    <span class="hljs-number">2</span>) 图片适配(★)<br>      img &#123; max-<span class="hljs-attr">width</span>: <span class="hljs-number">100</span>%; &#125; 此时图片会自动缩放，同时图片最大值为自身的<span class="hljs-number">100</span>%<br>      为什么不用 img &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>%; &#125; ? 当容器大于图片宽度时，图片会无情的拉伸变形。<br>    <span class="hljs-number">3</span>) 媒体查询(★)<br>      自动检测屏幕宽度，然后加载相应的<span class="hljs-variable constant_">CSS</span>文件或样式，语法 @media screen and (min-<span class="hljs-attr">width</span>:1200px) &#123; 样式代码 &#125;<br>    <span class="hljs-number">4</span>) 动态rem方案(★)<br>      rem 和媒体查询配合实现响应式布局。<br>    	- px：像素，屏幕上显示数据的最基本的点，<span class="hljs-variable constant_">HTML</span>中默认单位；<br>    	- em：相对于【父元素的 font-size】 的百分比大小；<br>    	- rem：相对于【根元素的 font-size】的大小，如<br>    	    css 中 html&#123; font-<span class="hljs-attr">size</span>: 100px; &#125;<br>    	    js  中动态设置 fontSize，以 iphone6的750px为标准宽度等比缩放设计稿，使用375px进行计算，计算方式<br>    	    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">375</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;px&#x27;</span>;<br><span class="hljs-number">6.</span> <span class="hljs-title class_">CSS3</span>中的 transform? transition? animation? 区别是什么？<br>    <span class="hljs-attr">transform</span>: 静态样式，对元素进行移动translate、缩放scale、旋转rotate、扭曲skew、矩阵变形matrix<br>    <span class="hljs-attr">transition</span>: 样式过度，从一种效果改变为另一种效果，复合属性，分别可以设置 <span class="hljs-variable constant_">CSS</span>属性、过度效果时间、速度曲线、过渡开始的延迟时间<br>    <span class="hljs-attr">animation</span>: 动画属性，由 <span class="hljs-string">`@keyframes`</span> 来描述每一帧的样式<br>    区别：<br>        <span class="hljs-number">1</span>) transform 仅描述元素静态样式，尝尝配合 transition 和 animation 使用<br>        <span class="hljs-number">2</span>) transition 通常和 hover 等事件配合使用，animation 是自发的，立即播放<br>        <span class="hljs-number">3</span>) transition 可与 js 配合使用，js设定要变化的样式，transition 负责动画效果<br>        <span class="hljs-number">4</span>) animation 可设置循环次数<br>        <span class="hljs-number">5</span>) animation 可设置每一帧的样式和时间，transition 只能设置头尾<br><span class="hljs-number">7.</span> 父元素和子元素的宽高不固定，如何实现水平垂直居中？<br>    方式<span class="hljs-number">1</span>: 定位和位移(★) 父元素相对定位，子元素绝对定位 + <span class="hljs-attr">left</span>:<span class="hljs-number">50</span>% + <span class="hljs-attr">top</span>: <span class="hljs-number">50</span>% + <span class="hljs-attr">transform</span>: <span class="hljs-title function_">translate</span>(-<span class="hljs-number">50</span>%, -<span class="hljs-number">50</span>%) 位移<br>    方式<span class="hljs-number">2</span>: 弹性布局(★) 主轴和侧轴居中，即 <span class="hljs-attr">display</span>:flex; justify-<span class="hljs-attr">content</span>:center; align-<span class="hljs-attr">item</span>:center; <br><span class="hljs-number">8.</span> 假设高度默认100px，写出三栏布局、其中左栏、右栏各位300px，中间自适应<br>    方式<span class="hljs-number">1</span>: 浮动(盒子1left左浮动、盒子2right右浮动、盒子3center自动填满中间)--必须是这个顺序！<br>    方式<span class="hljs-number">2</span>: 绝对定位(盒子<span class="hljs-number">1</span>定位left0、盒子<span class="hljs-number">3</span>定位right0)<br>    方式<span class="hljs-number">3</span>: 弹性布局(盒子<span class="hljs-number">1</span>宽度<span class="hljs-number">300</span>，盒子<span class="hljs-number">3</span>宽度<span class="hljs-number">300</span>，盒子<span class="hljs-number">2</span>设置<span class="hljs-attr">flex</span>:<span class="hljs-number">1</span>)<br><span class="hljs-number">9.</span> <span class="hljs-variable constant_">BFC</span>, 块级格式上下文<br>    <span class="hljs-variable constant_">BFC</span>（<span class="hljs-title class_">Block</span> <span class="hljs-title class_">Formatting</span> <span class="hljs-title class_">Context</span>，块级格式上下文）是 <span class="hljs-variable constant_">CSS</span> 中一种独立的渲染环境 / 布局规则。<br>    <span class="hljs-variable constant_">BFC</span> 的元素===“封闭的独立盒子”，盒子内部元素布局都不会影响到外部元素，外部元素也不会干扰盒子内部布局，且盒子内遵循独立的布局规则。<br>    只要元素满足以下任意一个条件，就会创建 <span class="hljs-variable constant_">BFC</span>：<br>        <span class="hljs-number">1</span>)根元素(&lt;html&gt;)<br>        <span class="hljs-number">2</span>)浮动元素(float 不为 none，比如 <span class="hljs-attr">float</span>: left/right)<br>        <span class="hljs-number">3</span>)绝对定位、固定定位元素(<span class="hljs-attr">position</span>: absolute/fixed)<br>        <span class="hljs-number">4</span>)行内块元素(<span class="hljs-attr">display</span>: inline-block)<br>        <span class="hljs-number">5</span>)表格单元格、表格标题(<span class="hljs-attr">display</span>: table-cell/table-caption)<br>        <span class="hljs-number">6</span>)溢出元素(overflow 不为 visible，比如 <span class="hljs-attr">overflow</span>: hidden/auto/scroll【最常用】)<br>        <span class="hljs-number">7</span>)弹性、网格容器(<span class="hljs-attr">display</span>: flex/grid)<br>    应用场景：（触发 <span class="hljs-variable constant_">BFC</span> 最常用方法，简单无副作用，添加 <span class="hljs-attr">overflow</span>: hidden）<br>    	<span class="hljs-number">1</span>) 解决父元素高度塌陷(★)<br>    	  父元素里子元素设置浮动后，父元素会失去高度（塌陷），无法包裹子元素。【解决】给父元素触发<span class="hljs-variable constant_">BFC</span>（最常用 <span class="hljs-attr">overflow</span>: hidden）<br>    	<span class="hljs-number">2</span>) 解决垂直方向margin重叠问题(★)<br>    	  两个相邻的块级元素，垂直方向的 margin 会 “合并”（取最大值，而非相加）。【解决】给其中<span class="hljs-number">1</span>个元素包裹一层div触发 <span class="hljs-variable constant_">BFC</span> 的父元素<br>    	<span class="hljs-number">3</span>) 阻止浮动元素覆盖普通元素(★)<br>    	  浮动元素会覆盖旁边的普通块级元素，导致布局错乱。【解决】给被覆盖的元素（如浮动的div盖住了 p 标签）p标签触发 <span class="hljs-variable constant_">BFC</span><br></code></pre></td></tr></table></figure>



<h2 id="JavaScript-★"><a href="#JavaScript-★" class="headerlink" title="JavaScript(★)"></a>JavaScript(★)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> <span class="hljs-variable constant_">JS</span>内置对象：<br>    数据封装类对象: <span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Array</span>, <span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">Number</span>, <span class="hljs-title class_">String</span><br>    其他对象: <span class="hljs-title class_">Function</span>, <span class="hljs-title class_">Arguments</span>, <span class="hljs-title class_">Math</span>, <span class="hljs-title class_">Date</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Error</span><br>    <span class="hljs-title class_">ES6</span>新增对象: <span class="hljs-title class_">Symbol</span>(标识唯一性的<span class="hljs-variable constant_">ID</span>), <span class="hljs-title class_">Map</span>, <span class="hljs-title class_">Set</span>, <span class="hljs-title class_">Promises</span>, <span class="hljs-title class_">Proxy</span>, <span class="hljs-title class_">Reflect</span><br><span class="hljs-number">2.</span> 如何最小化 重绘(repaint) 和 回流(reflow)？<br>    <span class="hljs-number">1</span>)对元素复杂操作时，先隐藏（<span class="hljs-attr">display</span>:none），操作完再显示<br>    <span class="hljs-number">2</span>)创建多个<span class="hljs-variable constant_">DOM</span>节点时，使用 <span class="hljs-title class_">DocumentFragment</span> 创建完后一次性的加入 <span class="hljs-variable language_">document</span><br>    <span class="hljs-number">3</span>)缓存 <span class="hljs-title class_">Layout</span> 属性值，如 <span class="hljs-string">`var left=elem.offsetLeft;`</span> 这样多次left只产生一次回流<br>    <span class="hljs-number">4</span>)尽量避免用 table 布局<br><span class="hljs-number">3.</span> <span class="hljs-variable constant_">JS</span>作用域链？<br>    全局函数无法查看局部函数的内部细节，局部函数可以查看其上层的函数细节，直至全局细节；<br>    当前作用域函数没有找到属性或方法，会向上层作用域[[<span class="hljs-title class_">Scoped</span>]]查找，直至全局函数，这就是作用域链。<br><span class="hljs-number">4.</span> 数据请求？<span class="hljs-variable constant_">XHR</span>, fetch, jsonp<br>   <span class="hljs-attr">XHR</span>: <span class="hljs-title class_">XMLHttpRequest</span>()，  xhr.<span class="hljs-title function_">abort</span>();<span class="hljs-comment">//取消或终止请求</span><br>   <span class="hljs-attr">fetch</span>: w3c新的标准 <span class="hljs-title function_">fetch</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br>   <span class="hljs-attr">jsonp</span>: 解决跨域，且只有get请求；原理是动态创建 script 标签，请求数据没有限制<br><span class="hljs-number">5.</span> 跨域和同源策略<br>    同源：同协议、同域名、同端口 才能进行数据请求和响应交互。非同源就会触发<span class="hljs-variable constant_">CORS</span>跨域。<br>    <span class="hljs-number">1</span>) <span class="hljs-title class_">JSON</span>P(★)：利用动态创建 script 标签，请求数据没有限制，解决跨域。<br>    <span class="hljs-number">2</span>) <span class="hljs-title function_">CORS</span>(★)：依赖服务端对前端的请求头进行放行，不做限制（<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>:*）<br>    <span class="hljs-number">3</span>) 反向代理(★)：前端访问无跨域问题的代理服务器，代理服务器再去访问目标服务器<br><span class="hljs-number">6.</span> 面向对象<br>	<span class="hljs-number">1</span>)构造函数：通过函数方法创建一个对象，可以 <span class="hljs-keyword">new</span> 一个该对象<br>	<span class="hljs-number">2</span>)原型: <span class="hljs-title class_">Test</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125; 缺点是：原型很容易被覆盖而丢失原有的功能<br>	<span class="hljs-number">3</span>)继承: <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...) 或 <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, ...) 然后原型继承 <span class="hljs-title class_">Test2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Test</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>	<span class="hljs-number">4</span>)原型链: 任何一个实例，通过原型链找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。<br><span class="hljs-number">7.</span> 闭包：实际开发中使用到的闭包<br>	函数内部返回一个函数(★)，而这个函数又被外界使用，导致该函数和返回的函数都不会被垃圾回收，此用法称之为<span class="hljs-string">`闭包`</span>。<br>	使用多了或者使用不当可能会导致【内存泄露】。<br>	场景<span class="hljs-number">1</span>: 函数防抖(搜索查询)，即 input 绑定一个延迟500ms定时器去延时请求搜索查询来实现防抖，而不是所有输入都请求数据<br>	场景<span class="hljs-number">2</span>: 函数节流(图表自适应)，即 resize 用于 echart 重新渲染图标大小时，拖动窗口超过如1s时，才重新设置 echarts 的 option渲染图标<br>	场景<span class="hljs-number">3</span>: 循环添加事件(ul li)，即 ul li 标签遍历 li 添加事件时，遍历会瞬间执行完，使用闭包可以让每个点击对应每个事件，而不是直接全部执行完毕<br><span class="hljs-number">8.</span> 数组去重： <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]))  <span class="hljs-comment">//[1,2,3,4]</span><br><span class="hljs-number">9.</span> 数组合并： <span class="hljs-number">1</span>)concat    <span class="hljs-number">2</span>)[...a, ...b]展开运算符    <span class="hljs-number">3</span>)[a, b].<span class="hljs-title function_">flat</span>()扁平化<br><span class="hljs-number">10.</span> cookie 和 session - 【登陆鉴权如何实现的？】<br>    <span class="hljs-attr">cookie</span>: 客户端向服务端登陆的时候，服务端通过响应头去set-cookie，在浏览器注入cookie（可能携带隐私敏感信息 -- 可能会被模拟cookie即模拟登陆<br>    <span class="hljs-attr">session</span>: 服务端建立用户信息表和生命周期机制，服务端在客户端登陆时将此信息返回为set-cookie，客户端存储到cookie或<span class="hljs-variable language_">localStorage</span>均可<br>             每次请求携带该验证信息，服务端去验证是否有效或过期<br>             一般是 cookie 中存 sessionId --或-- <span class="hljs-variable language_">localStorage</span> 中存储 token<br><span class="hljs-number">11.</span> 协商缓存和强缓存的区别<br>    相同：都是浏览器对静态资源文件的缓存机制<br>    不同：<br>    	- 强缓存：客户端直接查看本地的缓存文件是否过期，如果没有过去就直接取用。【不涉及服务端交互】<br>    	          依靠响应头上的 <span class="hljs-title function_">expires</span>(绝对时间) 和 cache-<span class="hljs-title function_">control</span>(相对时间) 两个值来对比<br>    	- 协商缓存：客户端去询问服务器对应的文件是否有更新，如果有更新才会重新请求。<br>    	          依靠 last-<span class="hljs-title function_">modified</span>(最后更新时间) 和 <span class="hljs-title function_">etag</span>(内容变更标识) 来确认文件是否有更新<br>    【一般做法】在静态文件的 url 如 xxx.<span class="hljs-property">js</span> 后面追加了 <span class="hljs-string">&#x27;?t=时间戳&#x27;</span> 参数，可以阻止浏览器缓存，每次都可以获取到最新的信息<br><span class="hljs-number">12.</span> <span class="hljs-variable constant_">HTTP</span>与<span class="hljs-variable constant_">HTTPS</span><br>    <span class="hljs-variable constant_">HTTP</span>：明文传输，<span class="hljs-variable constant_">TCP</span>传输交换<span class="hljs-number">3</span>个包，默认端口号 <span class="hljs-number">80</span><br>    <span class="hljs-variable constant_">HTTPS</span>：加密传输，<span class="hljs-variable constant_">TCP</span>传出交换<span class="hljs-number">3</span>+<span class="hljs-number">9</span>=<span class="hljs-number">12</span>个包，默认端口号 <span class="hljs-number">443</span>，<span class="hljs-variable constant_">TLS</span>加密即通过证书对双方进行身份验证<br><span class="hljs-number">13.</span> 跨域问题解决：<br>    <span class="hljs-number">1</span>)一般线上环境不会有跨域问题，因为前后端都部署在同一台服务器。<br>    <span class="hljs-number">2</span>)本地开发可能会有跨域，比如本地访问测试或开发服务器的接口，基本都是后端设置允许跨域为 * ，有时前端也需要配置脚手架的 devServer 中配置 <span class="hljs-title class_">Proxy</span><br>    <span class="hljs-number">3</span>)极少的情况下，项目中可能会访问一些第三方api，如定位、天气这些接口，可能会根据接口的情况使用 jsonp 进行跨域处理。<br><span class="hljs-number">14.</span> 事件循环机制：<br>    <span class="hljs-number">1</span>)所有同步任务在主线程上执行，形成一个【执行栈】<br>    <span class="hljs-number">2</span>)主线程之外，还存在一个【任务队列】，只要一步任务（<span class="hljs-built_in">setInterval</span>, <span class="hljs-built_in">setTimeout</span>, i/o...）有了结果，就在【任务队列】中放置一个事件<br>    <span class="hljs-number">3</span>)一旦执行栈中的所有同步任务执行完毕，系统就会读取【任务队列】，拿到队列的第一个任务，进入执行栈，开始执行<br>    <span class="hljs-number">4</span>)主线程不断重复步骤<span class="hljs-number">3</span>)<br><span class="hljs-number">15.</span> 宏任务 与 微任务<br>    宏任务：script 全部代码、<span class="hljs-built_in">setTimeout</span>、<span class="hljs-built_in">setInterval</span>、I/O、<span class="hljs-variable constant_">UI</span> <span class="hljs-title class_">Rendering</span>...<br>    微任务：<span class="hljs-title class_">Promise</span>、<span class="hljs-title class_">Process</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-title class_">Node</span>独有)...<br><span class="hljs-number">16.</span> <span class="hljs-variable constant_">HTTP</span>状态码：<br>    <span class="hljs-number">200</span> <span class="hljs-variable constant_">OK</span> 正常返回信息 || memory cache <span class="hljs-string">&#x27;强缓存&#x27;</span><br>    <span class="hljs-number">201</span> <span class="hljs-title class_">Created</span> 请求成功并且服务器创建了新资源<br>    <span class="hljs-number">202</span> <span class="hljs-title class_">Accepted</span> 服务器已接收请求，但尚未处理<br>    <span class="hljs-number">301</span> <span class="hljs-title class_">Moved</span> <span class="hljs-title class_">Permanently</span> 重定向-请求的网页已永久移动到新位置<br>    <span class="hljs-number">302</span> <span class="hljs-title class_">Found</span> 重定向-临时性重定向<br>    <span class="hljs-number">304</span> <span class="hljs-title class_">Not</span> <span class="hljs-title class_">Modified</span> 自动上次请求后，请求的网页未修改过 <span class="hljs-string">&#x27;协商缓存&#x27;</span><br>    <span class="hljs-number">307</span> <span class="hljs-title class_">Internal</span> <span class="hljs-title class_">Redirect</span> 重定向-内部重定向<br>    <span class="hljs-number">400</span> <span class="hljs-title class_">Bad</span> <span class="hljs-title class_">Request</span> 服务器无法理解请求的格式，客户端不应当尝试再次请求<br>    <span class="hljs-number">401</span> <span class="hljs-title class_">Unauthorized</span> 请求未授权<br>    <span class="hljs-number">403</span> <span class="hljs-title class_">Forbidden</span> 禁止访问<br>    <span class="hljs-number">404</span> <span class="hljs-title class_">Not</span> <span class="hljs-title class_">Found</span> 找不到任何与 <span class="hljs-variable constant_">URI</span> 相匹配的资源<br>    <span class="hljs-number">500</span> <span class="hljs-title class_">Internal</span> <span class="hljs-title class_">Server</span> <span class="hljs-title class_">Error</span> 服务端错误<br>    <span class="hljs-number">503</span> <span class="hljs-title class_">Service</span> <span class="hljs-title class_">Unavailable</span> 服务端无法处理的请求，服务不可用<br><span class="hljs-number">17.</span> 一个页面从输入<span class="hljs-variable constant_">URL</span>到页面加载显示完成，这个过程都发生了什么？<br>    <span class="hljs-number">1</span>)【域名解析<span class="hljs-variable constant_">IP</span>】：浏览器查找域名对应的<span class="hljs-variable constant_">IP</span>地址（<span class="hljs-variable constant_">DNS</span>查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;<span class="hljs-variable constant_">ISP</span> <span class="hljs-variable constant_">DNS</span>缓存-&gt;根域名服务器）<br>    <span class="hljs-number">2</span>)【<span class="hljs-variable constant_">TCP</span>三次握手】：浏览器向web服务器发送一个<span class="hljs-variable constant_">HTTP</span>请求（<span class="hljs-variable constant_">TCP</span>三次握手）<br>    <span class="hljs-number">3</span>)【重定向】：服务器<span class="hljs-number">301</span>重定向（从 xxx.<span class="hljs-property">com</span> 重定向到 www.<span class="hljs-property">xxx</span>.<span class="hljs-property">com</span>）<br>    <span class="hljs-number">4</span>)【请求】：浏览器跟踪重定向地址，请求另一个带www的网址<br>    <span class="hljs-number">5</span>)【处理请求】：服务器处理请求（通过路由读取资源）<br>    <span class="hljs-number">6</span>)【响应】：服务器返回一个<span class="hljs-variable constant_">HTTP</span>响应（抱头中把<span class="hljs-title class_">Content</span>-type 设置为 text/html）<br>    <span class="hljs-number">7</span>)【<span class="hljs-variable constant_">DOM</span>构建】：浏览器进<span class="hljs-variable constant_">DOM</span>树构建<br>    <span class="hljs-number">8</span>)【请求资源】：浏览器发送请求获取嵌在<span class="hljs-variable constant_">HTML</span>中的资源（如图片、音频、视频、<span class="hljs-variable constant_">CSS</span>、<span class="hljs-variable constant_">JS</span>等）<br>    <span class="hljs-number">9</span>)【显示页面】：浏览器显示完成页面<br>    <span class="hljs-number">10</span>)【异步请求】：浏览器发送异步请求<br><span class="hljs-number">18.</span> <span class="hljs-variable constant_">CSRF</span>跨站请求伪造 &amp; <span class="hljs-variable constant_">XSS</span>脚本注入攻击<br>    <span class="hljs-variable constant_">CSRF</span>：<span class="hljs-number">1</span>)登陆受信任网站A，并在本地生成cookie； <span class="hljs-number">2</span>)在不登出A的情况下，访问危险网站B（利用了A网站的漏洞）【因为浏览器会自动携带cookie】<br>        解决方案：<br>           <span class="hljs-number">1</span>)<span class="hljs-title class_">Token</span>验证(最常用)：前端携带token后端验证token<br>           <span class="hljs-number">2</span>)隐藏token在head请求头中<br>           <span class="hljs-number">3</span>)<span class="hljs-title class_">Referer</span>验证：只接受本站请求，其他拦截掉<br>    <span class="hljs-variable constant_">XSS</span>：不需要做任何登陆认证，通过合法的操作，向你的页面注入脚本（如js代码发送你的明文cookie外部），即盗用cookie/破坏页面插入广告/doss攻击<br>        解决方案：<br>           <span class="hljs-number">1</span>)编码：对用户输入的数据进行 <span class="hljs-variable constant_">HTML</span> <span class="hljs-title class_">Entity</span> 编码<br>           <span class="hljs-number">2</span>)过滤：移除用户输入的和事件相关的属性、移除用户输入的style、script、iframe节点<br>    区别：<span class="hljs-variable constant_">CSRF</span>是利用网站A本身的漏洞，去请求网站A的api；  <span class="hljs-variable constant_">XSS</span>是向网站注入js代码，然后执行js代码，篡改网站的内容<br></code></pre></td></tr></table></figure>

<h3 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h3><h4 id="①函数防抖"><a href="#①函数防抖" class="headerlink" title="①函数防抖"></a>①函数防抖</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;mytext&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> oInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;mytext&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// oInput.oninput = () =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">//     console.log(this.value); //! 每次输入都会输出 - 不能这么做</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// &#125;</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">vibration</span>(<span class="hljs-params">fn, delay</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">if</span> (timer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-built_in">clearTimeout</span>(timer);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;, delay);</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 测试函数防抖</span></span></span><br><span class="language-javascript"><span class="language-xml">    oInput.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">vibration</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">//! 输入停止n秒后输出</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-number">500</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h4 id="②函数节流"><a href="#②函数节流" class="headerlink" title="②函数节流"></a>②函数节流</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">// 函数节流：在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则不执行回调。</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = <span class="hljs-title function_">throttle</span>(<span class="hljs-number">1000</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">delay</span>) &#123;<br>        <span class="hljs-keyword">var</span> date = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resize&quot;</span>)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - date &gt;= delay) &#123;<br>                date = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1秒内只能触发一次&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h4 id="③循环添加事件"><a href="#③循环添加事件" class="headerlink" title="③循环添加事件"></a>③循环添加事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;ul&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">var</span> oLis = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;li&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; oLis.<span class="hljs-property">length</span>; i++) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-comment">// 每个li都有一个点击事件，点击时输出当前li的索引</span></span></span><br><span class="language-javascript"><span class="language-xml">        oLis[i].<span class="hljs-property">onclick</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;)(i) <span class="hljs-comment">// 立即执行函数，将i作为参数传递，返回一个函数，赋值给oLis[i].onclick</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>



<h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-comment">//数字即是执行顺序：111 222 333 444 555</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">555</span>);<br>    &#125;, <span class="hljs-number">0</span>);<br>    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260214130820623.png" srcset="/img/loading.gif" lazyload alt="image-20260214130819453"></p>
<h2 id="ES6-ES13-★"><a href="#ES6-ES13-★" class="headerlink" title="ES6 - ES13(★)"></a>ES6 - ES13(★)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> <span class="hljs-title class_">ES6</span>新增方法：<br>    <span class="hljs-keyword">let</span>&amp;<span class="hljs-keyword">const</span>、解构赋值、箭头函数、模版字符串<br>    <span class="hljs-title class_">Symbol</span>、<span class="hljs-title class_">Map</span>、<span class="hljs-title class_">Set</span>常用数据类型<br>    <span class="hljs-title class_">Proxy</span> 重新定义了数据劫持的能力<br>    <span class="hljs-title class_">Reflect</span> 定义了一套标准化的数据操作方式<br>    <span class="hljs-title class_">Promise</span>解决异步嵌套回调地狱问题，定义异步逻辑<span class="hljs-number">3</span>种状态 pending/fullfilled/rejected, 搭配then/<span class="hljs-keyword">catch</span>/all/race和<span class="hljs-keyword">async</span>+<span class="hljs-keyword">await</span>语法糖<br>    <span class="hljs-title class_">Generator</span>函数，可以将异步逻辑划片执行 (大厂面试)：同步遍历器，会返回一个遍历器对象，即可以一次遍历 <span class="hljs-title class_">Generator</span> 函数内部的每一个状态<br>    <span class="hljs-keyword">class</span>类<br>    modules模块化<br><span class="hljs-number">2.</span> <span class="hljs-keyword">var</span> &amp; <span class="hljs-keyword">let</span> &amp; <span class="hljs-keyword">const</span> 区别：<br>    <span class="hljs-attr">var</span>: 存在声明提前，不存在作用域限制<br>    <span class="hljs-attr">let</span>: 不会声明提前， 存在暂时性死区，存在块级作用域限制<br>    <span class="hljs-attr">const</span>: 常量定义，无法修改<br><span class="hljs-number">3.</span> 箭头函数: <span class="hljs-string">`()=&gt;&#123;&#125;`</span> <span class="hljs-title class_">ES6</span>推出的，低版本浏览器有兼容性问题。箭头函数没有自己的 <span class="hljs-variable language_">this</span> 指向（默认指向<span class="hljs-variable language_">window</span>）<br><span class="hljs-number">4.</span> 解构赋值:  <span class="hljs-keyword">let</span> &#123; type, payload &#125; = data   <span class="hljs-comment">//&#123; type: &quot;&quot;, payload: &quot;&quot; &#125;</span><br><span class="hljs-number">5.</span> ...展开合并：<br>    [...arr1, ...arr2]<br>    &#123;...obj1, ...obj2&#125;<br><span class="hljs-number">6.</span> 异步处理方案：<br>    <span class="hljs-number">1</span>)回调函数<br>    <span class="hljs-number">2</span>)<span class="hljs-title class_">Promise</span> - 解决回调地狱（默认pending状态，<span class="hljs-title function_">resolve</span>()后进入fullfilled状态进入.<span class="hljs-title function_">then</span>()，如果rejected则进入.<span class="hljs-title function_">catch</span>()）<br>        - <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>() 所有异步都结束(fullfilled)进入.<span class="hljs-property">then</span><br>        - <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>() 所有异步任一返回结果(fullfilled)就进入.<span class="hljs-title function_">then</span>() 或 任一被<span class="hljs-title function_">rejected</span>()则就进入.<span class="hljs-title function_">catch</span>()<br>        - <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>() 所有异步都变成<span class="hljs-title function_">rejected</span>()才会结束<br>    <span class="hljs-number">3</span>)generator 生成器 <span class="hljs-keyword">yield</span><br>    <span class="hljs-number">4</span>)<span class="hljs-keyword">async</span> <span class="hljs-keyword">await</span><br><span class="hljs-number">7.</span> <span class="hljs-keyword">class</span> 类：与<span class="hljs-title class_">Java</span>的类写法基本一致，支持箭头函数、构造函数、babel-loader<br><span class="hljs-number">8.</span> modules 模块化规范：<br>    <span class="hljs-number">1</span>)导出 <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> aaa<br>      导入 <span class="hljs-keyword">import</span> obj <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span><br>    <span class="hljs-number">2</span>)导出 <span class="hljs-keyword">export</span> &#123;bbb&#125;  或 <span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> bbb = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>      导入 <span class="hljs-keyword">import</span> &#123;bbb&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./b&#x27;</span><br>    <span class="hljs-variable constant_">AMD</span> - 前端异步加载 - 提前下载，提前加载 <span class="hljs-built_in">require</span>.<span class="hljs-property">js</span><br>    <span class="hljs-variable constant_">CMD</span> - 异步加载 - 提前下载，按需加载 - sea.<span class="hljs-property">js</span><br>    <span class="hljs-title class_">CommonJS</span> - 同步加载（webpack） --&gt;  <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>)   =&gt;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>   =&gt;<span class="hljs-built_in">exports</span><br>    <span class="hljs-title class_">ES6</span>可以导入某几个方法；<span class="hljs-title class_">CommonJS</span>是默认导入一个文件<br><span class="hljs-number">9.</span> <span class="hljs-title class_">Generator</span> 异步遍历器<br>    场景：一个数组中均为异步任务，在 <span class="hljs-keyword">for</span> 循环中进行挨个按顺序执行<br></code></pre></td></tr></table></figure>

<h3 id="Generator-异步遍历器-★"><a href="#Generator-异步遍历器-★" class="headerlink" title="Generator 异步遍历器(★)"></a>Generator 异步遍历器(★)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">t</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;data-&quot;</span> + t);<br>            &#125;, t);<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 定义一个异步遍历器，每次yield返回一个promise</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> *<span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timer</span>(<span class="hljs-number">1000</span>)<br>        <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timer</span>(<span class="hljs-number">2000</span>)<br>        <span class="hljs-keyword">yield</span> <span class="hljs-title function_">timer</span>(<span class="hljs-number">3000</span>)<br>    &#125;<br>    <span class="hljs-comment">// 使用 async + await 遍历异步遍历器</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> g = <span class="hljs-title function_">gen</span>()<br>        <span class="hljs-comment">// 将异步遍历器放入在数组中</span><br>        <span class="hljs-keyword">let</span> arr = [g.<span class="hljs-title function_">next</span>(), g.<span class="hljs-title function_">next</span>(), g.<span class="hljs-title function_">next</span>()];<br>        <span class="hljs-comment">//每次循环都等待上一个promise执行完成，也就是 for await 循环中的代码块完全执行完</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;start-&quot;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;end-&quot;</span>, <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">test</span>(); <span class="hljs-comment">// 依次1s后输出 data-1, 此时再过2s后输出 data-2, 此时再过3s后输出 data-3</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>



<h2 id="Vue-★"><a href="#Vue-★" class="headerlink" title="Vue(★)"></a>Vue(★)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> 单项数据流 &amp; 双向数据绑定<br>    单向数据流：修改一边，另一边不会同步改变<br>    双向数据绑定：数据或视图任何一个发生改变，另一个都会实时改变<br><span class="hljs-number">2.</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>() 有什么缺点<br>    <span class="hljs-number">1</span>)无法监听 es6 的 <span class="hljs-title class_">Set</span>、<span class="hljs-title class_">Map</span> 变化<br>    <span class="hljs-number">2</span>)无法监听 <span class="hljs-keyword">class</span> 类型的数据<br>    <span class="hljs-number">3</span>)属性的新加或删除也无法监听<br>    <span class="hljs-number">4</span>)数组元素的增加和删除也无法监听<br><span class="hljs-number">3.</span> <span class="hljs-variable constant_">MVC</span>/<span class="hljs-variable constant_">MVP</span>/<span class="hljs-variable constant_">MVVM</span><br>    <span class="hljs-attr">MVC</span>: <span class="hljs-title class_">Model</span>-<span class="hljs-title class_">View</span>-<span class="hljs-title class_">Controller</span> （观察者模式通过<span class="hljs-title class_">View</span>，强依赖<span class="hljs-title class_">Model</span>，无法组件化无法复用）<br>    <span class="hljs-attr">MVP</span>: <span class="hljs-title class_">Model</span>-<span class="hljs-title class_">View</span>-<span class="hljs-title class_">Presenter</span>  （<span class="hljs-title class_">View</span>不依赖<span class="hljs-title class_">Model</span>，<span class="hljs-title class_">View</span>可以组件化，<span class="hljs-title class_">View</span>-<span class="hljs-title class_">Model</span>需要手动同步，维护困难）<br>    <span class="hljs-attr">MVVM</span>: <span class="hljs-title class_">Model</span>-<span class="hljs-title class_">View</span>-<span class="hljs-title class_">ViewModel</span> （双向绑定机制，提高代码可维护性和复用性）<br><span class="hljs-number">4.</span> 生命周期<br>    <span class="hljs-attr">vue2</span>: beforeCreate/created, beforeMount/<span class="hljs-title function_">mounted</span>(操作<span class="hljs-variable constant_">DOM</span>等), beforeUpdate/updated, beforeDestroy/destroyed<br>    <span class="hljs-attr">vue3</span>: setup/setup, onBeforeMount/<span class="hljs-title function_">onMounted</span>(操作<span class="hljs-variable constant_">DOM</span>等), onBeforeUpdate/onUpdated, onBeforeUnmount/onUnmounted<br><span class="hljs-number">5.</span> <span class="hljs-title class_">Vue</span>响应式数据原理？<br>    响应式原理：<br>      <span class="hljs-number">1</span>)利用 <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>() 的方法里的 【setter 和 getter】 方法的 观察者模式(拦截)。<br>      <span class="hljs-number">2</span>)组件初始化会【给每个data属性注册 setter和getter】，然后再 <span class="hljs-keyword">new</span> 一个自己的 【watcher】 对象，它会立即调用【render函数生成虚拟<span class="hljs-variable constant_">DOM</span>】<br>      <span class="hljs-number">3</span>)render时就会需要data的属性值，就会遍历所有的 watcher 对象，对虚拟<span class="hljs-variable constant_">DOM</span>会进行新旧对比diff算法，以最小patch补丁的方式更新<span class="hljs-variable constant_">DOM</span><br>    <span class="hljs-title class_">Proxy</span> 与 <span class="hljs-title class_">Object</span>.<span class="hljs-property">defineProperty</span> 优劣对比？<br>      - <span class="hljs-title class_">Proxy</span>: 可以直接监听对象而非属性，监听数组的变化，超过<span class="hljs-number">13</span>种拦截方法，返回的是新对象，只操作新的对象达到目的，有浏览器兼容性问题<br>      - <span class="hljs-title class_">Object</span>.<span class="hljs-property">defineProperty</span>: 遍历对象属性直接修改，兼容性好，支持<span class="hljs-title class_">IE9</span><br><span class="hljs-number">6.</span> <span class="hljs-title class_">Composition</span> <span class="hljs-variable constant_">API</span>组合式<span class="hljs-variable constant_">API</span>有哪些新的体验，为什么需要这个？<br>    <span class="hljs-number">1</span>)可读性和可维护性高，类似 react 的 hook 写法<br>    <span class="hljs-number">2</span>)更好的重用逻辑代码，在 <span class="hljs-title class_">Option</span> <span class="hljs-variable constant_">API</span>中只能通过 <span class="hljs-title class_">Mixins</span>重用逻辑代码，容易发生命名冲突且关系不清晰<br>    <span class="hljs-number">3</span>)解决生命周期函数包含不相关的逻辑，又不得不把逻辑分离到了不同方法中的问题<br><span class="hljs-number">7.</span> <span class="hljs-title class_">Vue</span> 对比 jQuery<br>    <span class="hljs-attr">jQuery</span>: 专注视图层，通过直接操作 <span class="hljs-variable constant_">DOM</span> 去实现页面的逻辑渲染<br>    <span class="hljs-title class_">Vue</span>: 专注于数据层，数据双向绑定，最终表现在<span class="hljs-variable constant_">DOM</span>层面，减少了<span class="hljs-variable constant_">DOM</span>操作；组件化思想，使项目子集职责清晰，提高开发效率，方便重用和协同开发<br><span class="hljs-number">8.</span> <span class="hljs-title class_">Vue</span> 单文件组件中定义全局<span class="hljs-variable constant_">CSS</span>： &lt;style&gt;标签中不添加 <span class="hljs-string">&#x27;scoped&#x27;</span> 属性，默认为全局 <span class="hljs-variable constant_">CSS</span> 样式<br><span class="hljs-number">9.</span> $root, $parent, $refs<br>    <span class="hljs-attr">$root</span>: 访问父组件属性和方法，根父组件实例<br>    <span class="hljs-attr">$parent</span>: 访问父组件属性和方法，最近一级的父组件实例<br>    <span class="hljs-attr">$refs</span>: 子组件标签定义 ref 属性，在父组件中可以使用 $refs 访问子组件实例<br><span class="hljs-number">10.</span> 自定义指令(用的少)：标签上可以添加一个 v-xxx 指令，就能够在插入到<span class="hljs-variable constant_">DOM</span>后，对该节点进行相应的操作；分全局指令和局部指令<br><span class="hljs-number">11.</span> 过滤器（vue3已废弃）：全局/局部过滤器，对数据进行处理，可以传递参数，使用方式参考 &#123;&#123; message | capitalize &#125;&#125;<br><span class="hljs-number">12.</span> <span class="hljs-title class_">Vue</span>单页面应用的优缺点：<br>    优点：<br>      <span class="hljs-number">1</span>)内容改变不需要加载整个页面，响应性极高<br>      <span class="hljs-number">2</span>)没有页面之间的切换，不会出现白屏现象<br>      <span class="hljs-number">3</span>)服务器压力小，吞吐能力提高<br>      <span class="hljs-number">4</span>)良好的前后端分离<br>    缺点：<br>      <span class="hljs-number">1</span>)首次加载耗时较多 - 需要路由懒加载处理<br>      <span class="hljs-number">2</span>)<span class="hljs-variable constant_">SEO</span>问题，不利于搜索引擎收录 - 需要<span class="hljs-variable constant_">SSR</span>服务端渲染处理<br>      <span class="hljs-number">3</span>)容易造成 <span class="hljs-variable constant_">CSS</span> 命名冲突<br>      <span class="hljs-number">4</span>)前进、后退、地址栏、书签等需要程序管理，页面复杂度高，开发成本较高<br><span class="hljs-number">13.</span> <span class="hljs-title class_">Vue</span>-router 使用 params 和 query 传参有什么区别？<br>    <span class="hljs-attr">params</span>: 需要<span class="hljs-string">&#x27;name&#x27;</span>来引入，接参都是 <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span> 和 <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>; 路由的一部分，必须要有 <br>    <span class="hljs-attr">query</span>: 需要<span class="hljs-string">&#x27;path&#x27;</span>来引入，接参都是 <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span> 和 <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>; 拼接在 url 后面的参数<br><span class="hljs-number">14.</span> keep-alive 的作用<br>    vue的内置组件，可以使被包含的组件保留状态，避免重新渲染。即mounted/created等钩子函数只会在第一次进入组件时调用，再次切换回来将不会调用；<br>    切换时做其他事情，需要使用【actived和deactived】这两个钩子函数（只有被 keep-alive 包裹时才有这两个生命周期钩子函数）<br><span class="hljs-number">15.</span> vue如何实现单页面应用：利用 hash 和 history 以及监听其路由变化<br>    <span class="hljs-attr">hash</span>: 监听浏览器 <span class="hljs-title function_">onhashchange</span>() 事件变化，查找对应的路由规则<br>    <span class="hljs-attr">history</span>: 监听浏览器的 pushState 和 replaceState 两个<span class="hljs-variable constant_">API</span>方法，使用 <span class="hljs-title function_">onpopstate</span>() 监听<span class="hljs-variable constant_">URL</span>变化<br><span class="hljs-number">16.</span> 列举vue中指令和用法：<br>    v-<span class="hljs-keyword">if</span>    判断是否隐藏，用来判断元素是否创建<br>    v-show  元素的显示和隐藏，类似css中的 display的block和none<br>    v-<span class="hljs-keyword">for</span>   遍历数据，必须添加key，提高性能(虚拟<span class="hljs-variable constant_">DOM</span>的diff算法打补丁更新<span class="hljs-variable constant_">DOM</span>-性能核心)<br>    v-bind  绑定属性<br>    v-model 双向绑定属性<br><span class="hljs-number">17.</span> 如何实现一个路径渲染多个组件？<br>    通过命名视图&lt;router-view&gt;允许同一界面拥有多个【单独命名】的视图。没有取名字则为 <span class="hljs-keyword">default</span><br>    比如：<br>      &lt;router-view <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;view left-sidebar&quot;</span> name=<span class="hljs-string">&quot;LeftSidebar&quot;</span>&gt;&lt;/router-view&gt;<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view main-content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;view right-sidebar&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RightSidebar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span></span><br><span class="hljs-number">18.</span> 如何实现多个路径共享一个组件？<br>    只需要将多个路径的 component 字段的值设置为同一个组件即可<br>    比如: <span class="hljs-keyword">const</span> routes = [<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> &#125;,<br>      &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> &#125; ]<br><span class="hljs-number">19.</span> 如何监测动态路由的变化？<br>    <span class="hljs-number">1</span>)通过 watch 方法来对 $route 进行监听;  <span class="hljs-number">2</span>)通过导航守卫的钩子函数 beforeRouteUpdate 来监听它的变化。<br><span class="hljs-number">20.</span> vue-router 中的 router-link 上的 v-slot 属性怎么用？<br>    高阶<span class="hljs-variable constant_">API</span>，通过作用域插槽暴露底层的定制能力。多数情况用在 <span class="hljs-title class_">NavLink</span> 这样的自定义组件里。<br>    比如：<br>      &lt;router-link custom to=<span class="hljs-string">&quot;/films&quot;</span> v-slot=<span class="hljs-string">&quot;&#123;isActive, navigate&#125;&quot;</span>&gt;<br>    	<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;isActive ? &#x27;jerry-active&#x27; : &#x27;&#x27;&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;navigate&quot;</span>&gt;</span>电影<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>      &lt;/router-link&gt;<br><span class="hljs-number">21.</span> <span class="hljs-title class_">Vue</span>中如何去除 url 中的 #<br>    将路由模式改为 <span class="hljs-string">&#x27;history&#x27;</span> 模式。<br>    问题: 页面路径访问时有些 url 会认为是资源请求，可能会出现 <span class="hljs-number">404</span> 的情况。<br>    解决: 服务端的 nginx 中配置为 默认没有找到的页面都重定向到 首页 index.<span class="hljs-property">html</span><br><span class="hljs-number">22.</span> $route 和 $router 的区别<br>    <span class="hljs-attr">$route</span>: 获取路由信息，包含 name,meta,path,hash,query,params,fullPath,matched,redirectedFrom等<br>    <span class="hljs-attr">$router</span>: 操作路由跳转，它是<span class="hljs-title class_">VueRouter</span>实例，包含了路由跳转方法 push, go, replace, 钩子函数等<br><span class="hljs-number">23.</span> <span class="hljs-title class_">Vue</span>路由守卫(路由拦截器)<br>    router.<span class="hljs-title function_">beforeEach</span>(...)   router.<span class="hljs-title function_">afterEach</span>(...)<br>    参数：<br>      <span class="hljs-attr">to</span>: 即将要进入的目标路由对象<br>      <span class="hljs-attr">from</span>: 当前导航即将要离开的路由对象<br>      <span class="hljs-attr">next</span>: 调用该方法后，才能进入下一个钩子函数 afterEach<br><span class="hljs-number">24.</span> <span class="hljs-title class_">Vue</span>路由底层原理:<br>    <span class="hljs-title class_">Vue</span>中利用数据劫持defineProperty在原型 prototype 上初始化了一些 getter，分别是router代表的当前<span class="hljs-title class_">Router</span>实例、route代表的<span class="hljs-title class_">Router</span>信息<br>    在install中也全局注册了router-view、router-link，其中 <span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-property">defineReactive</span> 是vue里观察者劫持数据的方法:<br>      - 劫持 _route 当出发 setter方法时，会通知到依赖的组件<br>    接下来的init中，会挂载判断是路由的模式，是history或者是hash，点击行为按钮，调用 hashchange 或者 popstate 监听事件方法<br>    同时更新_route，再触发 route-view 的重新渲染。<br><span class="hljs-number">25.</span> 路由懒加载: <span class="hljs-title class_">Vue</span> <span class="hljs-title class_">Router</span> 支持开箱即用的 <span class="hljs-string">`动态导入`</span>，首屏加载时只关联需要的静态资源，如js、css等<br><span class="hljs-number">26.</span> 插槽用过吗？具名插槽还是匿名插槽？<br>    都使用过。插槽就是预留一个组件的位置，将写在组件内的内容放入替换掉。写一个插槽就替换一次，多次就替换多次。<br>    为了自定义插槽的位置可以给插槽取名，根据插槽名字进行内容插入替换。一一对应<br><span class="hljs-number">27.</span> <span class="hljs-title class_">Vue</span>-loader 解释一下<br>    解析和转换 .<span class="hljs-property">vue</span> 文件，提取出其中的逻辑代码 script、样式代码 style、以及 <span class="hljs-variable constant_">HTML</span> 模版 template，分别交给 <span class="hljs-title class_">Loader</span> 去处理。<br><span class="hljs-number">28.</span> <span class="hljs-title class_">Vue</span>和<span class="hljs-title class_">React</span>的 diff 算法区别:<br>    相同: 都是忽略跨级，即<span class="hljs-string">`同级比较`</span>。<br>    不同: <br>      <span class="hljs-number">1</span>)vue diff时调动patch函数，参数是 vnode 和 oldVnode 分别代表新旧节点<br>      <span class="hljs-number">2</span>)vue 对比节点: 当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建；react 则认为是同类型节点，只是修改节点属性<br>      <span class="hljs-number">3</span>)vue 对比列表: 采用两端到中间的对比方式；react 则是从左到右依次对比 ——整体来说 vue 的执行效率更高效！<br><span class="hljs-number">29.</span> <span class="hljs-title class_">Vue</span> 生命周期中 create 和 mount 的区别:<br>    <span class="hljs-attr">create</span>: 组件初始化阶段，主要完成数据观测data observer、属性和方法的运算、watch/event事件回调，还为生成真实<span class="hljs-variable constant_">DOM</span>，无法获取<span class="hljs-variable constant_">DOM</span>元素<br>    <span class="hljs-attr">mount</span>: 从虚拟<span class="hljs-variable constant_">DOM</span>到真实<span class="hljs-variable constant_">DOM</span>挂载完成，此时html已经渲染出来了，可以直接操作 <span class="hljs-variable constant_">DOM</span> 节点了<br><span class="hljs-number">30.</span> axios 的使用，实现登陆功能的流程？<br>    axios 是请求 api 资源的模块。大多数情况下需要封装请求和响应拦截器，来进行 登陆拦截(路由跳转、提示等)<br><span class="hljs-number">31.</span> computed 和 watch 的区别？watch 实现原理？watch 的写法有几种？<br>    都是基于 data 中声明过 或 父组件传递的 props 数据<br>    <span class="hljs-attr">computed</span>: 计算属性 <span class="hljs-number">1</span>)支持缓存  <span class="hljs-number">2</span>)不支持异步  <span class="hljs-number">3</span>)默认走缓存  <span class="hljs-number">4</span>)一个属性依赖其他属性计算时常用  <span class="hljs-number">5</span>)属性值是函数默认走get方法,数据变化走set方法<br>    <span class="hljs-attr">watch</span>: 属性监听 <span class="hljs-number">1</span>)不支持缓存  <span class="hljs-number">2</span>)支持异步  <span class="hljs-number">3</span>)监听函数有<span class="hljs-number">2</span>个参数,一个是新值,一个是旧值  <span class="hljs-number">4</span>)属性变化时则会执行监听逻辑,一对多  <span class="hljs-number">5</span>)额外两个常用参数:<br>       - <span class="hljs-attr">immediate</span>: 组件加载时，立即出发回调函数执行<br>       - <span class="hljs-attr">deep</span>: 深度监听，对象内部值发生变化、复杂类型的数据时使用<br><span class="hljs-number">32.</span> <span class="hljs-title class_">Vue</span> <span class="hljs-string">`$forceUpdate`</span> 原理（用的少）<br>    作用: 迫使 vue 实例重新渲染那。仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件<br>    原理: 依赖发生变化的时候会通知 watcher，然后通知 watcher来调用 update 方法。<br><span class="hljs-number">33.</span> v-<span class="hljs-keyword">for</span> <span class="hljs-title function_">key</span>(关键字)<br>    :key=<span class="hljs-string">&quot;唯一标识&quot;</span> 是为 vue 中的 vnode 标记唯一id，通过这个key 在 diff算法中可以更准确和快速<br>    diff 算法的过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的 key 与旧节点进行对比，然后将差异打 patch 补丁方式渲染 <span class="hljs-variable constant_">DOM</span><br><span class="hljs-number">34.</span> 为什么要设置key值，可以使用 index 值吗？为什么不能？<br>    使用 key 时为了标记遍历节点的唯一性，更好的利用 diff 算法的性能；如果使用 index 时，在列表中间进行 <span class="hljs-string">&#x27;新增/删除&#x27;</span> 时会增加计算复杂度和性能问题。<br>    核心原因: index 索引在中间新增/删除时，对应节点后面的索引值全部会发生变化，diff时也会重新计算，复杂度上升。<span class="hljs-string">`只在没有唯一标识时才会选择使用`</span><br><span class="hljs-number">35.</span> diff 算法的原理<br>    <span class="hljs-attr">diff</span>: 通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 <span class="hljs-title function_">O</span>(n)<br>    特点: <span class="hljs-number">1</span>)只会同<span class="hljs-string">&#x27;层级比较&#x27;</span>  <span class="hljs-number">2</span>)比较过程中循环从<span class="hljs-string">&#x27;两边向中间&#x27;</span>收拢<br><span class="hljs-number">36.</span> vue 组件中的 data 为什么是函数？根组件却是对象呢？<br>    data 是函数，内部的私有数据空间对于每个不同的组件更具有复用性，不会在复用的组件之间造成一改全改的影响。<br>    这是 js 的特性带来的，与 vue 的设计无关。<br><span class="hljs-number">37.</span> vue 的组件通信:<br>    <span class="hljs-number">1</span>)props和$emit<br>    <span class="hljs-number">2</span>)$attrs和$listeners<br>    <span class="hljs-number">3</span>)中央事件总线 bus<br>    <span class="hljs-number">4</span>)provide和inject<br>    <span class="hljs-number">5</span>)v-model<br>    <span class="hljs-number">6</span>)$parent和$children<br>    <span class="hljs-number">7</span>)boradcast和dispatch<br>    <span class="hljs-number">8</span>)vuex|pinia公共状态管理（处理业务逻辑复杂的状态管理）<br><span class="hljs-number">38.</span> vuex|pinia 什么情况下使用？<br>    如果应用简单，最好不去使用 vuex或pinia，一个简单的 store 或 父子通信即可。<br>    vuex工作流: vue components <span class="hljs-title function_">commit</span>() -&gt; mutations 只支持同步 -&gt; state render components<br>               vue components <span class="hljs-title function_">dispatch</span>() -&gt; actions 同步和异步 -&gt; state render components<br><span class="hljs-number">39.</span> vuex可以直接修改state的值吗？<br>    可以修改，但是极不推荐，因为无法被 devtool 监控，无法检测数据、快照、漫游/回滚都不被支持了。<br><span class="hljs-number">40.</span> mutations 为什么不支持异步？<br>    为了支持 devtools 的数据检测、快照、漫游/回滚，所以需要有同步的操作在 mutations，异步操作可以到 actions 中进行。<br><span class="hljs-number">41.</span> 访问和修改 vuex 的状态<br>    访问: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.属性<br>    修改: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;mutation中的方法&#x27;</span>)<br><span class="hljs-number">42.</span> vuex 缺点: 如果不是开发大型单页应用，使用vuex是繁琐和冗余的，并且 state 中的值会伴随着浏览器的刷新而初始化，无缓存。<br><span class="hljs-number">43.</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>() 是什么？<br>    <span class="hljs-title function_">nextTick</span>() 是 <span class="hljs-title class_">Vue3</span> 中的一个核心函数，它的作用是延迟执行某些操作，直到下一次 <span class="hljs-variable constant_">DOM</span> 更新循环结束之后再执行。<br>    常用在修改数据之后立即使用这个方法，可以获取更新后的<span class="hljs-variable constant_">DOM</span>。即 等<span class="hljs-variable constant_">DOM</span>加载完以后再去调用 <span class="hljs-title function_">nextTick</span>() 获取<span class="hljs-variable constant_">DOM</span>里面的数据内容。<br><span class="hljs-number">44.</span> <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>()知道吗？实现原理是什么？是宏任务还是微任务？<br>    nextTick 是<span class="hljs-string">&#x27;微任务&#x27;</span>，使用了宏任务与微任务，定义了一个异步方法，多次调用nextTick会存入一个队列中，通过异步方法清空队列。<br>    用于下次<span class="hljs-variable constant_">DOM</span>更新循环结束之后执行延迟回调。<br><span class="hljs-number">45.</span> 虚拟<span class="hljs-variable constant_">DOM</span>为什么能提高性能？<br>    其实就是一个<span class="hljs-title class_">JavaScript</span>对象，通过这个对象描述真实<span class="hljs-variable constant_">DOM</span>，利用 <span class="hljs-variable constant_">DOM</span> diff 对比算法避免了没有必要的 dom 操作，最小代价更新视图操作。<br><span class="hljs-number">46.</span> <span class="hljs-title class_">Vue</span>性能优化做过哪些？<br>    <span class="hljs-number">1</span>)首屏加载优化<br>    <span class="hljs-number">2</span>)路由懒加载<br>    <span class="hljs-number">3</span>)开发服务器<span class="hljs-title class_">Gzip</span><br>    <span class="hljs-number">4</span>)启动<span class="hljs-variable constant_">CDN</span>加速<br>    <span class="hljs-number">5</span>)代码层面优化：<br>        <span class="hljs-number">5.1</span>)computed和watch区分使用场景：computed-计算属性，依赖缓存；watch-监听值改变，触发回调操作<br>        <span class="hljs-number">5.2</span>)v-<span class="hljs-keyword">if</span>和v-show区分使用场景：v-<span class="hljs-keyword">if</span>在不需要频繁切换场景使用；v-show会在页面加载时就创建<br>        <span class="hljs-number">5.3</span>)v-<span class="hljs-keyword">for</span>遍历为item添加key：唯一id会提高性能<br>        <span class="hljs-number">5.4</span>)webpack配置：对图片进行压缩<br>        <span class="hljs-number">5.5</span>)避免内存泄露：尽量避免使用闭包<br>        <span class="hljs-number">5.6</span>)减少<span class="hljs-title class_">ES6</span>转为<span class="hljs-title class_">ES5</span>的冗余代码<br><span class="hljs-number">47.</span> <span class="hljs-title class_">Vue</span>常用修饰符：<br>    v-model：<br>      .<span class="hljs-property">lazy</span> 输入框可以实现光标离开才会更新数据<br>      .<span class="hljs-property">trim</span> 输入框过滤收尾的空格<br>      .<span class="hljs-property">number</span> 输入框输入值转为数字<br>    事件修饰符：<br>      .<span class="hljs-property">stop</span> 阻止事件冒泡<br>      .<span class="hljs-property">prevent</span> 阻止默认行为<br>      .<span class="hljs-property">self</span> 只有元素本身触发时才触发方法<br>      .<span class="hljs-property">once</span> 事件只执行一次<br>      .<span class="hljs-property">capture</span> 捕获阶段触发<br>      .<span class="hljs-property">sync</span> 对prop进行双向绑定<br>      .<span class="hljs-property">keyCode</span> 监听按键指令<br><span class="hljs-number">48.</span> <span class="hljs-title class_">Vue</span>中template的编译过程：<br>    经过 <span class="hljs-title function_">parse</span>() 生成 ast（抽象语法树），optimize 对静态节点优化，<span class="hljs-title function_">generate</span>() 生成 render 字符串，之后调用 <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() 函数，用来监听数据的变化。<br>    数据更新 <span class="hljs-title class_">Vnode</span> 会与数据改变之前的 <span class="hljs-title class_">Vnode</span> 做 diff计算，对内容做改动之后，就会更新到真正的 <span class="hljs-variable constant_">DOM</span><br><span class="hljs-number">49.</span> <span class="hljs-title class_">Vue3</span><span class="hljs-number">.0</span> 的了解<br>    vue3亮点: <span class="hljs-number">1</span>)性能更快<span class="hljs-number">1.2</span>-<span class="hljs-number">2</span>倍 <span class="hljs-number">2</span>)按需编译，体积小 <span class="hljs-number">3</span>)组合式<span class="hljs-variable constant_">API</span> <span class="hljs-number">4</span>)支持<span class="hljs-variable constant_">TS</span> <span class="hljs-number">5</span>)先进的组件<br>      <span class="hljs-number">1</span>)性能更快<span class="hljs-number">1.2</span>-<span class="hljs-number">2</span>倍：diff算法更快、静态提升、事件侦听缓存<br>      <span class="hljs-number">2</span>)按需编译，体积小：利用<span class="hljs-title class_">ES6</span>的<span class="hljs-keyword">import</span>进行按需加载<br>      <span class="hljs-number">3</span>)组合式<span class="hljs-variable constant_">API</span>： <span class="hljs-title function_">VCA</span>(<span class="hljs-title class_">Vue</span> <span class="hljs-title class_">Composition</span> <span class="hljs-variable constant_">API</span>) 更专注自己的 data method computed watch等<br><span class="hljs-number">50.</span> ref和reactive的理解：<br>    <span class="hljs-attr">ref</span>: 对vue3监听数据的方法，本质都是proxy；ref支持对基本类型和复杂类型，一般是监听基本类型；ref底层还是reactive，封装多了一层value<br>    <span class="hljs-attr">reactive</span>: 对vue3监听数据的方法，本质都是proxy；reactive只能监听对象、数组、json；<br><span class="hljs-number">51.</span> <span class="hljs-title class_">Vuex</span>和redux区别 和 共同思想：<br>    vuex 改进了 redux 中的 action 和 reducer 函数，以 mutations 变化函数取代 reducer 无需 <span class="hljs-keyword">switch</span> 只需在对应mutation函数里改变state；<br>    vuex 自动重新渲染的特性，无需订阅，只要生成新的 state；<br>    vuex 数据流的顺序：view调用 store.<span class="hljs-property">commit</span> 提交对应请求到 store 中对应 mutation --&gt; store 改变(vue检测数据变化则渲染)<br>    共同思想: 单一数据源、变化可预测、<span class="hljs-variable constant_">MVVM</span>思想、vuex借鉴了redux将store作为全局数据中心进行管理<br><span class="hljs-number">52.</span> 微信小程序 和 vue 的区别：<br>    生命周期: 小程序的钩子函数更简单，跳转方式不一样钩子函数对应就也不一样<br>    数据绑定: vue使用:冒号绑定动态数据、小程序绑定是使用&#123;&#123;&#125;&#125;双大括号<br>    列表循环: wx-<span class="hljs-keyword">for</span> 与 v-<span class="hljs-keyword">for</span> <br>    显示与隐藏: vue中 v-<span class="hljs-keyword">if</span>和v-show，小程序中 wx-<span class="hljs-keyword">if</span> 和 hidden<br>    事件处理: vue中 v-<span class="hljs-attr">on</span>:event或@event绑定事件，小程序中 bindtap或catchtap绑定事件<br>    数据双向绑定: vue中可以通过 v-model绑定表单组件<br>    绑定事件传参: vue中形参传入、小程序中需要绑定到 data-属性 上，在事件方法中通过 e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">dataset</span>.* 的方式获取<br>    父子组件通信: 父传子-子组件通过v-bind传入值，子组件内部通过props接收；小程序没有v-bind，通过直接将值复制给一个变量，子组件properties中接收值<br><span class="hljs-number">53.</span> 管理系统项目 vue与react 如何选择？<br>    项目成员水平: 如果js基础较好、编码能力较强则选择 <span class="hljs-title class_">React</span> 否则 vue<br>    系统的大小: 构建生态系统选择 react；如果要求快、简单、能用就行、选择 vue<br>    系统运行环境: 如果适用于web端和原生<span class="hljs-variable constant_">APP</span>框架，选择 <span class="hljs-title class_">React</span>(<span class="hljs-variable constant_">RN</span>)，生态更好<br></code></pre></td></tr></table></figure>



<h2 id="React-★"><a href="#React-★" class="headerlink" title="React(★)"></a>React(★)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> react 类组件和函数组件的区别<br>    <span class="hljs-number">1</span>)函数组件是个函数，返回一个jsx元素；类组件是 <span class="hljs-title class_">ES6</span>语法糖<span class="hljs-keyword">class</span>定义，继承 component 这个类<br>    <span class="hljs-number">2</span>)类组件可以通过 state 进行状态管理，函数组件不能使用 <span class="hljs-title function_">setState</span>()，在 react16<span class="hljs-number">.8</span>+ 以上函数组件可以通过hooks的 <span class="hljs-title function_">useState</span>()来模拟状态管理<br>    <span class="hljs-number">3</span>)类组件有一系列生命周期钩子函数；函数组件需要借助hooks来使用生命周期函数<br>    <span class="hljs-number">4</span>)类组件捕获最新的值（永远保持一致）；函数组件捕获渲染所需的值，因为有闭包的特性，无法从外部进行更改<br><span class="hljs-number">2.</span> react 事件绑定原理<br>    基于<span class="hljs-title class_">Virtual</span> <span class="hljs-variable constant_">DOM</span>的基础上实现了合成事件，小驼峰命名： <span class="hljs-number">1</span>)事件注册 <span class="hljs-number">2</span>)事件合成 <span class="hljs-number">3</span>)批处理<br><span class="hljs-number">3.</span> react 中的 <span class="hljs-title function_">setState</span>() 缺点是什么<br>    <span class="hljs-number">1</span>)默认是异步的，但在原生事件和 <span class="hljs-built_in">setTimeout</span> 中都是同步的<br>    <span class="hljs-number">2</span>)无法立即拿到更新后的值，需要在第二个参数callback中拿到更新后的结果<br>    <span class="hljs-number">3</span>)批量更新也是异步，需要多次调用该方法实现批量<br><span class="hljs-number">4.</span> react 中 props 和 state 区别<br>    <span class="hljs-attr">props</span>: 外部组件传入的参数、组件通信使用、不可以在组件内修改-只能父组件修改<br>    <span class="hljs-attr">state</span>: 组件内部的状态变量、内部通过 setState 进行修改<br><span class="hljs-number">5.</span> 虚拟<span class="hljs-variable constant_">DOM</span>优劣？实现原理？<br>    虚拟<span class="hljs-variable constant_">DOM</span>是 js 模拟的一颗 dom 树，相当于加了一层 dom 缓存，利用 dom diff算法避免了没有必要的 dom 操作，从而提高性能。<br>    优点: 有效降低大面积的重绘和回流<br>    缺点: 首次渲染大量<span class="hljs-variable constant_">DOM</span>时，会比 innerHTML 慢<br><span class="hljs-number">6.</span> diff 与 key 之间的联系？<br>    两个虚拟<span class="hljs-variable constant_">DOM</span>在对比的时候，为了降低算法复杂度，利用 key 值的不同可以只对比不同的元素节点内容、以及批处理的合并操作等，实现最小补丁更新和渲染。<br><span class="hljs-number">7.</span> react 组件通信：<br>    <span class="hljs-number">1</span>)props - 父传子<br>    <span class="hljs-number">2</span>)实例方法 - 父组件用 refs 引用子组件，调用子组件的实例方法<br>    <span class="hljs-number">3</span>)回调函数 - 子传父，子组件调用props传递过来的方法<br>    <span class="hljs-number">4</span>)状态提升 - 两个子组件通过父组件定义的参数进行传参<br>    <span class="hljs-number">5</span>)<span class="hljs-title class_">Context</span>上下文 - 一般用于全局主题<br>    <span class="hljs-number">6</span>)公共状态管理 - mobx/redux/dva 通过在 view 中出发 action，改变 state 进而改变其他组件 state<br><span class="hljs-number">8.</span> react 中 refs 作用和原理：<br>    ref 是 react 提供用来操作组件实例或 <span class="hljs-variable constant_">DOM</span> 元素的接口，主要用来做文本框的聚焦、触发强制动画等...<br><span class="hljs-number">9.</span> react 生命周期函数： - 老<br>    <span class="hljs-number">1</span>)第一阶段：装载阶段 <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>), <span class="hljs-title function_">render</span>(), <span class="hljs-title function_">componentDidMount</span>()<br>    <span class="hljs-number">2</span>)第二阶段：更新阶段 [<span class="hljs-title function_">shouldComponentUpdate</span>()], <span class="hljs-title function_">render</span>(), <span class="hljs-title function_">componentDidUpdate</span>()<br>    <span class="hljs-number">3</span>)第三阶段：卸载阶段 <span class="hljs-title function_">componentWillUnmount</span>()<br><span class="hljs-number">10.</span> A组件嵌套B组件，生命周期执行顺序：<br>    父组件-constructor<br>    父组件-render<br>    子组件-constructor<br>    子组件-render<br>    子组件-componentDidMount<br>    父组件-componentDidMount<br><span class="hljs-number">11.</span> 新出的声明周期钩子函数？<br>    react16 废弃了三个钩子函数: componentWillMount/componentWillReceiveProps/componentWillUpdate<br>    react16<span class="hljs-number">.8</span> 以后新增的方法: <span class="hljs-title function_">getDerivedStateFromProps</span>() 静态方法 / <span class="hljs-title function_">getSnapshotBeforeUpdate</span>()<br><span class="hljs-number">12.</span> react hooks 用过吗？为什么要用？<br>    <span class="hljs-title function_">useState</span>() 创建状态，返回一个数组，第一个值为状态、第二个值为改变状态的函数<br>    <span class="hljs-title function_">useEffect</span>() 副作用，数据获取、dom操作影响页面，在渲染结束之后执行；第一个参数为函数，第二个参数为依赖列表；如果不传第二个参数则渲染完就执行<span class="hljs-number">1</span>次<br>    <span class="hljs-title function_">useRef</span>() 返回一个可变ref对象，整个生命周期不变；用来获取元素的实例，比如用于输入框聚焦或动画的触发<br>    <span class="hljs-title function_">useMemo</span>() 优化函数组件中的功能函数，在渲染期间执行 - 类似与 vue的 computed 计算属性<br>    <span class="hljs-title function_">useContext</span>() 获取上下文注入的值，接受一个context对象，返回该对象&lt;<span class="hljs-title class_">MyContext</span>.<span class="hljs-property">Provider</span>&gt;元素的value值：<span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>)<br>    <span class="hljs-title function_">useLayoutEffect</span>() 有<span class="hljs-variable constant_">DOM</span>操作的副作用，时机不同，在dom更新后马上<span class="hljs-string">&#x27;同步&#x27;</span>调用的代码，会阻塞页面渲染-防抖场景用；而 useEffect 是整个页面渲染完才调用<br>    <span class="hljs-title function_">useCallback</span>() 与 <span class="hljs-title function_">useMemo</span>() 类似，将函数缓存<br>    react-router<br>        <span class="hljs-title function_">useHistory</span>() 跳转路由<br>        <span class="hljs-title function_">useLocation</span>() 得到url对象<br>        <span class="hljs-title function_">useParams</span>() 得到url上的参数<br>    react-redux<br>        <span class="hljs-title function_">useSelector</span>() 共享状态，从redux的store中提取数据<br>        <span class="hljs-title function_">useDispatch</span>() 共享状态，返回redux的store中对dispatch的引用<br><span class="hljs-number">13.</span> hooks 的使用注意事项<br>    <span class="hljs-number">1</span>)只能在函数式组件 或 自定义hook 中使用hooks<br>    <span class="hljs-number">2</span>)不要在循环、条件或嵌套函数中调用 hooks，必须使用react函数的顶层hooks。原理是react的闭包会导致调用顺序的不一致性，从而产生难以预料的后果。<br><span class="hljs-number">14.</span> hooks 会取代 render props 和 高阶组件<span class="hljs-variable constant_">HOC</span> 吗？<br>    可以取代，但没必要。都在处理同一种问题：逻辑复用。<br><span class="hljs-number">15.</span> 列举重新渲染 render 的情况<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>() / <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">forceUpdate</span>() / 接收新的props / 通过状态管理mobx,redux等 / 改变上下文<br><span class="hljs-number">16.</span> 如何避免组件的重新渲染<br>    当 props/state 改变时，组件会执行 render 函数重新渲染：<br>    <span class="hljs-number">1</span>) <span class="hljs-keyword">class</span>组件中使用 <span class="hljs-title function_">shouldComponentUpdate</span>() 钩子函数<br>    <span class="hljs-number">2</span>) <span class="hljs-title class_">PureComponent</span>() 默认有避免重新渲染的功能<br>    <span class="hljs-number">3</span>) 函数组件使用高阶组件 memo 处理<br><span class="hljs-number">17.</span> 渲染一个 react 组件的过程<br>    <span class="hljs-number">1</span>) babel 编译<br>    <span class="hljs-number">2</span>) 生成 element<br>    <span class="hljs-number">3</span>) 生成真实节点（初次渲染）<br>    <span class="hljs-number">4</span>) 生命周期：挂载、更新、卸载<br><span class="hljs-number">18.</span> 类/函数组件怎么做性能优化？<br>    类组件性能优化: <span class="hljs-number">1</span>)使用 <span class="hljs-title function_">shouldComponentUpdate</span>()  <span class="hljs-number">2</span>)使用 <span class="hljs-title class_">React</span>.<span class="hljs-title class_">PureComponent</span>()  <span class="hljs-number">3</span>)使用 immutable持久化  <span class="hljs-number">4</span>)bind函数<br>    函数组件性能优化: <span class="hljs-number">1</span>)使用 <span class="hljs-title function_">useCallback</span>() 缓存函数  <span class="hljs-number">2</span>)使用 <span class="hljs-title function_">useMemo</span>() 进行缓存<br>    两者都可用: <span class="hljs-number">1</span>)<span class="hljs-title class_">React</span>.<span class="hljs-property">memo</span>  <span class="hljs-number">2</span>)使用key  <span class="hljs-number">3</span>)不要滥用props<br><span class="hljs-number">19.</span> react 按需加载<br>    <span class="hljs-number">1</span>)懒加载 <span class="hljs-title class_">React</span>.<span class="hljs-title function_">lazy</span>() 但是不支持服务端渲染<br>    <span class="hljs-number">2</span>)使用 <span class="hljs-title class_">Loadable</span> <span class="hljs-title class_">Components</span> 这个库<br><span class="hljs-number">20.</span> 纯函数 与 副作用函数特点：<br>    纯函数: 与外界交互只有参数和返回值，无状态、线程安全、结果可缓存-性能高<br>    副作用函数: 除参数和返回值外，还有附加影响，如调接口、修改全局变量、抛异常/错误终止、打印到终端/读取用户输入、读写文件等<br><span class="hljs-number">21.</span> react 的 <span class="hljs-title class_">StrictMode</span> 严格模式是什么？<br>    仅开发模式下运行，不会影响生产构建（关掉即可），作用：<br>    <span class="hljs-number">1</span>) 验证内部组件是否遵循某些推荐做法，否则给出警告<br>    <span class="hljs-number">2</span>) 验证是否使用已废弃的方法，否则给出警告<br>    <span class="hljs-number">3</span>) 识别潜在风险预防的作用<br><span class="hljs-number">22.</span> react 的 props 上使用属性校验<br>    使用 <span class="hljs-title class_">PropTypes</span> 进行类型检查，在 react15<span class="hljs-number">.5</span>+ 起，使用库 prop-typs  <span class="hljs-string">`import PropTypes from &#x27;prop-types&#x27;;`</span><br><span class="hljs-number">23.</span> 高阶组件、受控组件、非受控组件<br>    高阶组件<span class="hljs-attr">HOC</span>: 不是 react api的一部分，是基于react的设计模式；参数为组件、返回值为新组建的函数-无副作用<br>    受控组件: 被 react 以 state 作为唯一数据源的方式控制取值的表单输入元素<br>    非受控组件: 表单数据由 dom 节点来处理，而不是 state 来管理数据，一般可以用 ref 来从<span class="hljs-variable constant_">DOM</span>节点中获取表单数据<br>    【区别】<br>       <span class="hljs-number">1</span>)受控和非受控是表单中的组件、高阶组件是对某个组件注入一些属性和方法<br>       <span class="hljs-number">2</span>)高阶组件是 解决代码复用性 而产生的<br>       <span class="hljs-number">3</span>)受控组件必须要有一个 value；非受控组件相当于稻草 <span class="hljs-variable constant_">DOM</span>，一般有个 defaultValue<br><span class="hljs-number">24.</span> react 的路由：react-router来配置<br>    <span class="hljs-title class_">Router</span>: 对应路由两种模式 &lt;<span class="hljs-title class_">BrowserRouter</span>&gt; 和 &lt;<span class="hljs-title class_">HashRouter</span>&gt;<br>    matchRoutes组件: 控制路径对应显示组件，同步和异步加载 &lt;<span class="hljs-title class_">Route</span>&gt;<br>    navigation组件: 用作路由切换和跳转 &lt;<span class="hljs-title class_">Link</span>&gt;<br><span class="hljs-number">25.</span> react 路由懒加载<br>    <span class="hljs-number">1</span>) <span class="hljs-title class_">React</span>.<span class="hljs-property">lazy</span> 包裹组件，实现动态按需加载<br>    <span class="hljs-number">2</span>) react-loadable 库<br>    <span class="hljs-number">3</span>) webpack 配置 lazyload-loader<br>    <span class="hljs-number">4</span>) <span class="hljs-keyword">import</span> webpack v2+<br>    <span class="hljs-number">5</span>) <span class="hljs-built_in">require</span>.<span class="hljs-property">ensure</span> webpack v1/v2<br><span class="hljs-number">26.</span> react-router-dom 内部实现，怎么做路由守卫？<br>    利用 <span class="hljs-title class_">ContextAPI</span> 通过上下文对象将路由信息注入到 <span class="hljs-title class_">Router</span> 组件中，<span class="hljs-title class_">Router</span> 渲染的内容就是 <span class="hljs-title class_">ContextAPI</span> 的 <span class="hljs-title class_">Provider</span> 组件，然后接收 <span class="hljs-title class_">Router</span> <br>    组件中的当前路由信息对象。这样在<span class="hljs-title class_">Router</span>的所有组件下都能通过 <span class="hljs-string">&#x27;上下文&#x27;</span> 拿到当前路由信息对象<br>    路由守卫： 路由里设置 meta 元字符实现路由拦截<br><span class="hljs-number">27.</span> react 性能优化手段<br>    <span class="hljs-number">1</span>)使用纯组件<br>    <span class="hljs-number">2</span>)使用 <span class="hljs-title class_">React</span>.<span class="hljs-property">memo</span> 进行组件记忆<br>    <span class="hljs-number">3</span>)路由懒加载<br>    <span class="hljs-number">4</span>)列表渲染的时候加 key<br>    <span class="hljs-number">5</span>)使用 <span class="hljs-title class_">React</span> <span class="hljs-title class_">Fragments</span> 避免额外标记<br>    <span class="hljs-number">6</span>)不要使用内联函数定义<br>    <span class="hljs-number">7</span>)避免使用内联样式属性<br>    <span class="hljs-number">8</span>)优化 react 中的条件渲染<br>    <span class="hljs-number">9</span>)不要在 render 方法中导出数据<br>    <span class="hljs-number">10</span>)避免在 <span class="hljs-title class_">Willxxx</span>系列生命周期中进行异步请求、操作dom等<br>    <span class="hljs-number">11</span>)【函数组件】中 useCallback 和 useMemo进行组件优化<br>    <span class="hljs-number">12</span>)【类组件】使用 shouldComponentUpdate 决定什么时候渲染组件<br>    <span class="hljs-number">13</span>)【类组件】使用 immutable 对象<br>    <span class="hljs-number">14</span>)【类组件】事件函数在 <span class="hljs-title class_">Constructor</span> 中 绑定 bind 改变 <span class="hljs-variable language_">this</span> 指向<br><span class="hljs-number">28.</span> 描述 <span class="hljs-title class_">Flux</span> 与 <span class="hljs-variable constant_">MVC</span> 模式<br>    <span class="hljs-variable constant_">MVC</span>模式：model-view-controller 数据流不清晰、缺乏数据完整性<br>    <span class="hljs-title class_">Flux</span>模式：数据和逻辑永远单向流动、复杂用户界面不再收到级联更新、通过限制对共享数据的直接访问来加强数据完整性<br><span class="hljs-number">29.</span> redux 的三个原则：<br>    <span class="hljs-number">1</span>)单一数据源  <span class="hljs-number">2</span>)state是只读的  <span class="hljs-number">3</span>)使用纯函数来执行修改<br><span class="hljs-number">30.</span> setState 不能获取值怎么办？<br>    <span class="hljs-number">1</span>) addeventListener 添加的事件或者 dom事件中出发<br>    <span class="hljs-number">2</span>) 接收的餐食可以是一个函数<br>    <span class="hljs-number">3</span>) <span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span> 异步调用处理<br><span class="hljs-number">31.</span> redux 和 vuex 的设计思想 - 都是基于 <span class="hljs-title class_">Flux</span>模式<br>    <span class="hljs-attr">redux</span>: <span class="hljs-number">1</span>)单一数据源  <span class="hljs-number">2</span>)状态只读  <span class="hljs-number">3</span>)状态修改由纯函数完成<br>    <span class="hljs-attr">vuex</span>: <span class="hljs-number">1</span>)全局只有一个store实例  <span class="hljs-number">2</span>)mutations是同步事务  <span class="hljs-number">3</span>)actions处理异步事务  <span class="hljs-number">4</span>)模块化通过 <span class="hljs-variable language_">module</span> 方式来处理<br><span class="hljs-number">32.</span> redux 是同步的，为什么可以执行异步逻辑？<br>    通过 redux-thunk 中间件的作用，可以异步执行 redux。检查 action 以及通过 <span class="hljs-title function_">next</span>() 进行放行。<br><span class="hljs-number">33.</span> redux 的 saga 和 thunk 中间件的区别，优缺点<br>    区别: redux-thunk 异步采用 <span class="hljs-keyword">async</span>/<span class="hljs-keyword">await</span>; redux-saga 采取generate函数<br>    优缺: redux-thunk 库小、代码就几行； redux-saga 异步区分、更加优雅、适合大量api请求<br><span class="hljs-number">34.</span> redux 和 mobx 的区别<br>    <span class="hljs-number">1</span>)redux 是函数式的，mobx 是面向对象的<br>    <span class="hljs-number">2</span>)redux 理想是 immutable 的，每次都返回一个新的数据；mobx 从始至终都是一份引用<br>    <span class="hljs-number">3</span>)redux 利用 dispatch 进行广播，通过 <span class="hljs-title class_">Provider</span> 和 connect 来对比前后差别和更新粒度；mobx 组件可以做到更精确更新，基于 observer 可观察对象<br>    <span class="hljs-number">4</span>)redux 采用 <span class="hljs-title class_">Provider</span> 和 connect 方式； mobx 采用 <span class="hljs-title class_">Provider</span> 和 inject、observer<br><span class="hljs-number">35.</span> 什么是 immutable？为什么要用它？<br>    immutable 是持久化数据，一旦创建就不会被修改。修改时返回新的 immutable，但是原数据不会改变。<br>    redux中因为深拷贝对性能消耗极大，immutable <span class="hljs-string">`只拷贝改变的节点，从而节省性能`</span>。<br></code></pre></td></tr></table></figure>



<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> 简述微信小程序原理<br>    采用 js、wxml、wxss 三种技术进行开发，本质是一个单页面应用，所有页面渲染和事件处理都在一个页面内进行。<br>    数据驱动的架构模式，可以通过微信客户端调用原生的各种接口。<br>    <span class="hljs-variable constant_">UI</span>和数据分离，webview 和 appservice<br><span class="hljs-number">2.</span> 微信小程序的相关文件类型<br>   <span class="hljs-attr">WXML</span>: 结合基础组件、事件系统、构建页面结构、微信自定义的一套组件<br>   <span class="hljs-attr">WXSS</span>: 样式语言，描述<span class="hljs-variable constant_">WXML</span>的组件样式<br>   <span class="hljs-attr">JS</span>: 逻辑处理、网络请求<br>   <span class="hljs-title class_">JSON</span>: 小程序设置、如页面注册、页面标题、tabBar等<br>     app.<span class="hljs-property">json</span> 全局配置文件<br>     app.<span class="hljs-property">js</span> 全局入口文件<br>     app.<span class="hljs-property">wxss</span> 全局样式（可选）<br><span class="hljs-number">3.</span> 小程序的双向绑定 与 vue 有哪些不一样<br>    <span class="hljs-number">1</span>)小程序通过 <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>(&#123;&#125;) 修改值，才能同步到视图中<br>    <span class="hljs-number">2</span>)vue 上表单元素加 v-model 再绑定一个 data值，实现同步到视图<br>    <span class="hljs-number">3</span>)取值： 小程序中 <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">xxx</span>, vue中 <span class="hljs-variable language_">this</span>.<span class="hljs-property">xxx</span><br><span class="hljs-number">4.</span> 自定义小程序的 navigationBar<br>    思路: 隐藏原生样式、获取胶囊按钮、状态栏相关数据供后续计算、根据不同机型计算出该机型的导航栏高度 进行适配、编写新的导航栏引用到页面<br><span class="hljs-number">5.</span> 小程序中的 <span class="hljs-attr">wx</span>:<span class="hljs-keyword">if</span> 和 hidden 的区别<br>   <span class="hljs-attr">wx</span>:<span class="hljs-keyword">if</span> 条件为<span class="hljs-literal">true</span>显示、显示时创建元素、隐藏时销毁元素 - 适用于不频繁切换的场景<br>   hidden 提前创建元素，相当于display、显示时渲染、隐藏时保留 - 适用于频繁切换的场景<br><span class="hljs-number">6.</span> 小程序的 wxss 和 css 有哪些不一样的地方<br>    <span class="hljs-number">1</span>)尺寸单位 rpx： 以 iphone6 为基准，固定宽度 750rpx，对应设计稿为 750px，即可量取多少设置多少<br>    <span class="hljs-number">2</span>)使用 @<span class="hljs-keyword">import</span> 标识符导入外联样式，后面跟相对路径<br><span class="hljs-number">7.</span> 小程序页面间传递数据的方法<br>    <span class="hljs-number">1</span>)全局变量，放在 app.<span class="hljs-property">js</span><br>    <span class="hljs-number">2</span>)使用 wx.<span class="hljs-title function_">navigateTo</span>(不关闭当前页面) 和 wx.<span class="hljs-title function_">redirectTo</span>(关闭当前页面跳转)<br>    <span class="hljs-number">3</span>)使用小程序本地缓存 <span class="hljs-title class_">Storage</span><br><span class="hljs-number">8.</span> 小程序的生命周期函数<br>    <span class="hljs-title function_">onLoad</span>() 页面加载时触发，只会调用一次，建议在此 请求数据<br>    <span class="hljs-title function_">onShow</span>() 页面显示/切换前台时触发，不建议在此 请求数据<br>    <span class="hljs-title function_">onReady</span>() 页面初次渲染完成时触发，只会调用一次，可以进行视图层交互<br>    <span class="hljs-title function_">onHide</span>() 页面隐藏/切入后台时触发，如 navigateTo 或底部 tab 切换到其他页面、小程序切入后台等<br>    <span class="hljs-title function_">onUnload</span>() 页面卸载时触发，如 redirectTo 或 navigateBack 到其他页面时<br><span class="hljs-number">9.</span> 哪些方法可以提高微信小程序的应用速度？<br>    <span class="hljs-number">1</span>)提高页面加载速度<br>    <span class="hljs-number">2</span>)用户行为预测<br>    <span class="hljs-number">3</span>)减少默认 data 的大小<br>    <span class="hljs-number">4</span>)组件化方案<br><span class="hljs-number">10.</span> 微信小程序的优劣势<br>    优点: 即用即走、无需安装、省流量、省安装、不占桌面、依托微信、开发成本比<span class="hljs-variable constant_">APP</span>低<br>    缺点: 用户留存相对低、入口对传统<span class="hljs-variable constant_">APP</span>要深、限制较多，页面大小不能超过2M，不能打开超过<span class="hljs-number">10</span>个层级的页面<br><span class="hljs-number">11.</span> 怎么解决小程序的一部请求问题<br>    <span class="hljs-number">1</span>)在返回成功的回调里面处理逻辑   <span class="hljs-number">2</span>)<span class="hljs-title class_">Promise</span>异步<br><span class="hljs-number">12.</span> 小程序关联微信公众号如何确定用户的唯一性？<br>    通过 <span class="hljs-string">`unionid`</span> 来区分用户的唯一性，因为微信开放平台下的不同应用，相同用户的 unionid 都是相同的。<br><span class="hljs-number">13.</span> 如何实现下拉刷新？<br>    方案<span class="hljs-number">1</span>: 全局 config 中的 <span class="hljs-variable language_">window</span> 配置 enablePullDownRefresh<br>    方案<span class="hljs-number">2</span>: 在 <span class="hljs-title class_">Page</span> 中定义 onPullDownRefresh 钩子函数，到达下拉刷新条件后，该钩子函数执行<br>    注意: 请求返回后，调用 wx.<span class="hljs-property">stopPullDownRefresh</span> 停止下拉刷新<br><span class="hljs-number">14.</span> bindtap 和 catchtap 的区别<br>    <span class="hljs-attr">bindtap</span>: 点击事件，不会阻止冒泡事件<br>    <span class="hljs-attr">catchtap</span>: 点击事件，会阻止冒泡事件<br><span class="hljs-number">15.</span> 简述微信支付业务流程：必须为企业用户，且经过企业认证<br>    wx.<span class="hljs-title function_">requestPayment</span>(&#123;&#125;)<br>    <span class="hljs-number">1</span>)用户在商户<span class="hljs-variable constant_">APP</span>中选择商品，提交订单，选择微信支付<br>    <span class="hljs-number">2</span>)商户后台收到用户支付单，调用微信支付统一下单接口<br>    <span class="hljs-number">3</span>)统一下单接口返回正常的 prepay_id 预支付id，再按签名规范重新生成签名后，将数据传输给<span class="hljs-variable constant_">APP</span>。<br>      参与签名字段: appid, partnerid, prepayid, noncestr, timestamp, package  注意: package的值格式为 <span class="hljs-title class_">Sign</span>=<span class="hljs-title class_">WXPay</span><br>    <span class="hljs-number">4</span>)商户<span class="hljs-variable constant_">APP</span>调起微信支付<br>    <span class="hljs-number">5</span>)商户后台接收支付结果<br>    <span class="hljs-number">6</span>)商户后台查询支付结果<br><span class="hljs-number">16.</span> 小程序自定义组件样式隔离，有哪几种隔离模式？<br>    指定特殊的样式隔离选项 styleIsolation<br>    <span class="hljs-title class_">Component</span>(&#123; <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">styleIsolation</span>: <span class="hljs-string">&#x27;isolated&#x27;</span> &#125; &#125;)  <span class="hljs-comment">//表示启用样式隔离</span><br><span class="hljs-number">17.</span> 小程序让图片保持宽高比例不变<br>    使用 mode=<span class="hljs-string">&#x27;widthFix&#x27;</span> 宽度不变、高度自适应； mode=<span class="hljs-string">&#x27;heightFix&#x27;</span> 高度不变，宽度自适应<br><span class="hljs-number">18.</span> 小程序组件传参<br>    父传子: 自定义属性，子组件通过 props 接收<br>    子传父: 自定义事件，父组件通过事件接收子组件传过来的值<br><span class="hljs-number">19.</span> 小程序【组件】生命周期<br>    created - attached - ready - moved - detached - error<br><span class="hljs-number">20.</span> 小程序【页面】生命周期<br>    onLoad - onShow - onReady - onHide - onShow - noUnload<br><span class="hljs-number">21.</span> 小程序路由传参<br>    wx.<span class="hljs-title function_">navigateTo</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;xxx?id=2&#x27;</span> &#125;) - 保留当前页面跳转<br>    wx.<span class="hljs-title function_">redirectTo</span>(&#123; <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;xxx?id=2&#x27;</span> &#125;) - 关闭当前页面跳转<br><span class="hljs-number">22.</span> 小程序路由跳转 switchTab/navigateTo/redirectTo 区别<br>    wx.<span class="hljs-title function_">navigateTo</span>() - 保留当前页面跳转<br>    wx.<span class="hljs-title function_">redirectTo</span>() - 关闭当前页面跳转<br>    wx.<span class="hljs-title function_">switchTab</span>() - 专门用于跳转 tabBar 页面<br>    wx.<span class="hljs-title function_">navigateBack</span>() - 关闭当前页面，返回上一页面或多级页面<br>    wx.<span class="hljs-title function_">reLaunch</span>() - 关闭所有页面，打开应用内某个指定页面<br><span class="hljs-number">23.</span> 小程序 tabbar 的实现原理<br>    <span class="hljs-attr">tabBar</span>: &#123;<br>        <span class="hljs-string">&quot;list&quot;</span>: [<br>            &#123;<span class="hljs-string">&quot;pagePath&quot;</span>: xxx, <span class="hljs-string">&quot;text&quot;</span>: xxx, <span class="hljs-string">&quot;iconPath&quot;</span>: xxx, <span class="hljs-string">&quot;selectedIconPath&quot;</span>: xxx&#125;<br>        ]<br>    &#125;<br><span class="hljs-number">24.</span> 小程序性能为什么高？<br>    <span class="hljs-number">1</span>)轻量级、代码包体积2M内，超过2M还可以分包  <span class="hljs-number">2</span>)运行在微信端，原生<span class="hljs-variable constant_">API</span>调用  <span class="hljs-number">3</span>)基于微信宿主，可以让小程序快速渲染<br></code></pre></td></tr></table></figure>



<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> nodejs创建静态服务器：要使用<span class="hljs-variable constant_">HTTP</span>服务器和客户端，则必须 <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-number">2.</span> <span class="hljs-title class_">CommonJS</span>规范 与 <span class="hljs-title class_">ES6</span>模块化规范<br>    <span class="hljs-title class_">CommonJS</span>规范: <span class="hljs-built_in">require</span> 导入，<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> 导出<br>    <span class="hljs-title class_">ES6</span>模块化规范: <span class="hljs-keyword">import</span> 导入，<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> 导出<br><span class="hljs-number">3.</span> socket通信/聊天<br>    websocket 利用了 <span class="hljs-variable constant_">HTTP</span> 协议来建立连接，且必须由浏览器发起。<br>    该请求与<span class="hljs-variable constant_">HTTP</span>普通请求的区别：<br>    <span class="hljs-number">1</span>)<span class="hljs-variable constant_">GET</span>请求地址不再是路径，而是 <span class="hljs-string">&#x27;ws://&#x27;</span> 或 <span class="hljs-string">&#x27;wss://&#x27;</span> 的统一资源标志符（<span class="hljs-variable constant_">URI</span>），其中 wss 表示使用了 <span class="hljs-variable constant_">TLS</span> 的 <span class="hljs-title class_">Websocket</span>。<br>    <span class="hljs-number">2</span>)请求头是 <span class="hljs-title class_">Upgrade</span>: websocker 和 <span class="hljs-title class_">Connection</span>: <span class="hljs-title class_">Upgrade</span> 表示连接要被转换为 websocket 连接<br>    <span class="hljs-number">3</span>)<span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Key</span> 用于标识这个连接，并非用于加密数据<br>    <span class="hljs-number">4</span>)<span class="hljs-title class_">Sec</span>-<span class="hljs-title class_">WebSocket</span>-<span class="hljs-title class_">Version</span> 指定了 <span class="hljs-title class_">WebSocket</span> 的协议版本<br><span class="hljs-number">4.</span> <span class="hljs-title class_">MongoDB</span> 非关系型数据库：<br>    关系型数据库：sql语句表之间关系可以连表增删改查、事务一致性/事务回滚等，如 mysql、oracle、sqlserver...<br>    非关系型数据库：sql语句没有表关系，轻量、高效、自由，如 mongoDB、redis...<br>    <span class="hljs-title class_">MongoDB</span>: <span class="hljs-title function_">collection</span>(集合/表)、<span class="hljs-title function_">document</span>(文档/行数据)、<span class="hljs-title function_">field</span>(域/字段)<br>    <span class="hljs-title class_">MongoDB</span>数据库连接通过 <span class="hljs-string">&#x27;mongoose&#x27;</span> 库的引入实现。<br><span class="hljs-number">5.</span> <span class="hljs-title function_">token</span>(jwt-json) 与 <span class="hljs-title function_">session</span>(express-session) 配合 <span class="hljs-title function_">cookie</span>(登陆鉴权)<br>    <span class="hljs-number">1</span>)浏览器-<span class="hljs-variable constant_">POST</span>账号密码-服务端-校验账号密码-数据库 - 校验成功-用户信息存session-返回sessionId<br>    <span class="hljs-number">2</span>)浏览器-存储sessionId-请求接口自动携带<span class="hljs-title class_">Cookie</span>:sessionId-数据库查session - 校验成功-接口返回<br>    以<span class="hljs-variable constant_">CSRF</span>攻击为例：<br>      <span class="hljs-attr">cookie</span>: 用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是放行进行操作<br>      <span class="hljs-attr">token</span>: 用户点击了链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作<br><span class="hljs-number">6.</span> token 存在 <span class="hljs-variable language_">localStorage</span> 里，当过期时，过期的 token 怎么处理？<br>    token过期：后端会返回一个 <span class="hljs-number">401</span> 鉴权失败的状态码给前端，前端接收后重定向到登录页，引导用户登录。【<span class="hljs-string">`axios`</span>拦截器中进行判断和重定向】<br><span class="hljs-number">7.</span> 使用原生<span class="hljs-title class_">Node</span>.<span class="hljs-property">js</span>操作 cookie？<br>    获取<span class="hljs-attr">cookie</span>: req.<span class="hljs-property">headers</span>.<span class="hljs-property">cookie</span><br>    设置<span class="hljs-attr">cookie</span>: res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>: <span class="hljs-string">&#x27;myCookie=test&#x27;</span>, <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>&#125;)<br><span class="hljs-number">8.</span> nextTick 和 setImmediate 的区别：<br>    <span class="hljs-attr">nextTick</span>: 延迟加载，放在当前队列的最后一个执行<br>    <span class="hljs-attr">setImmediate</span>: 延迟加载，在下一个队列的队首执行<br><span class="hljs-number">9.</span> koa 与 express 区别：<br>    相同：都是 nodejs 的快速开发框架<br>    不同：<br>      <span class="hljs-number">1</span>)语法：最大区别<br>        express 的异步采用的是回调函数的形式<br>        koa 支持generator+<span class="hljs-keyword">yield</span>，支持<span class="hljs-keyword">async</span>+<span class="hljs-keyword">await</span>，更加优雅<br>      <span class="hljs-number">2</span>)中间件：<br>        koa 采用洋葱模型，进去顺序执行，出去反向执行，支持context传递数据。<br>        express 需要引入插件，不支持 <span class="hljs-keyword">await</span> 中间件异步函数<br>      <span class="hljs-number">3</span>)集成度：<br>        express 内置了很多中间件，集成度高、省心<br>        koa 轻量简洁、容易定制<br><span class="hljs-number">10.</span> koa 中间件的实现原理<br>    <span class="hljs-number">1</span>)每个中间件接收两个参数：<span class="hljs-string">&#x27;Context&#x27;</span>, <span class="hljs-string">&#x27;next&#x27;</span> 只要调用next函数就可以把执行权交给下一个中间件<br>    <span class="hljs-number">2</span>)如果没有调用 next，执行权就不会传递下去<br>    <span class="hljs-number">3</span>)多个中间件会形成一个 栈 解构，以先进后出的顺序执行。<br><span class="hljs-number">11.</span> 图片上传到服务器的过程<br>    <span class="hljs-string">&#x27;Multer&#x27;</span> 是nodejs的一个中间件，只会处理 multipart/form-data 类型的表单数据，主要用于上传文件。<br><span class="hljs-number">12.</span> 服务端渲染<br>    页面渲染在服务端完成，最终的<span class="hljs-variable constant_">HTML</span>字符串直接通过请求发送给客户端。<br>    服务端渲染的优势: 利于<span class="hljs-variable constant_">SEO</span>优化、首屏加载快(客户端接收到的是完整<span class="hljs-variable constant_">HTML</span>页面)<br><span class="hljs-number">13.</span> nodejs 优缺点 和 适用场景<br>    优点: 事件驱动、异步变成、简单易学、非阻塞<span class="hljs-variable constant_">IO</span>、性能较高、轻量高效<br>    缺点: 单线程、可靠性低、开源组件库参差不齐-兼容性差、不适合做企业级应用开发-特别是复杂业务<br>    场景: <br>      <span class="hljs-number">1</span>)大量 ajax 请求的应用<br>      <span class="hljs-number">2</span>)实时应用：在线聊天、实时通知推送等<br>      <span class="hljs-number">3</span>)工具类应用：海量工具，前端压缩部署、桌面图形界面等<br>      <span class="hljs-number">3</span>)高并发、I/O密集、少量业务逻辑和不依赖可靠性的场景，nodejs 还有其一席之地<br></code></pre></td></tr></table></figure>



<h2 id="git-webpack"><a href="#git-webpack" class="headerlink" title="git | webpack"></a>git | webpack</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> git命令相关<br>    git init 初始化仓库<br>    git status 查看各个区域的代码状态<br>    git log 查看commit记录<br>    git reflog 查看完整记录(★)<br>    git add 添加工作区代码到暂存区<br>    git commit 暂存区代码的提交<br>    git reset 代码的版本回退(★)<br>    git stash 将暂存处代码收起来(★)<br>    git stash pop 将收起来的暂存区的代码释放出来(★)<br>    git tag 可以打标签(★)<br>    git branch 基于当前分支创建一个分支<br>    git checkout 切换分支<br>    git merge 合并分支<br>    git remote add origin 添加远端仓库地址<br>    git clone 克隆仓库<br>    git pull 下拉对应分支代码<br>    git push 上传对应分支代码<br>   【规范】gitlab 和 公司 git 规范<br>      <span class="hljs-number">4</span>个环境：开发环境<span class="hljs-variable constant_">DEV</span>-dev分支、测试环境<span class="hljs-variable constant_">TEST</span>-test分支、预发布环境<span class="hljs-variable constant_">UAT</span>-uat分支、生产环境<span class="hljs-variable constant_">PROD</span>-master分支<br><span class="hljs-number">2.</span> sass 和 scss<br>    sass是 css 的辅助工具，在<span class="hljs-variable constant_">CSS</span>语法上增加了变量、嵌套、混合、导入等高级功能。<br>    scss是 sass 的一个语言版本，.<span class="hljs-property">scss</span> 文件的特点是层级靠 &#123;&#125; 来区分，.<span class="hljs-property">sass</span>文件的特点是层级靠【缩进】来区分。<br><span class="hljs-number">3.</span> 前端工程化：gulp &amp; webpack<br>    gulp - <span class="hljs-function"><span class="hljs-params">src</span>=&gt;</span><span class="hljs-title function_">pipe</span>(scss翻译).<span class="hljs-title function_">pipe</span>(css合并).<span class="hljs-title function_">pipe</span>(css压缩)=&gt;dist<br>    gulp - <span class="hljs-function"><span class="hljs-params">src</span>=&gt;</span><span class="hljs-title function_">pipe</span>(模块化编译).<span class="hljs-title function_">pipe</span>(js压缩)=&gt;dist<br>        流程化<br>    webpack<br>        模块化，默认支持的 commonjs 规范。<br>        所有js模块打包生成一个js文件，编译解析浏览器不能识别的语言（如scss/vue/jsx/ts/es6等）<br>        配置：入口、出口、devServer启动（自动刷新/热更新/反向代理）、sourcemap-调试代码.<span class="hljs-property">map</span>地图<br>        <span class="hljs-attr">loaders</span>: sass-loader/css-loader/file-loader/babel-loader/vue-loader/postcss-loader<br>        <span class="hljs-attr">plugin</span>: 压缩、提取公共库<br><span class="hljs-number">4.</span> webpack配置、代码分割流程及操作<br>    webpack包含：mode模式、entry入口、output出口、plugins插件、loader加载器、resolve、devServer开发服务器相关配置<br>    组件模块化导入的时候可以采用懒加载的形式，就会单独打包对应的代码。（路由匹配到就会加载，提高首屏加载速度）<br><span class="hljs-number">5.</span> webpack <span class="hljs-number">4</span>大核心理念、编译原理: entry入口、output出口、plugins插件、loader加载器(一切皆为模块)<br><span class="hljs-number">6.</span> webpack构建优化(打包时间过长，可以优化时间短点 20s)：<br>    <span class="hljs-number">1</span>)提取公共库，避免重复引用。（使用<span class="hljs-title class_">DllPlugin</span>把第三方库文件分离出来单独编译，并且缓存，极大减少业务页面编译时间）<br>    <span class="hljs-number">2</span>)happypack，多线程解析文件，如babel-loader等耗时较长的<br>    <span class="hljs-number">3</span>)缓存 cache-loader<br>    <span class="hljs-number">4</span>)loaders 尽可能配置解析路径include参数，排除路径exclude参数，减少解析时查询范围<br>    <span class="hljs-number">5</span>)dev 阶段 devtool 设置成 cheap-<span class="hljs-variable language_">module</span>-<span class="hljs-built_in">eval</span>-source-map，已经能满足调试需求，编译更快<br>    <span class="hljs-number">6</span>)prod 阶段 去掉 source-map<br></code></pre></td></tr></table></figure>





<h2 id="浏览器与网络"><a href="#浏览器与网络" class="headerlink" title="浏览器与网络"></a>浏览器与网络</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> url从输入到渲染页面的全过程<br>   <span class="hljs-number">1</span>)浏览器构建 <span class="hljs-variable constant_">HTTP</span> request 请求，<span class="hljs-variable constant_">DNS</span> 解析 url 地址，生成 <span class="hljs-variable constant_">HTTP</span> 请求保温，构建<span class="hljs-variable constant_">TCP</span>连接，使用 <span class="hljs-variable constant_">IP</span> 协议选择传输路线<br>   <span class="hljs-number">2</span>)将请求通过网络传输到服务端，从客户机到服务器需要通过许多网络设备，一般包括集线器、交换器、路由器等<br>   <span class="hljs-number">3</span>)服务器构建<span class="hljs-variable constant_">HTTP</span> response 响应，响应客户端的请求<br>   <span class="hljs-number">4</span>)将响应体的数据通过网络传输返回给客户端<br>   <span class="hljs-number">5</span>)浏览器渲染页面，解析<span class="hljs-variable constant_">HTML</span>、<span class="hljs-variable constant_">CSS</span>、<span class="hljs-variable constant_">JS</span>，生成 <span class="hljs-title class_">RenderTree</span>渲染页面<br><span class="hljs-number">2.</span> <span class="hljs-variable constant_">TCP</span> 三次握手、四次挥手、可靠传输原理<br>   三次握手: 客户端sync（发送seq为x序列号） -&gt; 服务端sync+ack（发送seq为y的序列号并将x+<span class="hljs-number">1</span>） -&gt; 客户端ack（发送seq为z的序列号并将y+<span class="hljs-number">1</span>）<br>   四次挥手: 客户端fin -&gt; 服务端ack（fin+seq） -&gt; 服务端fin -&gt; 客户端ack（fin+seq）<br><span class="hljs-number">3.</span> http <span class="hljs-number">200</span> 与 <span class="hljs-number">302</span><br>   <span class="hljs-number">200</span>: 成功 或 强缓存<br>   <span class="hljs-number">302</span>: 临时重定向<br><span class="hljs-number">4.</span> <span class="hljs-variable constant_">HTTP</span> 头部字段<br>    <span class="hljs-title class_">Cache</span>-<span class="hljs-title class_">Control</span> 控制缓存行为<br>    <span class="hljs-title class_">Connection</span> 逐跳首部、连接的管理<br>    <span class="hljs-title class_">Date</span> 创建报文的日期时间<br>    <span class="hljs-title class_">Program</span> 报文指令<br>    <span class="hljs-title class_">Trailer</span> 报文末端的首部一览<br>    <span class="hljs-title class_">Transfer</span>-<span class="hljs-title class_">Encoding</span> 指定报文主体的传输编码方式<br>    <span class="hljs-title class_">Upgrade</span> 升级为其他协议<br>    <span class="hljs-title class_">Via</span> 代理服务器的相关信息<br>    <span class="hljs-title class_">Warning</span> 错误通知<br>    <span class="hljs-title class_">Authorization</span> web认证信息<br><span class="hljs-number">5.</span> 为什么浏览器要限制<span class="hljs-variable constant_">TCP</span>的最大个数<br>    内存资源、<span class="hljs-variable constant_">CPU</span>资源<br>    一个 tcp 连接最小占用内存为 8k，对于8G内存的机器，不考虑其他限制，最多支持的并发量为 <span class="hljs-number">100</span>万，实际情况下，8G是达不到<span class="hljs-number">100</span>万，因为系统本身需要占用资源<br><span class="hljs-number">6.</span> <span class="hljs-title class_">HTTP2</span> 的特点<br>    二进制分帧、多路复用、头部压缩、流量控制、请求优先级、服务器推送<br><span class="hljs-number">7.</span> <span class="hljs-title class_">HTTP2</span> 多路复用的原理<br>    <span class="hljs-title class_">HTTP1</span><span class="hljs-number">.1</span> 是管道串行化的，<span class="hljs-title class_">HTTP2</span> 是管道并行的，因此是多路复用，主要体现在 I/O 流数据的传输上。<br><span class="hljs-number">8.</span> https原理<br>    端口: <span class="hljs-number">443</span><br>    证书: 需要申请证书，用于验证服务器身份和加密使用<br>    加密: 在<span class="hljs-variable constant_">TCP</span>的基础上，客户端与服务器会进行<span class="hljs-variable constant_">SSL</span>加密，确定对话密钥，以密文进行传输数据<br><span class="hljs-number">9.</span> <span class="hljs-variable constant_">CDN</span>是什么？原理？<br>    <span class="hljs-variable constant_">CDN</span> 内容分发网络，核心是以地理位置最近的节点去获取浏览器请求的服务器数据，以更快的速度访问网站。<br>    <span class="hljs-variable constant_">CDN</span>原理：内容存储和分发技术。<br><span class="hljs-number">10.</span> form表单提交没有跨域，为什么 ajax 有跨域？<br>    浏览器的<span class="hljs-string">`同源`</span>策略，没有经过允许不能获取另一个域名的内容。<br>    form表单是不需要返回的，因此没有跨域限制。ajax请求需要返回数据，并读取响应数据内容，但浏览器对其有安全策略限制。<br>    浏览器的安全策略主要针对 js脚本、并不限制 src、form表单提交的请求。<br></code></pre></td></tr></table></figure>



<h3 id="HTTP缓存策略"><a href="#HTTP缓存策略" class="headerlink" title="HTTP缓存策略"></a>HTTP缓存策略</h3><p><img src="https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260220133616343.png" srcset="/img/loading.gif" lazyload alt="image-20260220133614997"></p>
<h2 id="高频算法"><a href="#高频算法" class="headerlink" title="高频算法"></a>高频算法</h2>
              
            </div>
            <hr/>
            <div>
              <div>
  <img src="https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20241112163319.png" srcset="/img/loading.gif" lazyload>
</div>
<div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/20-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="category-chain-item">20_面试问题</a>
  
  
    <span>></span>
    
  <a href="/categories/20-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01-%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/" class="category-chain-item">01_技术问题</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">#面试题</a>
      
        <a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>00-面试题杂项整理（前端）</div>
      <div>https://janycode.github.io/2017/05/03/20_面试问题/01_技术问题/00-面试题杂项整理 (前端)/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jerry(姜源)</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年5月3日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 姜源">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/02_%E8%AF%9D%E6%9C%AF%E6%8A%80%E5%B7%A7/01-%E9%9D%A2%E8%AF%95%E8%AF%9D%E6%9C%AF-%E8%BD%AF%E6%8A%80%E8%83%BD/" title="01-面试话术-软技能">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">01-面试话术-软技能</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01_%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/00-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%9D%82%E9%A1%B9%E6%95%B4%E7%90%86%20(%E5%90%8E%E7%AB%AF)/" title="00-面试题杂项整理（后端）">
                        <span class="hidden-mobile">00-面试题杂项整理（后端）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="SOHUCS" sid='https://janycode.github.io/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01_%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/00-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%9D%82%E9%A1%B9%E6%95%B4%E7%90%86%20(%E5%89%8D%E7%AB%AF)/'></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#SOHUCS', function() {
      Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
        window.changyan.api.config({"appid":"cyw5OHIcO","appkey":"fea3446b3df4b3f129f34da4cbc87e51"})
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://simple.blog.csdn.net" target="_blank" rel="nofollow noopener"><span>CSDN</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/janycode" target="_blank" rel="nofollow noopener"><span>GitHub</span></a> <i class="iconfont icon-love"></i> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量(PV) 
        <span id="busuanzi_value_site_pv"></span>
         次，
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数(UV) 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

<!-- live2d 动画 -->
<script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script>
<script>
    L2Dwidget.init({
        "model": {
            jsonPath: "https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json",
            "scale": 1
        },
        "display": {
            "position": "right",
            "width": 100,
            "height": 200,
            "hOffset": 35,
            "vOffset": -85
        },
        "mobile": {
            "show": false,
            "scale": 0.1
        },
        "react": {
            "opacityDefault": 0.75,
            "opacityOnHover": 0.2
        }
    });
</script>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?bfff735c897eb60ea49b735096b20e47";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
