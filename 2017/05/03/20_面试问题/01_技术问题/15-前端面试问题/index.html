

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jerry(姜源)">
  <meta name="keywords" content="Java,Html,CSS,JavaScript,Python,C,Linux,shell编程经验分享、技术总结、心得体会">
  
    <meta name="description" content="（待整理） 13.Vue-router使用params与query传参有什么区别用法上1： query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$ route.query和 this.$route.params。 展示上2： params是路由的一部分，必须要有。query是拼接在接口后面的参数 命名的路由，并加上参数，让路由建立url &#x2F;u">
<meta property="og:type" content="article">
<meta property="og:title" content="15-前端面试问题">
<meta property="og:url" content="https://janycode.github.io/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01_%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/15-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="姜源の云笔记">
<meta property="og:description" content="（待整理） 13.Vue-router使用params与query传参有什么区别用法上1： query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$ route.query和 this.$route.params。 展示上2： params是路由的一部分，必须要有。query是拼接在接口后面的参数 命名的路由，并加上参数，让路由建立url &#x2F;u">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="e:/blog/image/08-Vue3.0/1ad327ccc9384018926945473dbc92ef.png">
<meta property="article:published_time" content="2017-05-02T16:09:33.000Z">
<meta property="article:modified_time" content="2026-02-11T08:08:01.853Z">
<meta property="article:author" content="Jerry(姜源)">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="e:/blog/image/08-Vue3.0/1ad327ccc9384018926945473dbc92ef.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>15-前端面试问题 - 姜源の云笔记</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"janycode.github.io","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":50,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"bfff735c897eb60ea49b735096b20e47","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 50vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>姜源の云笔记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tools/">
                <i class="iconfont icon-slack-fill"></i>
                工具
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://yuancodes.github.io/">
                <i class="iconfont icon-notebook"></i>
                Docsify
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="15-前端面试问题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Jerry(姜源)
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-05-03 00:09" pubdate>
          星期三, 2017/05/03 00:09:33
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          132 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">15-前端面试问题</h1>
            
            <div class="markdown-body">
              
              <p>（待整理）</p>
<h3 id="13-Vue-router使用params与query传参有什么区别"><a href="#13-Vue-router使用params与query传参有什么区别" class="headerlink" title="13.Vue-router使用params与query传参有什么区别"></a>13.Vue-router使用params与query传参有什么区别</h3><p><strong>用法上</strong><br>1： query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$ route.query和 this.$route.params。</p>
<p><strong>展示上</strong><br>2： params是路由的一部分，必须要有。query是拼接在接口后面的参数</p>
<p><strong>命名的路由，并加上参数，让路由建立url &#x2F;users&#x2F;eduardo</strong><br>router.push({ name: ‘user’, params: { username: ‘eduardo’ } })</p>
<p><strong>带查询参数，结果是 &#x2F;register?plan&#x3D;private</strong><br>router.push({ path: ‘&#x2F;register’, query: { plan: ‘private’ } })</p>
<p><strong>带 hash，结果是 &#x2F;about#team</strong><br>router.push({ path: ‘&#x2F;about’, hash: ‘#team’ })</p>
<h3 id="14-Vue中-keep-alive-的作用"><a href="#14-Vue中-keep-alive-的作用" class="headerlink" title="14.Vue中 keep-alive 的作用"></a>14.Vue中 keep-alive 的作用</h3><p>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。一旦使用keepalive包裹组件，此时 mouted, created等钩子函数只会在第一次进入组件时调用，当再次切换回来时将不会调用。此时如果我们还想在每次切 换时做一些事情，就需要用到另外的周期函数，actived和deactived，这两个钩子函数只有被keepalive包裹后才会调用。</p>
<h3 id="15-Vue如何实现单页面应用"><a href="#15-Vue如何实现单页面应用" class="headerlink" title="15.Vue如何实现单页面应用"></a>15.Vue如何实现单页面应用</h3><p>通常的url地址由以下内容构成：协议名域名端口号路径参数哈希值，当哈希值改变，页面不会发生跳转，单页面应用就 是利用了这一点，给window注册onhashchange事件，当哈希值改变时通过location.hash就能获得相应的哈希值，然后就 能跳到相应的页面。</p>
<ol>
<li>hash通过监听浏览器的onhashchange()事件变化，查找对应的路由规则</li>
<li>history原理：利用H5的 history中新增的两个API pushState()和 replaceState()和一个事件onpopstate监听URL变化</li>
</ol>
<h3 id="16-说出至少4种Vue当中的指令和它的用法？"><a href="#16-说出至少4种Vue当中的指令和它的用法？" class="headerlink" title="16.说出至少4种Vue当中的指令和它的用法？"></a>16.说出至少4种Vue当中的指令和它的用法？</h3><pre><code class="hljs">v-if(判断是否隐藏 用来判断元素是否创建)
v-show(元素的显示隐藏，类似css中的display的block和hidden)
v-for(把数据遍历出来)
v-bind(绑定属性)
v-model(实现双向绑定)
</code></pre>
<h3 id="17-如何实现一个路径渲染多个组件？"><a href="#17-如何实现一个路径渲染多个组件？" class="headerlink" title="17.如何实现一个路径渲染多个组件？"></a>17.如何实现一个路径渲染多个组件？</h3><pre><code class="hljs">可以通过命名视图(router-view)，它容许同一界面中拥有多个单独命名的视图，而襁只有一个单独的出口。
如果router-view 没有设置名字，那么默认为default。通过设置components即可同时渲染多个组件。


&lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt;
&lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt;
const router = createRouter(&#123; history: createWebHashHistory(), routes:[
&#123;
    path: &#39;/&#39;,
    components: &#123; 
        default: Home, 
        // LeftSidebar: LeftSidebar 的缩写 
        LeftSidebar,
        //它们与、&lt;router-view&gt;、上的&#39;name&#39;属性匹配 
        RightSidebar,
    &#125;,
    &#125;,
 ],
&#125;)
</code></pre>
<h3 id="18-如何实现多个路径共享一个组件"><a href="#18-如何实现多个路径共享一个组件" class="headerlink" title="18.如何实现多个路径共享一个组件?"></a>18.如何实现多个路径共享一个组件?</h3><p>只需将多个路径的component字段的值设置为同一个组件即可。</p>
<pre><code class="hljs">const routes =[
&#123; path: &#39;/&#39;, component: Home &#125;,
&#123; path: &#39;/home&#39;, component: Home &#125;, ]
</code></pre>
<h3 id="19-如何监测动态路由的变化"><a href="#19-如何监测动态路由的变化" class="headerlink" title="19.如何监测动态路由的变化"></a>19.如何监测动态路由的变化</h3><p>可以通过亚3同方法^^route进行监听，或者通过导航守卫的钩子函数beforeRouteUpdate来监听它的变化。</p>
<h3 id="20-vue-router-中的-router-link-上-v-slot-属性怎么用？"><a href="#20-vue-router-中的-router-link-上-v-slot-属性怎么用？" class="headerlink" title="20.vue-router 中的 router-link 上 v-slot 属性怎么用？"></a>20.vue-router 中的 router-link 上 v-slot 属性怎么用？</h3><pre><code class="hljs"> router-link通过一个作用域插槽暴露底层的定制能力。这是一个更高阶的API，主要面向库作者，
 但也可以为开发者提供便利，多数情况用在一个类似NavLink这样的自定义组件里。
 有时我们可能想把激活的class应用到一个外部元素而不是&lt;a&gt;标签本身，
 这时你可以在一个router-link中包裹该元素并 使用v-slot属性来创建链接：


&lt;router-link
to=&quot;/foo&quot;
custom
v-slot=&quot;&#123; href, route, navigate, isActive, isExactActive &#125;&quot; &gt;
&lt;li :class=&quot;[isActive &amp;&amp; &#39;router-link-active&#39;, isExactActive &amp;&amp; &#39;router-link-exact-active&#39;]&quot;&gt;
    &lt;a :href=&quot;href&quot; @click=&quot;navigate&quot;&gt;&#123;&#123; route.fullPath &#125;&#125;&lt;/a&gt;
&lt;/li&gt;
&lt;/router-link&gt;
</code></pre>
<h3 id="21-Vue如何去除51中的"><a href="#21-Vue如何去除51中的" class="headerlink" title="21.Vue如何去除51中的#"></a>21.Vue如何去除51中的#</h3><pre><code class="hljs">将路由模式改为history

由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问
https://example.com/user/id，就会得到一个 404 错误。这就尴尬了。

不用担心：要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。
如果URL不匹配任何静态资源， 它应提供与你的应用程序中的index.html相同的页面。

var history = require(&#39;connect-history-api-fallback&#39;);
app.use(history(&#123;
        index: &#39;/index.html&#39;
    &#125;)); //注意放在所有的接口后面
</code></pre>
<h3 id="22-丁亚标和router的区别"><a href="#22-丁亚标和router的区别" class="headerlink" title="22.丁亚标和router的区别"></a>22.丁亚标和router的区别</h3><p>r o u t e 用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括 n a m e 、 m e t a 、 p a t h 、 h a s h 、 q u e r y 、 p a r a m s 、 f u l l P a t h 、 m a t c h e d , r e d i r e c t e d F r o m 等。而 route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、 hash、query、params、fullPath、matched, redirectedFrom等。而 route用来获取路由的信息的，它是路由信息的一个对象，里面包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched,redirectedFrom等。而「0供6「主要是用来操作路由的，它是VueRouter的 实例，包含了一些路由的目库专方法push, go, replace,钩子函数等</p>
<h3 id="23-Vue路由守卫"><a href="#23-Vue路由守卫" class="headerlink" title="23.Vue路由守卫"></a>23.Vue路由守卫</h3><p>vue-router提供的导航守卫主要用来对路由的蹴转进行监控，控制它的瞬转或取消，路由守卫有全局的,单个路由独享的， 或者组件级的。导航钩子有3个参数：</p>
<ol>
<li><p>to:即将要进入的目标路由对象；</p>
</li>
<li><p>from:当前导航即将要离开的路由对象；</p>
</li>
<li><p>next:调用该方法后，才能进入下一个钩子函数(afterEach)。</p>
<p>router.beforeEach(async (to, from) &#x3D;&gt; { if (<br>&#x2F;&#x2F;检查用户是否已登录<br>!isAuthenticated &amp;&amp;<br>&#x2F;&#x2F; (避免无限重定向 to.name !&#x3D;&#x3D; ‘Login’ ){<br>&#x2F;&#x2F;将用户重定向到登录页面 return { name: ‘Login’ }<br>}<br>})</p>
</li>
</ol>
<h3 id="24-Vue路由实现的底层原理"><a href="#24-Vue路由实现的底层原理" class="headerlink" title="24.Vue路由实现的底层原理"></a>24.Vue路由实现的底层原理</h3><p>在Vue中利用数据劫持defineProperty在原型prototype上初始化了一些getter,分别是routenf像当前Router的实例、 route 代表当前Router的信息。在install中也全局注册了router-view,router-link,其中的Vue.util.defineReactive, 这是Vue 里面观察者劫持数据的方法，劫持，oute,当_route触发setter方法的时候，则会通知到依赖的组件。</p>
<p>接下来在^汇中，会挂载判断是路由的模式，是history或者是hash,点击行为按钮，调用hashchange或者popstate的同时更 _route,_route的更新会触发route-view的重新渲染。</p>
<h3 id="25-路由懒加载"><a href="#25-路由懒加载" class="headerlink" title="25.路由懒加载"></a>25.路由懒加载</h3><pre><code class="hljs">Vue Router支持开箱即用的动态导入,这意味着你可以用动态导入代替静态导入：
//将
// import UserDetails from &#39;./views/UserDetails.vue&#39;
//替换成
const UserDetails = () =&gt; import(&#39;./views/UserDetails.vue&#39;)
const router = createRouter(&#123;
// ...
routes: [&#123; path: &#39;/users/:id&#39;, component: UserDetails &#125;],
&#125;)
</code></pre>
<h3 id="26-用过插槽吗？用的是具名插槽还是匿名插槽"><a href="#26-用过插槽吗？用的是具名插槽还是匿名插槽" class="headerlink" title="26.用过插槽吗？用的是具名插槽还是匿名插槽"></a>26.用过插槽吗？用的是具名插槽还是匿名插槽</h3><p>用过，都使用过。插槽相当于预留了一个位置，可以将我们书写在组件内的内容放入，写一个插槽就会将组件内的内容替 换一次，两次则替换两次。为了自定义插槽的位置我们可以给插槽取名，它会根据插槽名来插入内容，一对应。<br>举例来说，这里有一个组件，可以像这样使用：</p>
<pre><code class="hljs">template
&lt;FancyButton&gt;
Click me! &lt;!--插槽内容--&gt;
&lt;/FancyButton&gt;

而&lt;FancyButton&gt;的模板是这样的：

template
(button class=&quot;fancy-btn&quot;&gt;
&lt;slot&gt;&lt;/slot&gt; &lt;!--插槽出口 --&gt;
&lt;/button&gt;
</code></pre>
<h3 id="27-Vue-loader-解释一下"><a href="#27-Vue-loader-解释一下" class="headerlink" title="27.Vue-loader 解释一下"></a>27.Vue-loader 解释一下</h3><p>解析和转换.vue文件，提取出其中的逻辑代码script、样式代码style、以及HTML模版template，再分别把它们交给对 应的Loader去处理。</p>
<h3 id="28-Vue和React中diff算法区别"><a href="#28-Vue和React中diff算法区别" class="headerlink" title="28.Vue和React中diff算法区别"></a>28.Vue和React中diff算法区别</h3><p>vue和react的diff算法，都是忽略跨级比较，只做同级比较。vue diff时调动patch函数，参数是vnode和ldVnode，分别代表新旧节点。</p>
<ol>
<li>vue对比节点。当节点元素相同，但是classname不同，认为是不同类型的元素，删除重建，而react认为是同类型节点，<br>只是修改节点属性。</li>
<li>vue的列表对比，采用的是两端到中间比对的方式，而react采用的是从左到右依次对比的方式。当一个集合只是把最后一个节点移到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移到第一个。总体上，vue的方式比较高效。</li>
</ol>
<h3 id="29-请你说一下Vue中create和mount的区别"><a href="#29-请你说一下Vue中create和mount的区别" class="headerlink" title="29.请你说一下Vue中create和mount的区别"></a>29.请你说一下Vue中create和mount的区别</h3><p>create为组件初始化阶段，在此阶段主要完成数据观测(data observer),属性和方法的运算，watch&#x2F;event事件回调。然 而，挂载阶段还没开始，此时还未生成真实的DOM,也就无法获取和操作DOM元素。而mount主要完成从虚拟DOM到真 实DOM的转换挂载，此时html已经渲染出来了，所以可以直接操作dom节点。</p>
<h3 id="30-axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#30-axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="30.axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>30.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h3><p>axios是请求后台资源的模块。通过npm install axios -S来安装，在大多数情况下我们需要封装拦截器，在实现登录的过程中我们一般在请求拦截器中来加入token,在响应请求器中通过判断后端返回的状态码来对返回的数据进行不同的处理。如果发送的是跨域请求，需在配置文件中config&#x2F;index.js进行代理配置。</p>
<pre><code class="hljs">// Add a request interceptor
axios.interceptors.request.use(function (config) &#123;
    // Do something before request is sent 
        return config;
    &#125;, function (error) &#123;
    // Do something with request error
        return Promise.reject(error);
&#125;)；
// Add a response interceptor
axios.interceptors.response.use(function (response) &#123;
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data 
    return response;
&#125;, function (error) &#123;
    // Any status codes that falls outside the range of 2xx cause this function to trigger 
    // Do something with response error 
    return Promise.reject(error);
&#125;)；
</code></pre>
<h3 id="31-computed和watch的区别？-watch实现原理？-watch有几种写法？"><a href="#31-computed和watch的区别？-watch实现原理？-watch有几种写法？" class="headerlink" title="31.computed和watch的区别？ watch实现原理？ watch有几种写法？"></a>31.computed和watch的区别？ watch实现原理？ watch有几种写法？</h3><p>计算属性computed :</p>
<ol>
<li><p>支持缓存，只有依赖数据发生改变，才会重新进行计算</p>
</li>
<li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p>
</li>
<li><p>computed属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p>
</li>
<li><p>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，用computed</p>
</li>
<li><p>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都<br>有一个get和一个set方法，当数据变化时，调用set方法。</p>
<p>computed: {<br>&#x2F;&#x2F; 一个计算属性的getter<br>publishedBooksMessage() {<br>&#x2F;&#x2F; ‘this’指向当前组件实例<br>return this.author.books.length &gt; 0 ? ‘Yes’ : ‘No’<br>}<br>}</p>
</li>
</ol>
<p><strong>侦听属性watch ：</strong></p>
<ol>
<li><p>不支持缓存，数据变，直接会触发相应的操作；</p>
</li>
<li><p>watch支持异步；</p>
</li>
<li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值;</p>
</li>
<li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p>
</li>
<li><p>监听数据必须是~3上3中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，immediate：组件加载立即触发回调函数执行，deep：深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变 动不需要这么做。</p>
<p>watch: {<br>&#x2F;&#x2F;每当question改变时，这个函数就会执行<br>question(newQuestion, oldQuestion) {<br>if (newQuestion.includes(‘?’)) {<br>  this.getAnswer()<br>  }<br> }<br>},<br>watch: {<br>someObject: {<br>handler(newValue, oldValue) {<br>&#x2F;&#x2F;注意：在嵌套的变更中，<br>&#x2F;&#x2F;只要没有替换对象本身，<br>&#x2F;&#x2F;那么这里的’newValue’和’oldValue’相同<br>}, deep: true<br>} }</p>
</li>
</ol>
<h3 id="32-Vue-forceUpdate的原理"><a href="#32-Vue-forceUpdate的原理" class="headerlink" title="32.Vue $forceUpdate的原理"></a>32.Vue $forceUpdate的原理</h3><h4 id="1、作用："><a href="#1、作用：" class="headerlink" title="1、作用："></a>1、作用：</h4><p>迫使Vue实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
<h4 id="2、内部原理："><a href="#2、内部原理：" class="headerlink" title="2、内部原理："></a>2、内部原理：</h4><pre><code class="hljs">Vue.prototype.$forceUpdate = function () &#123;
const vm: Component = this
if (vm._watcher) &#123;
       vm._watcher.update()
    &#125;
&#125;
</code></pre>
<p>实例需要重新渲染是在依赖发生变化的时候会通知watcher，然后通知watcher来调用update方法，就是这么简单。</p>
<h3 id="33-v-for-key"><a href="#33-v-for-key" class="headerlink" title="33.v-for key"></a>33.v-for key</h3><ul>
<li>key是为Vue中的vnode标记的唯一id,通过这个key,我们的diff操作可以更准确、更快速</li>
<li>diff算法的过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点进行比对，然后超出差异.</li>
</ul>
<p>diffg可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx,它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key,就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较，这四种比较方式 就是首、尾、旧尾新头、旧头新尾.</p>
<p>准确:如果不加key,那么vue会选择复用节点(Vue的就地更新策略)，导致之前节点的状态被保留下来，会产生一 系列的bug.快速:key的唯一性可以被Map数据结构充分利用，相比于遍历查找的时间复杂度O(n), Map的时间 复杂度仅仅为O(1)</p>
<h3 id="34-为什么要设置key值，可以用index吗？为什么不能？"><a href="#34-为什么要设置key值，可以用index吗？为什么不能？" class="headerlink" title="34.为什么要设置key值，可以用index吗？为什么不能？"></a>34.为什么要设置key值，可以用index吗？为什么不能？</h3><p>vue中列表循环需加:key&#x3D;”唯一标识”唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标 识组件的唯一性，为了更好地区别各个组件key的作用主要是为了高效的更新虚拟DOM</p>
<h3 id="35-diff复杂度原理及具体过程画图"><a href="#35-diff复杂度原理及具体过程画图" class="headerlink" title="35.diff复杂度原理及具体过程画图"></a>35.diff复杂度原理及具体过程画图</h3><p>diff算法是一种通过同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，所以时间复杂度只有 O(n)。<br><img src="E:\blog\image\08-Vue3.0\1ad327ccc9384018926945473dbc92ef.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>diff算法有两个比较显著的特点：</p>
<ol>
<li>比较只会在同层级进行,不会跨层级比较。</li>
<li>在diff比较的过程中，循环从两边向中间收拢。</li>
</ol>
<p>diff流程：首先定义oldStartIdx、newStartIdx、oldEndIdx以及newEndIdx分别是新老两个VNode的两边的索 引。</p>
<p>接下来是一个while循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx以及newEndIdx会逐渐向中间 靠拢。while循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<p>while循环中会遇到四种情况：</p>
<ol>
<li>情形一：当新老VNode节点的start是同一节点时，直接patchVnode即可，同时新老VNode节点的开始索引都 加1。</li>
<li>情形二：当新老VNode节点的end是同一节点时，直接patchVnode即可，同时新老VNode节点的结束索引都 减1。</li>
<li>情形三：当老VNode节点的start和新VNode节点的end是同一节点时，这说明这次数据更新后oldStartVnode 已经跑到了<br>oldEndVnode后面去了。这时候在patchVnode后，还需要将当前真实dom节点移动到<br>oldEndVnode的后面，同时老VNode节点开始索引加1，新VNode节点的结束索引减1。</li>
<li>情形四：当老VNode节点的end和新VNode节点的start是同一节点时，这说明这次数据更新后oldEndVnode 跑到了oldStartVnode的前面去了。这时候在patchVnode后，还需要将当前真实dom节点移动到oldStartVnode的前面，同时老VNode节点结束索引减1，新VNode节点的开始索引加1。</li>
</ol>
<p>while循环的退出条件是直到老节点或者新节点的开始位置大于结束位置。</p>
<ol>
<li>情形一：如果在循环中，oldStartIdx大于oldEndIdx了，那就表示oldChildren比newChildren先循环完毕，那么newChildren里面剩余的节点都是需要新增的节点，把［newStartIdx, newEndIdx］之间的所有节点都插入到DOM中</li>
<li>情形二：如果在循环中，newStartIdx大于newEndIdx了，那就表示newChildren比oldChildren先循环完毕，那么oldChildren里面剩余的节点都是需要删除的节点，把［oldStartIdx, oldEndIdx］之间的所有节点都删除</li>
</ol>
<h3 id="36-Vue组件中的Data为什么是函数，根组件却是对象呢？"><a href="#36-Vue组件中的Data为什么是函数，根组件却是对象呢？" class="headerlink" title="36.Vue组件中的Data为什么是函数，根组件却是对象呢？"></a>36.Vue组件中的Data为什么是函数，根组件却是对象呢？</h3><p>综上可知，如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建 一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果。<br>所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。</p>
<h3 id="37-Vue的组件通信"><a href="#37-Vue的组件通信" class="headerlink" title="37.Vue的组件通信"></a>37.Vue的组件通信</h3><h4 id="1、props和-emit"><a href="#1、props和-emit" class="headerlink" title="1、props和$emit"></a>1、props和$emit</h4><p>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件</p>
<h4 id="2、attrs和-listeners"><a href="#2、attrs和-listeners" class="headerlink" title="2、attrs和 listeners"></a>2、attrs和 listeners</h4><h4 id="3、中央事件总线bus"><a href="#3、中央事件总线bus" class="headerlink" title="3、中央事件总线bus"></a>3、中央事件总线bus</h4><p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事 件总线的方式。新建一个Vue事件bus对象，然后通过bus.em范触发事件，加s.on监听触发的事件。</p>
<h4 id="4、provide和inject"><a href="#4、provide和inject" class="headerlink" title="4、provide和inject"></a>4、provide和inject</h4><p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject 那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命 周期内，子组件都可以调用。</p>
<h4 id="5、v-model"><a href="#5、v-model" class="headerlink" title="5、v-model"></a>5、v-model</h4><p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val) 自动修改v-model绑定的值</p>
<h4 id="6、parent-children"><a href="#6、parent-children" class="headerlink" title="6、parent children"></a>6、parent children</h4><h4 id="7、boradcast和dispatch"><a href="#7、boradcast和dispatch" class="headerlink" title="7、boradcast和dispatch"></a>7、boradcast和dispatch</h4><h4 id="8、vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有-上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这-个公共数据进行读写操作，这样达到了解耦的目的。"><a href="#8、vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有-上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这-个公共数据进行读写操作，这样达到了解耦的目的。" class="headerlink" title="8、vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有 上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这 个公共数据进行读写操作，这样达到了解耦的目的。"></a>8、vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有 上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这 个公共数据进行读写操作，这样达到了解耦的目的。</h4><h3 id="38-什么情况下使用Vuex"><a href="#38-什么情况下使用Vuex" class="headerlink" title="38.什么情况下使用Vuex"></a>38.什么情况下使用Vuex</h3><p>如果应用够简单，最好不要使用Vuex，一个简单的store模式即可，需要构建一个中大型单页应用时，使用Vuex能更好地 在组件外部管理状态<br>Gjimage-20230216130149318</p>
<h3 id="39-Vuex可以直接修改state的值吗？"><a href="#39-Vuex可以直接修改state的值吗？" class="headerlink" title="39. Vuex可以直接修改state的值吗？"></a>39. Vuex可以直接修改state的值吗？</h3><p>可以直接修改，但是极其不推荐，state的修改必须在mutation来修改，否则无法被devtool所监测，无法监测数据的来 源，无法保存状态快照，也就无法实现时间漫游&#x2F;回滚之类的操作。</p>
<h3 id="40-为什么Vuex的mutation不能做异步操作"><a href="#40-为什么Vuex的mutation不能做异步操作" class="headerlink" title="40.为什么Vuex的mutation不能做异步操作"></a>40.为什么Vuex的mutation不能做异步操作</h3><p>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过Action来提交mutation实现，这样使得我们可以方便地 跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。每个mutation执行完成后都会对 应到一个新的状态变更，这样devtools就可以打个快照存下来，否则无法被devtools所监测。如果mutation支持异步操 作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
<h3 id="41-怎么修改Vuex中的状态？-Vuex中有哪些方法"><a href="#41-怎么修改Vuex中的状态？-Vuex中有哪些方法" class="headerlink" title="41.怎么修改Vuex中的状态？ Vuex中有哪些方法"></a>41.怎么修改Vuex中的状态？ Vuex中有哪些方法</h3><ul>
<li>通过this.$store.state.属性的方法来访问状态</li>
<li>通过this.$store.commit(‘mutation中的方法’)来修改状态</li>
</ul>
<h3 id="42-Vuex的缺点"><a href="#42-Vuex的缺点" class="headerlink" title="42.Vuex的缺点"></a>42.Vuex的缺点</h3><p>如果您不打算开发大型单页应用，使用Vuex可能是繁琐冗余的，并且state中的值会伴随着浏览器的刷新而初始化，无缓 存。</p>
<h3 id="43-什么是-Vue-nextTick"><a href="#43-什么是-Vue-nextTick" class="headerlink" title="43.什么是 Vue.nextTick()?"></a>43.什么是 Vue.nextTick()?</h3><p>1、$nextTick是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM，意思是等你dom加载完毕以后再去调用nextTick()里面的数据内容</p>
<h3 id="44-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"><a href="#44-nextTick知道吗、实现的原理是什么？是宏任务还是微任务？" class="headerlink" title="44. nextTick知道吗、实现的原理是什么？是宏任务还是微任务？"></a>44. nextTick知道吗、实现的原理是什么？是宏任务还是微任务？</h3><p>微任务<br><strong>原理：</strong><br>nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过 这个异步方法清空队列。<br><strong>作用：</strong><br>nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新 循环结束之后执行延迟回调，在修改数据之后使用nextTick用于下次Dom更新循环结束之后执行延迟回调，在修改 数据之后使用nextTick,则可以在回调中获取更新后的DOM。</p>
<h3 id="45-虚拟dom为什么会提高性能？"><a href="#45-虚拟dom为什么会提高性能？" class="headerlink" title="45.虚拟dom为什么会提高性能？"></a>45.虚拟dom为什么会提高性能？</h3><p>虚拟DOM其实就是一个JavaScript对象。通过这个JavaScript对象来描述真实DOM，真实DOM的操作，一般都会 对某块元素的整体重新渲染，采用虚拟DOM的话，当数据变化的时候，只需要局部刷新变化的位置就好了，<br>虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高 性能<br>具体实现步骤如下</p>
<ul>
<li>用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新</li>
</ul>
<h3 id="46-你做过哪些Vue的性能优化？"><a href="#46-你做过哪些Vue的性能优化？" class="headerlink" title="46.你做过哪些Vue的性能优化？"></a>46.你做过哪些Vue的性能优化？</h3><ol>
<li><p>首屏加载优化</p>
</li>
<li><p>路由懒加载</p>
<p>{<br>path: ‘&#x2F;‘,<br>name: ‘home’,<br>component: () &#x3D;&gt; import(‘.&#x2F;views&#x2F;home&#x2F;index.vue’), meta: { isShowHead: true }<br>}</p>
</li>
<li><p>开启服务器Gzip</p>
</li>
</ol>
<p>开启Gzip就是一种压缩技术，需要前端提供压缩包，然后在服务器开启压缩，文件在服务器压缩后传给浏览器， 浏览器解压后进行再进行解析。首先安装webpack提供的compression-webpack-plugin进行压缩,然后在 vue.config.js：</p>
<pre><code class="hljs">const CompressionWebpackPlugin = require(&#39;compression-webpack-plugin&#39;)
const productionGzipExtensions = [&#39;js&#39;, &#39;css&#39;]	plugins:[
new CompressionWebpackPlugin( 
&#123;
    algorithm: &#39;gzip&#39;,
    test: new RegExp(&#39;\\.(&#39; + productionGzipExtensions.join(&#39;[&#39;) +	&#39;)$&#39;),
    threshold: 10240, 
    minRatio: 0.8 
&#125;
)]....
</code></pre>
<ol start="4">
<li>启动CDN加速</li>
</ol>
<p>我们继续采用cdn的方式来引入一些第三方资源，就可以缓解我们服务器的压力，原理是将我们的压力分给其他服务器点。</p>
<ol start="5">
<li>代码层面优化</li>
</ol>
<p><strong>computed和watch区分使用场景</strong><br>computed:是计算属性，依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed的值时才会重新计算computed的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用computed的缓存特性，避免每次获取值时，都要重新计算；<br>watch：类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时 执行异步或开销较大的操作时，应该使用watch，使用watch选项允许我们执行异步操作(访问一个API)，限制我们 执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<ul>
<li>v-if和v-show区分使用场景v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适 用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中dom总数，我比较倾向于使用v-if， 因为减少了 dom数量。</li>
<li>v-for遍历必须为item添加key，目避免同时使用v-if v-for遍历必须为item添加key，循环调用子组件时添<br>加key，key可以唯一标识一个循环个体，可以使用例如item.id作为key避免同时使用v-if，v-for比v-if优<br>先级高，如果每一次都需要遍历整个数组，将会影响速度。</li>
</ul>
<ol start="6">
<li>Webpack对图片进行压缩</li>
<li>避免内存泄漏</li>
<li>减少ES6转为ES5的冗余代码</li>
</ol>
<h3 id="47-Vue的常用修饰符"><a href="#47-Vue的常用修饰符" class="headerlink" title="47.Vue的常用修饰符"></a>47.Vue的常用修饰符</h3><h4 id="一、v-model修饰符"><a href="#一、v-model修饰符" class="headerlink" title="一、v-model修饰符"></a>一、v-model修饰符</h4><h5 id="1、-lazy："><a href="#1、-lazy：" class="headerlink" title="1、.lazy："></a>1、.lazy：</h5><p>输入框改变，这个数据就会改变，lazy这个修饰符会在光标离开input框才会更新数据:</p>
<pre><code class="hljs">&lt;input type=&quot;text* v-model.lazy=&#39;,value&quot;&gt;
</code></pre>
<h5 id="2、-trim："><a href="#2、-trim：" class="headerlink" title="2、.trim："></a>2、.trim：</h5><p>输入框过滤首尾的空格:</p>
<pre><code class="hljs">&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt;
</code></pre>
<h5 id="3、-number："><a href="#3、-number：" class="headerlink" title="3、.number："></a>3、.number：</h5><p>先输入数字就会限制输入只能是数字，先字符串就相当于没有加number，注意，不是输入框不能输入字符串，是 这个数据是数字：</p>
<pre><code class="hljs">    &lt;input type=&quot;text&quot; v-model.number=Mvalue&quot;&gt;
</code></pre>
<h4 id="二、事件修饰符"><a href="#二、事件修饰符" class="headerlink" title="二、事件修饰符"></a>二、事件修饰符</h4><h5 id="4、-stop："><a href="#4、-stop：" class="headerlink" title="4、.stop："></a>4、.stop：</h5><p>阻止事件冒泡，相当于调用了event.stopPropagation()方法:</p>
<pre><code class="hljs">&lt;button @cliek.stop=&quot;test&quot;&gt;test&lt;/button&gt;
</code></pre>
<h5 id="5、-prevent"><a href="#5、-prevent" class="headerlink" title="5、.prevent:"></a>5、.prevent:</h5><p>阻止默认行为，相当于调用了6”6团06”6团口6£33管方法，比如表单的提交、a标签的用阵专就是默认事件:</p>
<h5 id="6、-self："><a href="#6、-self：" class="headerlink" title="6、.self："></a>6、.self：</h5><p>只有元素本身触发时才触发方法，就是只有点击元素本身才会触发。比如一个div里面有个按钮，div和按钮都有事 件，我们点击按钮，div绑定的方法也会触发，如果div的click加上self，只有点击到div的时候才会触发，变相的算 是阻止冒泡：</p>
<pre><code class="hljs">&lt;div @Jclick.self=wtestM&gt;&lt;/div&gt;
</code></pre>
<h5 id="7、-once："><a href="#7、-once：" class="headerlink" title="7、.once："></a>7、.once：</h5><p>事件只能用一次，无论点击几次，执行一次之后都不会再执行</p>
<pre><code class="hljs">&lt;div @c1ick.once=etest&quot;x/div&gt;
</code></pre>
<h5 id="8、-capture："><a href="#8、-capture：" class="headerlink" title="8、.capture："></a>8、.capture：</h5><p>事件的完整机制是捕获-目标-冒泡，事件触发是目标往外冒泡</p>
<h5 id="9、-sync"><a href="#9、-sync" class="headerlink" title="9、.sync"></a>9、.sync</h5><p>对prop进行双向绑定</p>
<h5 id="10、-keyCode："><a href="#10、-keyCode：" class="headerlink" title="10、.keyCode："></a>10、.keyCode：</h5><p>监听按键的指令，具体可以查看vue的键码对应表</p>
<h3 id="48-Vue中template的编译过程"><a href="#48-Vue中template的编译过程" class="headerlink" title="48. Vue中template的编译过程"></a>48. Vue中template的编译过程</h3><p>vue template模板编译的过程经过parse()生成ast(抽象语法树),optimize对静态节点优化，generate。生成render 字符串之后调用new Watcher()函数，用来监听数据的变化，render函数就是数据监听的回调所调用的，其结果 便是重新生成vnode。当这个render函数字符串在第一次mount、或者绑定的数据更新的时候，都会被调用， 生成Vnode。如果是数据的更新，那么Vnode会与数据改变之前的Vnode做diff，对内容做改动之后，就会更 新到我们真正的DOM</p>
<h3 id="49-谈谈你对Vue3-0有什么了解？"><a href="#49-谈谈你对Vue3-0有什么了解？" class="headerlink" title="49.谈谈你对Vue3.0有什么了解？"></a>49.谈谈你对Vue3.0有什么了解？</h3><p><strong>六大亮点</strong></p>
<ol>
<li>性能比vue2.x快1.2~2倍</li>
<li>支持tree-shaking，按需编译，体积比vue2.x更小</li>
<li>支持组合API</li>
<li>更好的支持TS</li>
<li>更先进的组件</li>
</ol>
<p><strong>性能比vue2.x快1.2~2倍如何实现的呢</strong></p>
<p><strong>l.diff算法更快</strong></p>
<pre><code class="hljs">vue2.0是需要全局去比较每个节点的，若发现有节点发生变化后，就去更新该节点
vue3.0是在创建虚拟dom中，会根据DOM的的内容会不会发生内容变化，添加静态标记，谁有flag！比较谁。
</code></pre>
<p><strong>2、静态提升</strong></p>
<pre><code class="hljs">vue2中无论元素是否参与更新，每次都会重新创建，然后再渲染vue3中对于不参与更新的元素，会做静态提升，
只被创建一次，在渲染时直接复用即可
</code></pre>
<p><strong>3、事件侦听缓存</strong></p>
<p>默认情况下，0ndick为动态绑定，所以每次都会追踪它的变化，但是因为是同一函数，没有必要追踪变化，接缓 存复用即可</p>
<p>在之前会添加静态标记8会把点击事件当做动态属性会进行diff算法比较，但是在事件监听缓存之后就没有静态标 记了，就会进行缓存复用</p>
<p><strong>为什么vue3.0体积比vue2.x小</strong></p>
<p>在vue3.0中创建vue项目除了vue-cli，webpack外还有一种创建方法是Vite Vite是作者开发的一款有意取代 webpack的工具，其实现原理是利用ES6的import会发送请求去加载文件的特性，拦截这些请求，做一些预编译， 省去webpack冗长的打包时间</p>
<h3 id="50-vue3-0-组合-API"><a href="#50-vue3-0-组合-API" class="headerlink" title="50.vue3.0 组合 API"></a>50.vue3.0 组合 API</h3><p>说一说vue3.0的组合API跟之前vue2.0在完成业务逻辑上的区别：<br>在vue2.0中：主要是往data和method里面添加内容，一个业务逻辑需要什么data和method就往里面添加，而组 合API就是有一个自己的方法，里面有自己专注的data和method。<br>Cimage-20230217100400438<br>^image-20230217100411590<br>^image-20230217100430825<br>再说一下组合API的本质是什么：首先composition API （组合人「1）和Option API（vue2.0中的data和method） 可以共用composition API （组合API）本质就是把内容添加到Option API中进行使用</p>
<h3 id="51-ref和reactive的简单理解"><a href="#51-ref和reactive的简单理解" class="headerlink" title="51.ref和reactive的简单理解"></a>51.ref和reactive的简单理解</h3><p>1.ref和reactive都是vue3的监听数据的方法，本质是proxy 2.ref基本类型复杂类型都可以监听（我们一般用ref监听 基本类型），reactive只能监听对象（arr，json）3.ref底层还是reactive，ref是对reactive的二次包装，ref定义的 数据访问的时候要多一个.value</p>
<h3 id="52-Vuex和redux有什么区别？他们的共同思想。"><a href="#52-Vuex和redux有什么区别？他们的共同思想。" class="headerlink" title="52.Vuex和redux有什么区别？他们的共同思想。"></a>52.Vuex和redux有什么区别？他们的共同思想。</h3><p>Redux和Vuex区别</p>
<ul>
<li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer,无需switch,只需在对<br>应的mutation函数里改变state值就可以</li>
<li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state就可以</li>
<li>Vuex数据流的JI顺序是:View调用store.commit提交对应的请求至归tore中对应的mutation函数–store改变<br>(vue检测到数据变化自动渲染)</li>
</ul>
<p>共同思想</p>
<ul>
<li>单一的数据源</li>
<li>变化可以预测</li>
<li>本质上:Redux和Vuex都是对MVVM思想的服务，将数据从视图中抽离的一种方案</li>
<li>形式上:Vuex借鉴了Redux,将store作为全局的数据中心，进行数据管理</li>
</ul>
<h3 id="53-简单说一下微信，Jx程序与Vue的区别"><a href="#53-简单说一下微信，Jx程序与Vue的区别" class="headerlink" title="53.简单说一下微信，Jx程序与Vue的区别"></a>53.简单说一下微信，Jx程序与Vue的区别</h3><h4 id="1、生命周期："><a href="#1、生命周期：" class="headerlink" title="1、生命周期："></a>1、生命周期：</h4><p>〃濯序的钩子函数要简单得多。vue的钩子函数在圆悌专新页面时，钩子函数都会触发，但是〃濯序的钩子函数， 页面不同的用库专方式，触发的钩子并不一样。<br>在页面加载请求数据时，两者钩子的使用有些类似，vue 一般会在created或者mounted中请求数据，而在&#x2F;J濯 序，会在onLoad或者onShow中请求数据。</p>
<h4 id="2、数据绑定："><a href="#2、数据绑定：" class="headerlink" title="2、数据绑定："></a>2、数据绑定：</h4><p>vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：</p>
<pre><code class="hljs">&lt;img :src=&quot;imgSrc&quot;/&gt;
</code></pre>
<p>小程序绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串</p>
<pre><code class="hljs">&lt;image src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt;&lt;/image&gt;
</code></pre>
<h4 id="3、列表循环"><a href="#3、列表循环" class="headerlink" title="3、列表循环"></a>3、列表循环</h4><h4 id="4、显示与隐藏元素"><a href="#4、显示与隐藏元素" class="headerlink" title="4、显示与隐藏元素"></a>4、显示与隐藏元素</h4><p>vue中，使用v-if和v-show控制元素的显示和隐藏<br>小程序中，使用wx-if和hidden控制元素的显示和隐藏</p>
<h4 id="5、事件处理"><a href="#5、事件处理" class="headerlink" title="5、事件处理"></a>5、事件处理</h4><p>vue :使用v-on:event绑定事件，或者使用@event绑定事件<br>小程序中，全用 bindtap(bind+event),或者 catchtap(catch+event)绑定事件</p>
<h4 id="6、数据的双向绑定"><a href="#6、数据的双向绑定" class="headerlink" title="6、数据的双向绑定"></a>6、数据的双向绑定</h4><p>在vue中，只需要再表单元素上加上v-model，然后再绑定data中对应的一个值，当表单元素内容发生变化时，data 中对应的值也会相应改变。<br>当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单 上的值赋值给data中的对应值。</p>
<h4 id="7、绑定事件传参"><a href="#7、绑定事件传参" class="headerlink" title="7、绑定事件传参"></a>7、绑定事件传参</h4><p>在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传人就可以了<br>在〃濯序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然 后在方法中，通过e.currentTarget.dataset.*的方式获取</p>
<h4 id="8、父子组件通信"><a href="#8、父子组件通信" class="headerlink" title="8、父子组件通信"></a>8、父子组件通信</h4><p>父组件向子组件传递数据，只需要在子组件通过v-bind传入一个值，在子组件中，通过props接收，即可完成数据 的传递<br>父组件向子组件通信和vue类以，但是&#x2F;J濯序没有通过v-bind，而是直接将值赋值给一个变量在子组件 properties中，接收传递的值</p>

              
            </div>
            <hr/>
            <div>
              <div>
  <img src="https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20241112163319.png" srcset="/img/loading.gif" lazyload>
</div>
<div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/20-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/" class="category-chain-item">20_面试问题</a>
  
  
    <span>></span>
    
  <a href="/categories/20-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01-%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/" class="category-chain-item">01_技术问题</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">#面试题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>15-前端面试问题</div>
      <div>https://janycode.github.io/2017/05/03/20_面试问题/01_技术问题/15-前端面试问题/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jerry(姜源)</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年5月3日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 姜源">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01_%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/13-Spring_MVC%E6%A1%86%E6%9E%B6/" title="13-Spring_MVC框架">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">13-Spring_MVC框架</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01_%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/14-%E5%B8%B8%E8%A7%81bug%E9%97%AE%E9%A2%98/" title="14-常见bug问题">
                        <span class="hidden-mobile">14-常见bug问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="SOHUCS" sid='https://janycode.github.io/2017/05/03/20_%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/01_%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/15-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/'></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#SOHUCS', function() {
      Fluid.utils.createScript("https://changyan.sohu.com/upload/changyan.js", function() {
        window.changyan.api.config({"appid":"cyw5OHIcO","appkey":"fea3446b3df4b3f129f34da4cbc87e51"})
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://simple.blog.csdn.net" target="_blank" rel="nofollow noopener"><span>CSDN</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/janycode" target="_blank" rel="nofollow noopener"><span>GitHub</span></a> <i class="iconfont icon-love"></i> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量(PV) 
        <span id="busuanzi_value_site_pv"></span>
         次，
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数(UV) 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

<!-- live2d 动画 -->
<script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script>
<script>
    L2Dwidget.init({
        "model": {
            jsonPath: "https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json",
            "scale": 1
        },
        "display": {
            "position": "right",
            "width": 100,
            "height": 200,
            "hOffset": 35,
            "vOffset": -85
        },
        "mobile": {
            "show": false,
            "scale": 0.1
        },
        "react": {
            "opacityDefault": 0.75,
            "opacityOnHover": 0.2
        }
    });
</script>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?bfff735c897eb60ea49b735096b20e47";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  

  

  




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
