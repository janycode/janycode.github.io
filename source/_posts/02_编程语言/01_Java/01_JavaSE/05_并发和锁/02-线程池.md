---
title: 02-线程池
date: 2016-4-28 21:59:06
tags:
- JavaSE
- 线程池
categories: 
- 02_编程语言
- 01_Java
- 01_JavaSE
- 05_并发和锁
---

### 1. 线程池概念

现有问题：
* 线程是宝贵的内存资源、单个线程约占1MB的空间，过多分配易造成内存溢出；
* 频繁的创建及销毁会增加虚拟机回收频率、资源开销，造成程序性能下降。

线程池：
* 线程容器，可设定线程分配的数量上限；
* 将预先创建的线程对象存入池中，并重用线程池中的线程对象；
* 避免频繁的创建和销毁。



### 2. 线程池原理
将任务提交给线程池，由线程池分配线程、运行任务，并在当前任务结束后复用线程。
![Java线程池](https://img-blog.csdnimg.cn/20200313223230204.png)

* 应用与线程池的交互和线程池的内部工作过程：

![image-20200817000106890](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200817000108.png)

### 3. 线程池创建
常用的线程池接口和类：
① **Executor** // 接口，线程池的顶级接口
② **ExecutorService** //接口，线程池接口，可通过Future<?> submit(Runnable task)提交任务代码
③ **Executors** // 工厂类，通过此类可以创建一个线程池`4种方式`
（1）通过 Executors.**newFixedThreadPool**(int nThreads) 获取固定数量的线程池
    @nThreads int 指定线程池中线程的数量
    @return ExecutorService 接口类型引用
（2）通过 Executors.**newCachedThreadPool**()获得动态数量的线程池，如不够则创建新的，没有上限
    @return ExecutorService 接口类型引用

![image-20200629141608484](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200629141609.png)

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class TestThreadPool {
      public static void main(String[] args) {
            // 线程池引用 --> 指向Executors工具类(工厂类)
            // 手动限定线程池中的固定数量
            //ExecutorService es = Executors.newFixedThreadPool(3);
            
            // 动态数量的线程池
            ExecutorService es = Executors.newCachedThreadPool();
            
            // 1.创建任务类对象
            MyTask task = new MyTask();
            // 2.将任务提交到线程池，由线程池调度、执行（谁先运行结束则优先被复用）
            es.submit(task);
            es.submit(task);
            es.submit(task);
            es.submit(task);
            es.submit(task);
            es.submit(task);
      }
}
// 线程任务
class MyTask implements Runnable {
      public void run() {
            int i = 0;
            while (i++ < 10) {
                  System.out.println(Thread.currentThread().getName() +  ":" + i);
            }
      }
}
```

### 4. Callable接口
```java
public interface Callable<V> {
    public V call() throws Exception;
}
```
特点：
* JDK5加入，与Runnable接口类似，实现之后代表一个线程任务；
* Callable具有泛型返回值，`可以声明异常`。



```java
// 普通方式 - 定义
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class TestCallable {
      public static void main(String[] args) {
            ExecutorService es = Executors.newFixedThreadPool(3);
            ThisTask task = new ThisTask();
            
            es.submit(task);
      }
}
class ThisTask implements Callable<Object> {
      @Override
      public Object call() throws Exception {
            for (int i = 1; i <= 50; i++) {
                  Thread.sleep((int)(Math.random() * 1000));
                  System.out.println(Thread.currentThread().getName() +  ":" + i);
            }
            
            return null;
      }
}
```

```java
// 匿名内部类 - 定义
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
public class TestNonNameThread {
      public static void main(String[] args) {
            
            // 匿名内部类 - 创建一个带有返回值的call线程任务
            Callable<Object> c = new Callable<Object>() {
                  @Override
                  public Object call() throws Exception { // ①允许抛异常
                        int sum = 0;
                        for (int i = 0; i <= 100; i++) {
                              Thread.sleep(1000);
                              sum += i;
                        }
                        return sum; // ②强制返回值
                  }
            };
            ExecutorService es = Executors.newFixedThreadPool(3);
            es.submit(c);
            System.out.println(es.toString());
            // 输出：java.util.concurrent.ThreadPoolExecutor@33909752
            //      [Running, pool size = 1, active threads = 1, queued  tasks = 0, completed tasks = 0]
            
            
            // 匿名内部类 - 创建一个run线程任务
            Runnable r = new Runnable() {
                  @Override
                  public void run() {
                        for (int i = 0; i <= 100; i++) {
                              System.out.println(i);
                        }
                  }
            };
            Thread thread2 = new Thread(r, "线程2");
            System.out.println(thread2.toString()); // Thread[线程2,5,main]
      }
}
```

### 5. Future接口
```java
public interface Future<V>
```
特点：
* 异步接收 ExecutorService.submit() 所返回的状态结果，当中包含了call()的返回值；
* 方法：**V get()**以阻塞形式等待Future中的`异步/并发计算`处理结果(call()的返回值)



```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
public class TestFuture {
      public static void main(String[] args) throws  InterruptedException, ExecutionException {
            ExecutorService es = Executors.newFixedThreadPool(3);
            MyCall call = new MyCall();
            MyCall2 call2 = new MyCall2();
            
            // 通过submit执行提交的任务，Future接收返回的结果
            Future<Integer> f = es.submit(call);
            Future<Integer> f2 = es.submit(call2);
            System.out.println( f.get() + f2.get()); // 5050
      }
}
// 计算1~50的和
class MyCall implements Callable<Integer> {
      @Override
      public Integer call() throws Exception {
            Integer sum = 0;
            for (int i = 1; i <= 50; i++) {
                  sum += i;
            }
            System.out.println(Thread.currentThread().getName() + ":" +  sum);
            return sum; // 1275
      }
}
// 计算51~100的和
class MyCall2 implements Callable<Integer> {
      @Override
      public Integer call() throws Exception {
            Integer sum = 0;
            for (int i = 51; i <= 100; i++) {
                  sum += i;
            }
            System.out.println(Thread.currentThread().getName() + ":" +  sum);
            return sum; // 3775
      }
}
```

