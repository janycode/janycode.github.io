---
title: 01-TS基础入门
date: 2022-5-22 21:36:21
tags:
- Vue
- TypeScript
- ts
categories: 
- 04_大前端
- 05_TypeScript
---

![image-20260107112930310](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260107112931807.png)

参考资料：

* TypeScript 官网：https://www.typescriptlang.org/zh/
* TypeScript 语法文档：https://zhongsp.gitbooks.io/typescript-handbook/content/

> 所有文件格式都是 `.ts` 后缀名。

## 1. TS 环境

### 安装

下载并安装好 nodejs。

全局安装 typescript：*npm i typescript -g*

转换 ts 为 js：*tsc hello.ts*

解决 ts 与 js 冲突问题：*tsc --init*   `生成配置文件 tsconfig.json`

自动编译：*tsc --watch*  或简写 *tsc -w*

发出错误：*tsc -noEmitOnError hello.ts*  `在发现错误时不编译为 js 文件`

> 使用 tsc 将 ts编译为js，使用 node 运行 js 文件。
>
> 注意：
>
> tsc --watch 时，默认会生成 .d.ts/.d.ts.map/.js.map 文件，可以通过配置关闭
>
> ```json
>     // Other Outputs
>     "sourceMap": false,
>     "declaration": false,
>     "declarationMap": false,
> ```

### 显式类型

```js
function test(person:string, date:Date) {
    console.log(`hello ${person}, tody is ${date}`);
}
test("jerry", new Date())
```

### 降级编译

tsconfig.json 中：`"target": "esnext",` 比如修改为 es5 `"target": "es5",`

### 严格模式

tsconfig.json 中 `"strict": true,` 配置为严格模式。

```json
    "strict": true,            //严格模式 1.严格 开启
    "noImplicitAny": true,     //严格模式 2.无任何隐式类型 开启
    "strictNullChecks": true,  //严格模式 3.严格的 null 检查 开启
```

默认后两个配置都合并在 **strict** 配置中。

## 2. TS 基本类型

### 类型声明

- 类型声明是TS非常重要的一个特点；

- 通过类型声明可以指定TS中变量（参数、形参）的类型；

- 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；

- 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；

- 语法：

  - ```js
    let 变量: 类型;
    let 变量: 类型 = 值;
    function fn(参数: 类型, 参数: 类型): 类型{
        ...
    }
    ```

### 自动类型判断

- TS拥有自动的类型判断机制
- 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型
- 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明

### 类型：

| **类型** | **例子**           | **描述**                       |
| -------- | ------------------ | ------------------------------ |
| number   | 1, -33, 2.5        | 任意数字                       |
| string   | 'hi', "hi", \`hi\` | 任意字符串                     |
| boolean  | true、false        | 布尔值true或false              |
| 字面量   | 其本身             | 限制变量的值就是该字面量的值   |
| any      | -                  | 任意类型                       |
| unknown  | -                  | 类型安全的any                  |
| void     | 空值（undefined）  | 没有值（或undefined）          |
| never    | 没有值             | 不能是任何值                   |
| object   | {name:'孙悟空'}    | 任意的JS对象                   |
| array    | [1,2,3]            | 任意JS数组                     |
| tuple    | [4,5]              | 元素，TS新增类型，固定长度数组 |
| enum     | enum{A, B}         | 枚举，TS中新增类型             |

#### number - 数字

```js
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;
```

#### boolean - 布尔

```js
let isDone: boolean = false;
```

#### string - 字符串

```js
let color: string = "blue";
color = 'red';

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.

I'll be ${age + 1} years old next month.`;
```

#### 字面量

也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围

```js
let color: 'red' | 'blue' | 'black';
let num: 1 | 2 | 3 | 4 | 5;
```

#### any（不要用）

```js
let d: any = 4;
d = 'hello';
d = true;
```

#### unknown（不要用）

```js
let notSure: unknown = 4;
notSure = 'hello';
```

```js
let s: string = 'hello';
// a61的类型是any，它可以赋值给任意变量*
// any赋值给其他变量时，TS也会同时关闭对那个赋值变量的类型检查！*
s = a61;
// a62的类型是unknown，它不能赋值给一个确定类型！*
// s = a62; //报错，不能将类型“unknown”分配给类型“string”。*
// 即：unknown 实际上就是一个类型安全的any*
// unknown类型的变量，不能直接赋值给其他变量*
if (typeof a62 === "string") {
	s = a62;
}
```

#### void - 空

```js
let unusable: void = undefined;
function fn(): void{
    return null
}
```

#### never - 没有值

```js
function error(message: string): never {
  throw new Error(message);
}
```

#### object - 对象

```js
let obj: object = {};
let c: {name: string, [propName: string]: any}
c = {name: "孙悟空", age: 18, gender: "男"}
let d: (a: number, b: number) => number   // d是一个函数，接收2个数字形参，返回值类型也是number
```

#### array - 数组

```js
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];
```

#### tuple - 元组

```js
let x: [string, number];
x = ["hello", 10];  //此时该类型赋值只能是一个字符串，一个数字
```

#### enum - 枚举

```js
enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;
enum Color {
  Red = 1,  //初始值 1
  Green,    //2
  Blue,     //3
}
let c: Color = Color.Green;

enum Color {
  Red = 1,    //初始值 1
  Green = 2,  //自定义值 2
  Blue = 4,   //自定义值 4
}
let c: Color = Color.Green;
```

### 联合类型

```js
let b4: "male" | "female";
b4 = "male";
b4 = "female";

let c4: boolean | string;
c4 = true;
c4 = 'hello';
```

### 组合类型

```js
// &表示同时需要满足的类型
let a5: { name: string } & { age: number };
a5 = { name: 'haha', age: 18 };
```

### 类型别名

用于一些类型比较长且复用率高，用一个别名代替，比如联合类型

```js
// 使用关键字type
type myType = 1 | 2 | 3 | 4 | 5;
let k: myType;
let l: myType;
let m: myType;

k = 2;
// k = 6 // error!
```

### 类型断言

- 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：

  - 第一种

    - ```
      let someValue: unknown = "this is a string";
      let strLength: number = (someValue as string).length;
      ```

  - 第二种

    - ```
      let someValue: unknown = "this is a string";
      let strLength: number = (<string>someValue).length;
      ```

## 3. 编译选项

### 自动编译文件

编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。

示例：

```sh
tsc xxx.ts -watch
#简写
tsc xxx.ts -w
```

### 自动编译整个项目

> 在当前项目下新建一个tsconfig.json，直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。
>
> **但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json**
>
> tsconfig.json是一个JSON文件，添加配置文件后，只需 tsc 命令即可完成对整个项目的编译
>
> tsconfig.json是TS编译器的配置文件，TS编译器根据它的配置信息对代码进行编译

配置选项：

#### include - 包含

- 定义`需要被编译的文件`
- 默认值：`["**/*"]`

```json
  "include":["src/**/*", "tests/**/*"]
```

上述示例中，所有src目录和tests目录下的文件都会被编译

#### exclude - 排除

- 定义`不需要编译的文件`
- 默认值：`["node_modules", "bower_components", "jspm_packages"]`

```json
  "exclude": ["./src/hello/**/*"]
```

上述示例中，src下hello目录下的文件都不会被编译

#### extends - 继承

- 定义`被继承的配置文件`

```json
"extends": "./configs/base"
```

上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息

#### files - 文件列表

- `指定被编译文件`的列表，**只有需要编译的文件少时才会用到**

```json
"files": [
    "core.ts",
    "sys.ts",
    "types.ts",
    "scanner.ts",
    "parser.ts",
    "utilities.ts",
    "binder.ts",
    "checker.ts",
    "tsc.ts"
  ]
```

- 列表中的文件都会被TS编译器所编译

#### compilerOptions - 编译器选项

- 编译选项是配置文件中非常重要也比较复杂的配置选项
- 在compilerOptions中包含多个子选项，用来完成对编译的配置

项目选项：

`target`

- 设置ts代码编译的目标版本

- 可选值：

  - ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext

- 示例：

  - ```
    "compilerOptions": {
        "target": "ES6"
    }
    ```

- 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码

`lib`

- 指定代码运行时所包含的库（宿主环境）

- 可选值：

  - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......

- 示例：

  - ```
    "compilerOptions": {
        "target": "ES6",
        "lib": ["ES6", "DOM"],
        "outDir": "dist",
        "outFile": "dist/aa.js"
    }
    ```

`module`

- 设置编译后代码使用的模块化系统

- 可选值：

  - CommonJS、UMD、AMD、System、ES2020、ESNext、None

- 示例：

  - ```
    "compilerOptions": {
        "module": "CommonJS"
    }
    ```

`outDir`

- 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置

- 示例：

  - ```
    "compilerOptions": {
        "outDir": "dist"
    }
    ```

  - 设置后编译后的js文件将会生成到dist目录

`outFile`

- 将所有的文件编译为一个js文件

- 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中

- 示例：

  - ```
    "compilerOptions": {
        "outFile": "dist/app.js"
    }
    ```

`rootDir`

- 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录

- 示例：

  - ```
    "compilerOptions": {
        "rootDir": "./src"
    }
    ```

`allowJs`

- 是否对js文件编译

`checkJs`

- 是否对js文件进行检查

- 示例：

  - ```
    "compilerOptions": {
        "allowJs": true,
        "checkJs": true
    }
    ```

`removeComments`

- 是否删除编译后的文件的注释
- 默认值：false

`noEmit`

- 不生成编译文件
- 默认值：false

`noEmitOnError`

- 有错误时不生成编译文件
- 默认值：false
- sourceMap
  - 是否生成sourceMap
  - 默认值：false

- 严格检查
  - strict
    - 启用所有的严格检查，默认值为false，设置后相当于开启了所有的严格检查
  - alwaysStrict
    - 设置编译后的js代码是否使用严格模式，默认false
  - noImplicitAny
    - 禁止隐式的any类型
  - noImplicitThis
    - 禁止类型不明确的this
  - strictBindCallApply
    - 严格检查bind、call和apply的参数列表
  - strictFunctionTypes
    - 严格检查函数的类型
  - strictNullChecks
    - 严格的空值检查
  - strictPropertyInitialization
    - 严格检查属性是否初始化
- 额外检查
  - noFallthroughCasesInSwitch
    - 检查switch语句包含正确的break
  - noImplicitReturns
    - 检查函数没有隐式的返回值
  - noUnusedLocals
    - 检查未使用的局部变量
  - noUnusedParameters
    - 检查未使用的参数
- 高级
  - allowUnreachableCode
    - 检查不可达代码
    - 可选值：
      - true，忽略不可达代码
      - false，不可达代码将引起错误
  - noEmitOnError
    - 有错误时不生成编译文件
    - 默认值：false

## 4. 面向对象

要想面向对象，操作对象，首先便要拥有对象；

要创建对象，必须要先定义类，所谓的类可以理解为对象的模型；

程序中可以根据类创建指定类型的对象；

举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，不同的类可以用来创建不同的对象；

### 定义类

```js
class 类名 {
    属性名: 类型
    constructor(属性参数: 类型){
        this.属性名 = 参数
    }
    
    方法名(){
        ....
    }
}
```

示例：

```js
class Person {
    name: string
    age: number

    constructor(name: string, age: number){
        this.name = name
        this.age = age
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`)
    }
}
```

使用类：

```js
const p = new Person('孙悟空', 18);
p.sayHello();
```

### 构造函数

可以使用`constructor`定义一个构造器方法；

```js
class C{
    name: string
    age: number
    constructor(name: string, age: number) {
        this.name = name
        this.age = age
    }
}
```

同时也可以直接将属性定义在构造函数中：

```js
class C {
    constructor(public name: string, public age: number) {
    }
}
```

上面两种定义方法是完全相同的！

**注2：子类继承父类时，必须调用父类的构造方法（如果子类中也定义了构造方法）！**

例如：

```js
class A {
    protected num: number;
    constructor(num: number) {
        this.num = num;
    }
}
class X extends A {
    protected name: string;
    constructor(num: number, name: string) {
        super(num); //如果在X类中不调用`super`将会报错！
        this.name = name;
    }
}
```



### 封装（encapsulation）

对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装

默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置

- 静态属性（static）：
  - 声明为static的属性或方法不再属于实例，而是属于类的属性；
- 只读属性（readonly）：
  - 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改
- TS中属性具有三种修饰符：
  - public（默认值），可以在类、子类和对象中访问
  - protected ，可以在类、子类中访问
  - private ，可以在类中访问

示例：

public：

```js
class Person{
    public name: string; // 写或什么都不写都是public
    public age: number;
    constructor(name: string, age: number){
        this.name = name; // 可以在类中修改
        this.age = age;
    }
    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}
const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 可以通过对象修改
```

protected：

```js
class Person{
    protected name: string;
    protected age: number;
    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }
    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}
const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
```

private：

```js
class Person{
    private name: string;
    private age: number;
    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }
    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中不能修改
    }
}
const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
```

### 属性存取器

对于一些不希望被任意修改的属性，可以将其设置为 private

直接将其设置为private将导致无法再通过对象修改其中的属性

我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器

读取属性的方法叫做setter方法，设置属性的方法叫做getter方法

示例：

```js
class Person{
    private _name: string;  //私有属性通常以 _ 开头
    constructor(name: string){
        this._name = name;
    }
    get name(){
        return this._name;
    }
    set name(name: string){
        this._name = name;
    }
}
const p1 = new Person('孙悟空');
// 实际通过调用getter方法读取name属性
console.log(p1.name);
// 实际通过调用setter方法修改name属性 
p1.name = '猪八戒'; 
```

### 静态属性

静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用

静态属性（方法）使用 static 开头

示例：

```js
class Tools{
    static PI = 3.1415926;
    
    static sum(num1: number, num2: number){
        return num1 + num2
    }
}
console.log(Tools.PI);
console.log(Tools.sum(123, 456));
```

### this

在类中，使用this表示当前对象。

### 继承

继承时面向对象中的又一个特性

通过继承可以将其他类中的属性和方法引入到当前类中

示例：

```js
class Animal{
    name: string;
    age: number;
    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }
}
class Dog extends Animal{
    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }
}
const dog = new Dog('旺财', 4);
dog.bark();
```

通过继承可以在不修改类的情况下完成对类的扩展

### 重写

发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写

示例：

```js
class Animal{
    name: string;
    age: number;
    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }
    run(){
        console.log(`父类中的run方法！`);
    }
}
class Dog extends Animal{
    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }
    run(){
        super.run()
        console.log(`子类中的run方法，会重写父类中的run方法！`);
    }
}
const dog = new Dog('旺财', 4);
dog.bark();
```

**在子类中可以使用super来完成对父类的引用**

### 抽象类（abstract class）

抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例

> 抽象类的优点：
>
> - 只能被继承，不能被实例化，防止开发者胡乱创建没必要的对象
> - 抽象类定义的抽象方法必须被重写，防止派生类使用抽象类的抽象方法
> - 抽象类可以没有抽象方法，但抽象方法必须在抽象类中

```js
abstract class Animal{
  abstract run(): void;
  bark(){
      console.log('动物在叫~');
  }
}
class Dog extends Animals{
  run(){
      console.log('狗在跑~');
  }
}
```

使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现。

## 5. 接口（Interface）

接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；

接口主要负责定义一个类的结构，接口可以去限制一个对象的接口：对象只有包含接口中定义的所有属性和方法时才能匹配接口；

同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性；

> 接口和抽象类的区别：
>
> - 接口只能被类使用implements实现或者当做类型给变量声明；抽象类可以被类继承，可以当做变量声明类型；
> - 接口中的所有方法都是抽象方法，必须被实现类重写；抽象类可以有抽象方法，也可以有具体方法
> - 接口没有构造函数；抽象类有构造函数，派生类必须使用super调用抽象类的构造函数
> - 接口是定义类的规范，只有实现了接口才能说这个类符合规范；抽象类是抽取所有派生类的共有的属性和方法，一个抽象，这样派生类使用继承就能获取这些属性和方法

示例（检查对象类型）：

```js
interface Person{
    name: string;
    sayHello():void;
}
function fn(per: Person){
    per.sayHello();
}
fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});
```

示例（实现）：

```js
interface Person{
   name: string;
   sayHello():void;
}
class Student implements Person{
   constructor(public name: string) {
   }
   sayHello() {
       console.log('大家好，我是'+this.name);
   }
}
```

## 6. 泛型（Generic）

定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；

此时泛型便能够发挥作用；

举个例子：

```js
function test(arg: any): any{
    return arg;
}
```

上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；

由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的：

首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；

### 泛型函数

#### 创建泛型函数

```js
function test<T>(arg: T): T{
    return arg;
}
```

这里的`<T>`就是泛型；

T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型；

所以泛型其实很好理解，就表示某个类型；

那么如何使用上边的函数呢？

#### 使用泛型函数

##### 方式一（直接使用）：

```js
test(10)
```

使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式

##### 方式二（指定类型）：

```js
test<number>(10)
```

也可以在函数后手动指定泛型；

### 函数中声明多个泛型

可以同时指定多个泛型，泛型间使用逗号隔开：

```js
function test<T, K>(a: T, b: K): K{
  return b;
}
test<number, string>(10, "hello");
```

使用泛型时，完全可以将泛型当成是一个普通的类去使用；

### 泛型类

类中同样可以使用泛型：

```js
class MyClass<T>{
  prop: T;
  constructor(prop: T){
      this.prop = prop;
  }
}
```

### 泛型继承

除此之外，也可以对泛型的范围进行约束

```js
interface MyInter{
  length: number;
}
function test<T extends MyInter>(arg: T): number{
  return arg.length;
}
```

使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用；



