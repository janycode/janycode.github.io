---
title: 01-TS基础入门
date: 2022-5-22 21:36:21
tags:
- Vue
- TypeScript
- ts
categories: 
- 04_大前端
- 05_TypeScript
---

![image-20260107112930310](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260107112931807.png)

参考资料：

* TypeScript 官网：https://www.typescriptlang.org/zh/
* TypeScript 语法文档：https://zhongsp.gitbooks.io/typescript-handbook/content/



## 1. TS 环境

### 安装

下载并安装好 nodejs。

全局安装 typescript：*npm i typescript -g*

转换 ts 为 js：*tsc hello.ts*

解决 ts 与 js 冲突问题：*tsc --init*   `生成配置文件 tsconfig.json`

自动编译：*tsc --watch*  或简写 *tsc -w*

发出错误：*tsc -noEmitOnError hello.ts*  `在发现错误时不编译为 js 文件`

> 使用 tsc 将 ts编译为js，使用 node 运行 js 文件。
>
> 注意：
>
> tsc --watch 时，默认会生成 .d.ts/.d.ts.map/.js.map 文件，可以通过配置关闭
>
> ```json
>     // Other Outputs
>     "sourceMap": false,
>     "declaration": false,
>     "declarationMap": false,
> ```

### 显式类型

```ts
function test(person:string, date:Date) {
    console.log(`hello ${person}, tody is ${date}`);
}
test("jerry", new Date())
```

### 降级编译

tsconfig.json 中：`"target": "esnext",` 比如修改为 es5 `"target": "es5",`

### 严格模式

tsconfig.json 中 `"strict": true,` 配置为严格模式。

```json
    "strict": true,            //严格模式 1.严格 开启
    "noImplicitAny": true,     //严格模式 2.无任何隐式类型 开启
    "strictNullChecks": true,  //严格模式 3.严格的 null 检查 开启
```

默认后两个配置都合并在 **strict** 配置中。

## 2. TS 基本类型

### 类型声明

- 类型声明是TS非常重要的一个特点；

- 通过类型声明可以指定TS中变量（参数、形参）的类型；

- 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错；

- 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值；

- 语法：

  - ```ts
    let 变量: 类型;
    let 变量: 类型 = 值;
    function fn(参数: 类型, 参数: 类型): 类型{
        ...
    }
    ```

### 自动类型判断

- TS拥有自动的类型判断机制
- 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型
- 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明

### 类型：

| **类型** | **例子**           | **描述**                       |
| -------- | ------------------ | ------------------------------ |
| number   | 1, -33, 2.5        | 任意数字                       |
| string   | 'hi', "hi", \`hi\` | 任意字符串                     |
| boolean  | true、false        | 布尔值true或false              |
| 字面量   | 其本身             | 限制变量的值就是该字面量的值   |
| any      | -                  | 任意类型                       |
| unknown  | -                  | 类型安全的any                  |
| void     | 空值（undefined）  | 没有值（或undefined）          |
| never    | 没有值             | 不能是任何值                   |
| object   | {name:'孙悟空'}    | 任意的JS对象                   |
| array    | [1,2,3]            | 任意JS数组                     |
| tuple    | [4,5]              | 元素，TS新增类型，固定长度数组 |
| enum     | enum{A, B}         | 枚举，TS中新增类型             |

#### number - 数字

```ts
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;
```

#### boolean - 布尔

```ts
let isDone: boolean = false;
```

#### string - 字符串

```ts
let color: string = "blue";
color = 'red';

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.

I'll be ${age + 1} years old next month.`;
```

#### 字面量

也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围

```ts
let color: 'red' | 'blue' | 'black';
let num: 1 | 2 | 3 | 4 | 5;
```

#### any（不要用）

```ts
let d: any = 4;
d = 'hello';
d = true;
```

#### unknown（不要用）

```ts
let notSure: unknown = 4;
notSure = 'hello';
```

```ts
let s: string = 'hello';
// a61的类型是any，它可以赋值给任意变量*
// any赋值给其他变量时，TS也会同时关闭对那个赋值变量的类型检查！*
s = a61;
// a62的类型是unknown，它不能赋值给一个确定类型！*
// s = a62; //报错，不能将类型“unknown”分配给类型“string”。*
// 即：unknown 实际上就是一个类型安全的any*
// unknown类型的变量，不能直接赋值给其他变量*
if (typeof a62 === "string") {
	s = a62;
}
```

#### void - 空

```ts
let unusable: void = undefined;
function fn(): void{
    return null
}
```

#### never - 没有值

```ts
function error(message: string): never {
  throw new Error(message);
}
```

#### object - 对象

```ts
let obj: object = {};
let c: {name: string, [propName: string]: any}
c = {name: "孙悟空", age: 18, gender: "男"}
let d: (a: number, b: number) => number   // d是一个函数，接收2个数字形参，返回值类型也是number
```

#### array - 数组

```ts
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];
```

#### tuple - 元组

```ts
let x: [string, number];
x = ["hello", 10];  //此时该类型赋值只能是一个字符串，一个数字
```

#### enum - 枚举

```ts
enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;
enum Color {
  Red = 1,  //初始值 1
  Green,    //2
  Blue,     //3
}
let c: Color = Color.Green;

enum Color {
  Red = 1,    //初始值 1
  Green = 2,  //自定义值 2
  Blue = 4,   //自定义值 4
}
let c: Color = Color.Green;
```

### 联合类型

```ts
let b4: "male" | "female";
b4 = "male";
b4 = "female";

let c4: boolean | string;
c4 = true;
c4 = 'hello';
```

### 组合类型

```ts
// &表示同时需要满足的类型
let a5: { name: string } & { age: number };
a5 = { name: 'haha', age: 18 };
```

### 类型别名

用于一些类型比较长且复用率高，用一个别名代替，比如联合类型

```ts
// 使用关键字type
type myType = 1 | 2 | 3 | 4 | 5;
let k: myType;
let l: myType;
let m: myType;

k = 2;
// k = 6 // error!
```

### 类型断言

- 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：

  - 第一种

    - ```
      let someValue: unknown = "this is a string";
      let strLength: number = (someValue as string).length;
      ```

  - 第二种

    - ```
      let someValue: unknown = "this is a string";
      let strLength: number = (<string>someValue).length;
      ```

## 3. 编译选项

### 自动编译文件

编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。

示例：

```sh
tsc xxx.ts -watch
#简写
tsc xxx.ts -w
```

### 自动编译整个项目

> 在当前项目下新建一个tsconfig.json，直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。
>
> **但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json**
>
> tsconfig.json是一个JSON文件，添加配置文件后，只需 tsc 命令即可完成对整个项目的编译
>
> tsconfig.json是TS编译器的配置文件，TS编译器根据它的配置信息对代码进行编译

配置选项：

#### include - 包含

- 定义`需要被编译的文件`
- 默认值：`["**/*"]`

```json
  "include":["src/**/*", "tests/**/*"]
```

上述示例中，所有src目录和tests目录下的文件都会被编译

#### exclude - 排除

- 定义`不需要编译的文件`
- 默认值：`["node_modules", "bower_components", "jspm_packages"]`

```json
  "exclude": ["./src/hello/**/*"]
```

上述示例中，src下hello目录下的文件都不会被编译

#### extends - 继承

- 定义`被继承的配置文件`

```json
"extends": "./configs/base"
```

上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息

#### files - 文件列表

- `指定被编译文件`的列表，**只有需要编译的文件少时才会用到**

```json
"files": [
    "core.ts",
    "sys.ts",
    "types.ts",
    "scanner.ts",
    "parser.ts",
    "utilities.ts",
    "binder.ts",
    "checker.ts",
    "tsc.ts"
  ]
```

- 列表中的文件都会被TS编译器所编译

#### compilerOptions - 编译器选项

- 编译选项是配置文件中非常重要也比较复杂的配置选项
- 在compilerOptions中包含多个子选项，用来完成对编译的配置

项目选项：

`target`

- 设置ts代码编译的目标版本

- 可选值：

  - ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext

- 示例：

  - ```
    "compilerOptions": {
        "target": "ES6"
    }
    ```

- 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码

`lib`

- 指定代码运行时所包含的库（宿主环境）

- 可选值：

  - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......

- 示例：

  - ```
    "compilerOptions": {
        "target": "ES6",
        "lib": ["ES6", "DOM"],
        "outDir": "dist",
        "outFile": "dist/aa.js"
    }
    ```

`module`

- 设置编译后代码使用的模块化系统

- 可选值：

  - CommonJS、UMD、AMD、System、ES2020、ESNext、None

- 示例：

  - ```
    "compilerOptions": {
        "module": "CommonJS"
    }
    ```

`outDir`

- 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置

- 示例：

  - ```
    "compilerOptions": {
        "outDir": "dist"
    }
    ```

  - 设置后编译后的js文件将会生成到dist目录

`outFile`

- 将所有的文件编译为一个js文件

- 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中

- 示例：

  - ```
    "compilerOptions": {
        "outFile": "dist/app.js"
    }
    ```

`rootDir`

- 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录

- 示例：

  - ```
    "compilerOptions": {
        "rootDir": "./src"
    }
    ```

`allowJs`

- 是否对js文件编译

`checkJs`

- 是否对js文件进行检查

- 示例：

  - ```
    "compilerOptions": {
        "allowJs": true,
        "checkJs": true
    }
    ```

`removeComments`

- 是否删除编译后的文件的注释
- 默认值：false

`noEmit`

- 不生成编译文件
- 默认值：false

`noEmitOnError`

- 有错误时不生成编译文件
- 默认值：false
- sourceMap
  - 是否生成sourceMap
  - 默认值：false

- 严格检查
  - strict
    - 启用所有的严格检查，默认值为false，设置后相当于开启了所有的严格检查
  - alwaysStrict
    - 设置编译后的js代码是否使用严格模式，默认false
  - noImplicitAny
    - 禁止隐式的any类型
  - noImplicitThis
    - 禁止类型不明确的this
  - strictBindCallApply
    - 严格检查bind、call和apply的参数列表
  - strictFunctionTypes
    - 严格检查函数的类型
  - strictNullChecks
    - 严格的空值检查
  - strictPropertyInitialization
    - 严格检查属性是否初始化
- 额外检查
  - noFallthroughCasesInSwitch
    - 检查switch语句包含正确的break
  - noImplicitReturns
    - 检查函数没有隐式的返回值
  - noUnusedLocals
    - 检查未使用的局部变量
  - noUnusedParameters
    - 检查未使用的参数
- 高级
  - allowUnreachableCode
    - 检查不可达代码
    - 可选值：
      - true，忽略不可达代码
      - false，不可达代码将引起错误
  - noEmitOnError
    - 有错误时不生成编译文件
    - 默认值：false

## 4. 面向对象

要想面向对象，操作对象，首先便要拥有对象；

要创建对象，必须要先定义类，所谓的类可以理解为对象的模型；

程序中可以根据类创建指定类型的对象；

举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，不同的类可以用来创建不同的对象；

### 定义类

```ts
class 类名 {
    属性名: 类型
    constructor(属性参数: 类型){
        this.属性名 = 参数
    }
    
    方法名(){
        ....
    }
}
```

示例：

```ts
class Person {
    name: string
    age: number

    constructor(name: string, age: number){
        this.name = name
        this.age = age
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`)
    }
}
```

使用类：

```ts
const p = new Person('孙悟空', 18);
p.sayHello();
```

### 构造函数

可以使用`constructor`定义一个构造器方法；

```ts
class C{
    name: string
    age: number
    constructor(name: string, age: number) {
        this.name = name
        this.age = age
    }
}
```

同时也可以直接将属性定义在构造函数中：

```ts
class C {
    constructor(public name: string, public age: number) {
    }
}
```

上面两种定义方法是完全相同的！

**注2：子类继承父类时，必须调用父类的构造方法（如果子类中也定义了构造方法）！**

例如：

```ts
class A {
    protected num: number;
    constructor(num: number) {
        this.num = num;
    }
}
class X extends A {
    protected name: string;
    constructor(num: number, name: string) {
        super(num); //如果在X类中不调用`super`将会报错！
        this.name = name;
    }
}
```



### 封装（encapsulation）

对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装

默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置

- 静态属性（static）：
  - 声明为static的属性或方法不再属于实例，而是属于类的属性；
- 只读属性（readonly）：
  - 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改
- TS中属性具有三种修饰符：
  - public（默认值），可以在类、子类和对象中访问
  - protected ，可以在类、子类中访问
  - private ，可以在类中访问

示例：

public：

```ts
class Person{
    public name: string; // 写或什么都不写都是public
    public age: number;
    constructor(name: string, age: number){
        this.name = name; // 可以在类中修改
        this.age = age;
    }
    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}
const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 可以通过对象修改
```

protected：

```ts
class Person{
    protected name: string;
    protected age: number;
    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }
    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}
const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
```

private：

```ts
class Person{
    private name: string;
    private age: number;
    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }
    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中不能修改
    }
}
const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
```

### 属性存取器

对于一些不希望被任意修改的属性，可以将其设置为 private

直接将其设置为private将导致无法再通过对象修改其中的属性

我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器

读取属性的方法叫做setter方法，设置属性的方法叫做getter方法

示例：

```ts
class Person{
    private _name: string;  //私有属性通常以 _ 开头
    constructor(name: string){
        this._name = name;
    }
    get name(){
        return this._name;
    }
    set name(name: string){
        this._name = name;
    }
}
const p1 = new Person('孙悟空');
// 实际通过调用getter方法读取name属性
console.log(p1.name);
// 实际通过调用setter方法修改name属性 
p1.name = '猪八戒'; 
```

### 静态属性

静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用

静态属性（方法）使用 static 开头

示例：

```ts
class Tools{
    static PI = 3.1415926;
    
    static sum(num1: number, num2: number){
        return num1 + num2
    }
}
console.log(Tools.PI);
console.log(Tools.sum(123, 456));
```

### this

在类中，使用this表示当前对象。

### 继承

继承时面向对象中的又一个特性

通过继承可以将其他类中的属性和方法引入到当前类中

示例：

```ts
class Animal{
    name: string;
    age: number;
    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }
}
class Dog extends Animal{
    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }
}
const dog = new Dog('旺财', 4);
dog.bark();
```

通过继承可以在不修改类的情况下完成对类的扩展

### 重写

发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写

示例：

```ts
class Animal{
    name: string;
    age: number;
    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }
    run(){
        console.log(`父类中的run方法！`);
    }
}
class Dog extends Animal{
    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }
    run(){
        super.run()
        console.log(`子类中的run方法，会重写父类中的run方法！`);
    }
}
const dog = new Dog('旺财', 4);
dog.bark();
```

**在子类中可以使用super来完成对父类的引用**

### 抽象类（abstract class）

抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例

> 抽象类的优点：
>
> - 只能被继承，不能被实例化，防止开发者胡乱创建没必要的对象
> - 抽象类定义的抽象方法必须被重写，防止派生类使用抽象类的抽象方法
> - 抽象类可以没有抽象方法，但抽象方法必须在抽象类中

```ts
abstract class Animal{
  abstract run(): void;
  bark(){
      console.log('动物在叫~');
  }
}
class Dog extends Animals{
  run(){
      console.log('狗在跑~');
  }
}
```

使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现。

## 5. 接口（Interface）

接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；

接口主要负责定义一个类的结构，接口可以去限制一个对象的接口：对象只有包含接口中定义的所有属性和方法时才能匹配接口；

同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性；

> 接口和抽象类的区别：
>
> - 接口只能被类使用implements实现或者当做类型给变量声明；抽象类可以被类继承，可以当做变量声明类型；
> - 接口中的所有方法都是抽象方法，必须被实现类重写；抽象类可以有抽象方法，也可以有具体方法
> - 接口没有构造函数；抽象类有构造函数，派生类必须使用super调用抽象类的构造函数
> - 接口是定义类的规范，只有实现了接口才能说这个类符合规范；抽象类是抽取所有派生类的共有的属性和方法，一个抽象，这样派生类使用继承就能获取这些属性和方法

示例（检查对象类型）：

```ts
interface Person{
    name: string;
    sayHello():void;
}
function fn(per: Person){
    per.sayHello();
}
fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});
```

示例（实现）：

```ts
interface Person{
   name: string;
   sayHello():void;
}
class Student implements Person{
   constructor(public name: string) {
   }
   sayHello() {
       console.log('大家好，我是'+this.name);
   }
}
```

## 6. 泛型（Generic）

定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；

此时泛型便能够发挥作用；

举个例子：

```ts
function test(arg: any): any{
    return arg;
}
```

上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；

由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的：

首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；

### 泛型函数

#### 创建泛型函数

```ts
function test<T>(arg: T): T{
    return arg;
}
```

这里的`<T>`就是泛型；

T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型；

所以泛型其实很好理解，就表示某个类型；

那么如何使用上边的函数呢？

#### 使用泛型函数

##### 方式一（直接使用）：

```ts
test(10)
```

使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式

##### 方式二（指定类型）：

```ts
test<number>(10)
```

也可以在函数后手动指定泛型；

### 函数中声明多个泛型

可以同时指定多个泛型，泛型间使用逗号隔开：

```ts
function test<T, K>(a: T, b: K): K{
  return b;
}
test<number, string>(10, "hello");
```

使用泛型时，完全可以将泛型当成是一个普通的类去使用；

### 泛型类

类中同样可以使用泛型：

```ts
class MyClass<T>{
  prop: T;
  constructor(prop: T){
      this.prop = prop;
  }
}
```

### 泛型继承

除此之外，也可以对泛型的范围进行约束

```ts
interface MyInter{
  length: number;
}
function test<T extends MyInter>(arg: T): number{
  return arg.length;
}
```

使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用；



## 7. TS + Vue3

1. TypeScript 的定位是静态类型语言，在`写代码的阶段就能检查错误`，而非运行阶段
2. 类型系统是最好的文档，增加了代码的`可读性和可维护性`
3. 有一定的学习成本，需要链接`接口 interfaces`、`泛型 generics`、`类 classes` 等
4. `.ts 最后被编译成 js`



### 变量声明

```ts
// 类型推断
var myname:string = "jerry"   // 定义 myname 只能为字符串类型，其他类型赋值编写就报错
var myname1 = "hello"  //隐式类型推断
myname.substring(0, 1)

var myage:number = 100.34
myage = parseInt(myage.toFixed(2)) 
console.log(myage)

var myvalue:string|number = 100  // | 或，两种类型都可以
myvalue = "300"
```

```ts
// 数组
var mylist:string[] = ['jerry', 'tom', 'spike']
mylist.push('lucy')

var mylist2:number[] = [1, 2, 3]
mylist2.push(100)

var mylist3:(string|number)[] = ['jerry', 18]
mylist3.push(20)
mylist3.push('tom')

var myany:any = "123"     // any类型 就失去了 ts 类型检查的能力了 - 能不用就不用
myany = {}
myany = []
```

```ts
// 第二种风格: 泛型写法
var mylist4:Array<string> = ['aaa', 'bbb']
var mylist5:Array<string|number> = ['ccc', 10]
var mylist6:Array<any> = ['ddd', 11, {}, []]
```

```ts
// 对象
var myobj = {
    name: 'jerry',
    age: 18
}
interface InterObj {        //接口形式定义对象的字段和类型
    name:string,
    age:number,
    location?:string        //?可选属性
    [propName:string]:any   //可以不限制添加额外属性
}
var myobj1:InterObj
myobj1 = {
    name: 'tom',
    age: 20,
    a: {},
    b: []
}
```

### 函数

```ts
// 函数：限定形参类型、返回值类型
function test(a: number, b: number):number {
  return a + b
}

var mynum:number = test(1, 2)
```



### ts+选项式API

参考 vue 官网：https://cn.vuejs.org/guide/typescript/options-api.html

`不推荐`，官方更推荐与 组合式 api使用。

* 注意：接口类型限定
* 注意：类型断言

```vue
<template>
  <div>
    voa app - {{ myname }}
    <button @click="handleChange">click</button>
    <ul>
      <li v-for="(item, index) in list" :key="item">{{ item }}</li>
    </ul>
    <div ref="mydiv">测试</div>
    输入框：<input type="text" ref="myintput">
  </div>
</template>

<script lang="ts">
interface InterState {
  myname: string
  myage: number
  list: Array<string>
}
export default {
  data() {
    return {
      myname: "jerry",
      myage: 18,
      list: [],
    } as InterState // 限定为指定的接口类型
  },
  methods: {
    handleChange() {
      this.myname = "tom"
      this.list.push(this.myname)
      // 类型断言
      console.log((this.$refs.mydiv as HTMLDivElement).innerHTML)
      console.log((this.$refs.myintput as HTMLInputElement).value)
    },
  },
}
</script>
```

父-示例：

```vue
<template>
  <div>
    <Child title="首页" :item="{name:'jerry', age:18, list:[1,2,3]}"></Child>
  </div>
</template>

<script lang="ts">
import Child from "./Child.vue"

export default {
  components: {
    Child,
  }
}
</script>
```

子-示例：

```vue
<template>
  <div>child - {{ title }} - {{ item?.name }} - {{ item?.age }} - {{ item?.list }}</div>
</template>

<script lang="ts">
import type { PropType } from "vue"   //引入类型断言
interface IProps {  //定义接口类型
  name: string
  age: number
  list: Array<number>
}
export default {
  props: {
    title: String,
    item: Object as PropType<IProps>,  //限定为接口类型
  },
}
</script>
```



### ts+组合式API

示例：注意 接口类型限定 interface 和 类型断言如 `ref<HTMLDivElement>()`

```vue
<template>
  <div>
    vca - {{ myname }} - {{ computedMyname }}
    <div ref="mydiv">这是个div</div>
  </div>
</template>

<script lang="ts" setup>
import { computed, onMounted, reactive, ref } from "vue"
import type { Ref } from "vue"
// 隐式推导
// const state = reactive({
//     myname: 'jerry'
// })
interface IState {
  myname: string
}
const state: IState = reactive({
  myname: "jerry",
})

// const myname = ref("tom1") //隐式推导
// const myname:Ref<string> = ref('tom2') //Ref<>泛型，需要导入 Ref
const myname = ref<string>("tom3") //ref<>
const mylist = ref<IState[]>([])   // [{myname:'xxx'}, {myname:'yyy'}]

const mydiv = ref<HTMLDivElement>()
onMounted(() => {
  console.log(mydiv.value?.innerHTML)
})

const computedMyname = computed<string>(() => myname.value.substring(0, 1).toUpperCase() + myname.value.substring(1))

</script>
```

父-示例：

```vue
<template>
  <div>
    <Child title="首页" :obj="{name:'jerry', age: 20}"></Child>
  </div>
</template>

<script lang="ts" setup>
import Child from "./Child.vue"
</script>
```

子-示例：`defineProps<{...}>` 与 `defineEmits<{...}>`

```vue
<template>
  <div>child... - {{ title }}-{{ obj.name }}-{{ obj.age }}</div>
</template>

<script lang="ts" setup>
interface IProps {
    name:String,
    age:Number
}
const props = defineProps<{
    title:string,
    obj:IProps   //可选属性，通过接口定义类型
}>()

// 子传父
const emit = defineEmits<{
  (e: 'event', myvalue: string): void
}>()
const handleClick = () => {
  emit("event", "hello")
}
</script>
```



## 8. TS 打包

### webpack 整合

通常情况下，实际开发中我们都需要使用构建工具对代码进行打包；

TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS；

步骤如下：

#### 初始化项目

进入项目根目录，执行命令 `npm init -y`，创建package.json文件

#### 下载构建工具

命令如下：

```sh
npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin html-webpack-plugin
```

共安装了7个包:

- webpack：构建工具webpack
- webpack-cli：webpack的命令行工具
- webpack-dev-server：webpack的开发服务器
- typescript：ts编译器
- ts-loader：ts加载器，用于在webpack中编译ts文件
- clean-webpack-plugin：webpack中的清除插件，每次构建都会先清除目录
- html-webpack-plugin：webpack中html插件，用来自动创建html文件

#### 配置 webpack

根目录下创建 webpack 的配置文件`webpack.config.js`：

```js
const path = require("path");
const HtmlWebpackPlugin = require("html-webpack-plugin");
const { CleanWebpackPlugin } = require("clean-webpack-plugin");
// webpack中的所有配置信息都应该写在module.exports中
module.exports = {
   optimization:{
       minimize: false // 关闭代码压缩，可选
   },
   // 指定入口文件
   entry: "./src/index.ts",
   devtool: "inline-source-map",
   devServer: {
       contentBase: './dist'
   },
   // 指定打包文件所在目录
   output: {
       // 指定打包文件的目录
       path: path.resolve(__dirname, "dist"),
       // 打包后文件的文件名
       filename: "bundle.js",
       environment: {
           arrowFunction: false // 关闭webpack的箭头函数，可选
       }
   },
   resolve: {
       extensions: [".ts", ".js"]
   },
   // 指定webpack打包时要使用的模块
   module: {
       // 指定的加载规则
       rules: [
           {
               // test 指定规则生效的文件
               test: /\.ts$/,
               // 要用的加载器
               use: {
                   loader: "ts-loader"     
               },
               // 排除的文件
               exclude: /node_modules/
           }
       ]
   },
   plugins: [
       new CleanWebpackPlugin(),
       new HtmlWebpackPlugin({
           title:'这是一个自定义的 title'
       }),
   ]
}
```

#### 配置TS编译选项

根目录下创建 tsconfig.json，配置可以根据自己需要

```json
{
   "compilerOptions": {
       "target": "ES2015",
       "module": "ES2015",
       "strict": true
   }
}
```

#### 修改package.json配置

修改 package.json 添加如下配置

```json
{
   ...
   "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1",
       "build": "webpack",
       "start": "webpack serve --open chrome.exe"
   },
   ...
}
```

#### 项目使用

在src下创建ts文件，并在并命令行执行`npm run build`对代码进行编译；

或者执行`npm start`来启动开发服务器；

### Babel

除了webpack，开发中还经常需要结合babel来对代码进行转换；

以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中；

> 虽然TS在编译时也支持代码转换，但是只支持简单的代码转换；
>
> 对于例如：Promise等ES6特性，TS无法直接转换，这时还要用到babel来做转换； 安装依赖包：

```sh
npm i -D @babel/core @babel/preset-env babel-loader core-js
```

共安装了4个包，分别是：

- @babel/core：babel的核心工具
- @babel/preset-env：babel的预定义环境
- @babel-loader：babel在webpack中的加载器
- core-js：core-js用来使老版本的浏览器支持新版ES语法

修改webpack.config.js配置文件

```js
...
module: {
    rules: [
        {
            test: /\.ts$/,
            use: [
                {
                    loader: "babel-loader",
                    options:{
                        presets: [
                            [
                                "@babel/preset-env",
                                {
                                    "targets":{
                                        "chrome": "58",
                                        "ie": "11"
                                    },
                                    "corejs":"3",
                                    "useBuiltIns": "usage"
                                }
                            ]
                        ]
                    }
                },
                {
                    loader: "ts-loader",
                }
            ],
            exclude: /node_modules/
        }
    ]
}
...
```

如此一来，使用ts编译后的文件将会再次被babel处理；

使得代码可以在大部分浏览器中直接使用；

同时可以在配置选项的targets中指定要兼容的浏览器版本；

#### 报错：[BABEL] .targets is not allowed in preset options

原因：presets中是有两层中括号，少写一层会报这个错误

```
presets: [
  [
    "@babel/preset-env",
    {
      "targets":{
        "chrome": "58",
        "ie": "11"
      },
      "corejs":"3",
      "useBuiltIns": "usage"
    }
  ]
]
```



























