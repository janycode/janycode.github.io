---
title: 01-TS基础入门
date: 2022-5-22 21:36:21
tags:
- Vue
- TypeScript
- ts
categories: 
- 04_大前端
- 05_TypeScript
---

![image-20260107112930310](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260107112931807.png)

参考资料：

* TypeScript 官网：https://www.typescriptlang.org/zh/



## 1. TS 

### 1.1 环境

全局安装 typescript：*npm i typescript -g*

转换 ts 为 js：*tsc hello.ts*

解决 ts 与 js 冲突问题：*tsc --init*   - 生成配置文件 `tsconfig.json`

自动编译：*tsc --watch*

发出错误：*tsc -noEmitOnError hello.ts*  - 在发现错误时不编译为 js 文件

> 使用 tsc 将 ts编译为js，使用 node 运行 js 文件。
>
> 注意：
>
> tsc --watch 时，默认会生成 .d.ts/.d.ts.map/.js.map 文件，可以通过配置关闭
>
> ```json
>     // Other Outputs
>     "sourceMap": false,
>     "declaration": false,
>     "declarationMap": false,
> ```



### 1.2 显式类型

```ts
function test(person:string, date:Date) {
    console.log(`hello ${person}, tody is ${date}`);
}
test("jerry", new Date())
```



### 1.3 降级编译

tsconfig.json 中：`"target": "esnext",` 比如修改为 es5 `"target": "es5",`



### 1.4 严格模式

tsconfig.json 中 `"strict": true,` 配置为严格模式。

```json
    "strict": true,            //严格模式 1.严格 开启
    "noImplicitAny": true,     //严格模式 2.无任何隐式类型 开启
    "strictNullChecks": true,  //严格模式 3.严格的 null 检查 开启
```

默认后两个配置都合并在 strict 配置中。



### 1.5 类型

基本类型：

* `string` - 字符串

* `number` - 数字

* `boolean` - 布尔 true / false

数组类型：

* `type[]` - 数组，如 number[]
* `Array<type>` - 数组，泛型写法，如 Array\<number\>

任意类型：

* any - 任意类型

```ts
// 基本类型
let str: string = "hello typescript"
let num: number = 100
let bool: boolean = true

// 数组类型
let arr: number[] = [1, 2, 3]
let arr2: Array<number> = [1, 2, 3]

// 任意类型
let obj: any = {
    x: 0
}
obj.foo()
obj.bar = "hello"
obj = 123
```



### 1.6 类型推断

```ts
let myname = "hello"
// myname = 100  //自动类型推断，不能再被赋值为 其他类型
```



### 1.7 函数类型 f(): type1 {}

```ts
// 普通函数
function test(name: string): number {
    console.log("hello," + name.toUpperCase() + "!");
    return 10
}
let number = test("jerry")
// 匿名函数 - 自动推断类型
const names = ['aaa', 'bbb', 'ccc']
names.forEach((s) => {
    console.log(s.toUpperCase())
})
```



### 1.8 对象类型 o: {}

```ts
function printCoord(pt: { x: number, y: number }) {
    console.log("坐标 x=", pt.x);
    console.log("坐标 y=", pt.y);
}
printCoord({x: 3,  y: 7})

// ?可选参数
function printName(obj: { first: string, last?: string }) {
    console.log(obj.first, obj.last?.toUpperCase());
}
printName({first: "hello"})
printName({first: "hello", last: "world"})
```



### 1.9 联合类型 type1 | type2

```ts
function printId(id: number | string) {
    if (typeof id === 'string') {
        console.log(id.toUpperCase());
    } else {
        console.log(id);
    }
}
printId(101)
printId("hello")
```

```ts
function welcome(x: string[] | string) {
    if (Array.isArray(x)) {
        console.log('hello, ' + x.join(' adn '));
    } else {
        console.log('hello, welcome ');
    }
}
welcome('A')
welcome(['a', 'b'])
```

```ts
function getFirst(x: number[] | string) {
    return x.slice(0, 3)
}
console.log(getFirst('abcdefg'));  //abc
console.log(getFirst([1, 2, 3, 4, 5])); //[1, 2, 3]
```



### 1.10 类型别名 type

关键字 `type` 来定义类型别名。

```ts
type Point = {
    x: number,
    y: number
}
function printCoord(pt: Point) {}
printCoord({ x: 100, y: 200 })

type ID = number | string
function printId(id: ID) { }
printId(100)
printId('hello')

type UserInputSanitizedString = string
function sanitizedInput(str: string): UserInputSanitizedString {
    return str.slice(0, 2)
}
let userInput = sanitizedInput('hello')
console.log(userInput);
userInput = 'new Input'
console.log(userInput);
```

### 1.12 接口 interface

```ts
interface Point {
    x: number
    y: number
}
function printCoord(pt: Point) { }
printCoord({x: 100, y: 200})
```



### 1.13 type 与 interface 的区别

* interface 可以扩展，比如 `extends` 继承；并且可以向现有类型里添加字段
* type 可以扩展，比如 `&` 符号来继承；一旦定义则不支持往现有类型里编程式增加字段

```ts
// 扩展接口
interface Animal {
    name: string
}
interface Bear extends Animal {
    honey: boolean
}
const bear: Bear = {
    name: 'winne',
    honey: true
}
console.log(bear.name);  // winne
console.log(bear.honey); // true
```

```ts
// 扩展 type
type Animal = {
    name: string
}
type Bear = Animal & {
    honey: boolean
}
const bear: Bear = {
    name: 'winne',
    honey: true
}
console.log(bear.name);  // winne
console.log(bear.honey); // true
```

```ts
// interface 向现有类型添加字段
interface window {
    count: number
}
interface window {
    title: string
}
const w: window = {
    count: 100,
    title: "窗口"
}
```



### 1.14 类型断言

```ts
const myCanvas = document.getElementById('main_canvas') as HTMLCanvasElement
// 等价
const myCanvas2 = <HTMLCanvasElement>document.getElementById('main_canvas')
```























































## x. TypeScript 介绍

1. TypeScript 的定位是静态类型语言，在`写代码的阶段就能检查错误`，而非运行阶段
2. 类型系统是最好的文档，增加了代码的`可读性和可维护性`
3. 有一定的学习成本，需要链接`接口 interfaces`、`泛型 generics`、`类 classes` 等
4. `.ts 最后被编译成 js`



### x.1 变量声明

```ts
// 类型推断
var myname:string = "jerry"   // 定义 myname 只能为字符串类型，其他类型赋值编写就报错
var myname1 = "hello"  //隐式类型推断
myname.substring(0, 1)

var myage:number = 100.34
myage = parseInt(myage.toFixed(2)) 
console.log(myage)

var myvalue:string|number = 100  // | 或，两种类型都可以
myvalue = "300"
```

```ts
// 数组
var mylist:string[] = ['jerry', 'tom', 'spike']
mylist.push('lucy')

var mylist2:number[] = [1, 2, 3]
mylist2.push(100)

var mylist3:(string|number)[] = ['jerry', 18]
mylist3.push(20)
mylist3.push('tom')

var myany:any = "123"     // any类型 就失去了 ts 类型检查的能力了 - 能不用就不用
myany = {}
myany = []
```

```ts
// 第二种风格: 泛型写法
var mylist4:Array<string> = ['aaa', 'bbb']
var mylist5:Array<string|number> = ['ccc', 10]
var mylist6:Array<any> = ['ddd', 11, {}, []]
```

```ts
// 对象
var myobj = {
    name: 'jerry',
    age: 18
}
interface InterObj {        //接口形式定义对象的字段和类型
    name:string,
    age:number,
    location?:string        //?可选属性
    [propName:string]:any   //可以不限制添加额外属性
}
var myobj1:InterObj
myobj1 = {
    name: 'tom',
    age: 20,
    a: {},
    b: []
}
```

### 1.2 函数

```ts
// 函数：限定形参类型、返回值类型
function test(a: number, b: number):number {
  return a + b
}

var mynum:number = test(1, 2)
```



### 1.3 ts+选项式API

参考 vue 官网：https://cn.vuejs.org/guide/typescript/options-api.html

`不推荐`，官方更推荐与 组合式 api使用。

* 注意：接口类型限定
* 注意：类型断言

```vue
<template>
  <div>
    voa app - {{ myname }}
    <button @click="handleChange">click</button>
    <ul>
      <li v-for="(item, index) in list" :key="item">{{ item }}</li>
    </ul>
    <div ref="mydiv">测试</div>
    输入框：<input type="text" ref="myintput">
  </div>
</template>

<script lang="ts">
interface InterState {
  myname: string
  myage: number
  list: Array<string>
}
export default {
  data() {
    return {
      myname: "jerry",
      myage: 18,
      list: [],
    } as InterState // 限定为指定的接口类型
  },
  methods: {
    handleChange() {
      this.myname = "tom"
      this.list.push(this.myname)
      // 类型断言
      console.log((this.$refs.mydiv as HTMLDivElement).innerHTML)
      console.log((this.$refs.myintput as HTMLInputElement).value)
    },
  },
}
</script>
```

父-示例：

```vue
<template>
  <div>
    <Child title="首页" :item="{name:'jerry', age:18, list:[1,2,3]}"></Child>
  </div>
</template>

<script lang="ts">
import Child from "./Child.vue"

export default {
  components: {
    Child,
  }
}
</script>
```

子-示例：

```vue
<template>
  <div>child - {{ title }} - {{ item?.name }} - {{ item?.age }} - {{ item?.list }}</div>
</template>

<script lang="ts">
import type { PropType } from "vue"   //引入类型断言
interface IProps {  //定义接口类型
  name: string
  age: number
  list: Array<number>
}
export default {
  props: {
    title: String,
    item: Object as PropType<IProps>,  //限定为接口类型
  },
}
</script>
```



### 1.4 ts+组合式API

示例：注意 接口类型限定 interface 和 类型断言如 `ref<HTMLDivElement>()`

```vue
<template>
  <div>
    vca - {{ myname }} - {{ computedMyname }}
    <div ref="mydiv">这是个div</div>
  </div>
</template>

<script lang="ts" setup>
import { computed, onMounted, reactive, ref } from "vue"
import type { Ref } from "vue"
// 隐式推导
// const state = reactive({
//     myname: 'jerry'
// })
interface IState {
  myname: string
}
const state: IState = reactive({
  myname: "jerry",
})

// const myname = ref("tom1") //隐式推导
// const myname:Ref<string> = ref('tom2') //Ref<>泛型，需要导入 Ref
const myname = ref<string>("tom3") //ref<>
const mylist = ref<IState[]>([])   // [{myname:'xxx'}, {myname:'yyy'}]

const mydiv = ref<HTMLDivElement>()
onMounted(() => {
  console.log(mydiv.value?.innerHTML)
})

const computedMyname = computed<string>(() => myname.value.substring(0, 1).toUpperCase() + myname.value.substring(1))

</script>
```

父-示例：

```vue
<template>
  <div>
    <Child title="首页" :obj="{name:'jerry', age: 20}"></Child>
  </div>
</template>

<script lang="ts" setup>
import Child from "./Child.vue"
</script>
```

子-示例：`defineProps<{...}>` 与 `defineEmits<{...}>`

```vue
<template>
  <div>child... - {{ title }}-{{ obj.name }}-{{ obj.age }}</div>
</template>

<script lang="ts" setup>
interface IProps {
    name:String,
    age:Number
}
const props = defineProps<{
    title:string,
    obj:IProps   //可选属性，通过接口定义类型
}>()

// 子传父
const emit = defineEmits<{
  (e: 'event', myvalue: string): void
}>()
const handleClick = () => {
  emit("event", "hello")
}
</script>
```



### 1.5 ts+路由

router/index.ts - 文件格式改为 ts （不要与 js 两掺）

```ts
import { createRouter, createWebHistory } from "vue-router";
import Center from "../Center.vue";


const routes = [
    {
        path: '/',
        component: Center
    }
]

const router = createRouter({
    history: createWebHistory(),
    routes,
})

export default router
```

































