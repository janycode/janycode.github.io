---
title: 01-Vue 2.0
date: 2018-5-22 21:36:21
tags:
- Vue
categories: 
- 04_大前端
- 04_Vue
---

![image-20200723170734421](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200723170735.png)

参考资料：

* 官网：https://cn.vuejs.org/
* vue2 官方教程：https://v2.cn.vuejs.org/v2/guide/
* vue3 官方教程：https://cn.vuejs.org/guide/introduction.html
* 说明：*`Vue 2.0 在 2023 年 12 月 31 日停止更新`*。



## 1. 框架

### 1.1 引入

`Vue`是一套用于构建用户界面的**渐进式框架**。

引入：（vue2）

```js
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
```

或者下载vue.js文件（浏览器打开http...js文件，Ctrl +S保存），放在本地路径。

引入：（vue3）

```js
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```

每个 Vue 应用都需要通过`实例化 Vue`来实现。

语法格式如下：

```vue
var vm = new Vue({
  // 选项
})
```



### 1.2 原理

依赖 `Object.defineProperty`  中 get/set 方法的拦截。

> 当把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的 property，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些 property 全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#定义_getters_与_setters)。
>
> `Object.defineProperty` 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
>
> **注意：vue3的变化**
>
> `Object.defineProperty` 有以下缺点：
>
> 1. 无法监听ES6的 Set、Map 变化
> 2. 无法监听Class类型的数据
> 3. 属性的新加或删除也无法监听
> 4. 数组元素的增加和删除也无法监听
>
> `针对这些缺点，ES6 Proxy都能完美解决，唯一缺点就是对IE不友好，所以vue3如果检测到使用IE(包括IE11都不支持)时，会自动降级为 Object.defineProperty 的数据监听系统。`

![img](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20251217182853.png)

示例：

```js
    <div id="box"></div>
    <script>
        var obj = {}
        var box = document.getElementById("box")
        // dom拦截, obj.myname 的获取和赋值 都能够拦截到
        Object.defineProperty(obj, "myname", {
            get() {
                console.log("get");
                return box.innerHTML
            },
            set(val) {
                console.log("set", val);
                box.innerHTML = val
            }
        })
    </script>
```

![image-20251217155425506](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20251217155426.png)



## 2. 响应式渲染

### 2.1 模版语法 {{a}}

**插值**：

* `{{...}}` 双大括号，绑定文本插值，中间也支持三目表达式
* `v-html` 渲染html代码，有**`XSS/CSRF攻击风险`**，尽可能不要给用户提供该能力使用。
  * **防止XSS,CSRF攻击**：①前端过滤  ②后端转义(`<` `>` `&lt;` `&gt;`)  ③给cookie加上属性http
* 表达式

**指令**：

* `v-bind`  / `:`动态绑定属性。简写 `:`，如 **:class** 绑定类名，**:src** 绑定路径，支持三目表达式
* `v-if` 动态创建/删除。
* `v-show` 动态显示/隐藏。（会提前创建出来，并添加样式display:none）
* `v-on`  / `@` 绑定事件。简写 `@` ，如 **@click**="handleClick()"
* `v-for` 遍历
* `v-model` 双向绑定表单 input



#### 案例：待办事项

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./lib/vue.js"></script>
</head>
<body>
    <div id="box">
        <!-- v-model 双向绑定了input框的值 -->
        <input type="text" v-model="mytext">{{mytext}}
        <button @click="handleAdd()">添加</button>
        <ul v-show="dataList.length">
            <li v-for="(item, index) in dataList">
                {{item}}
                <button @click="handleDel(index)">删除</button>
            </li>
        </ul>
        <!-- 数组长度为0时显示 -->
        <div v-show="!dataList.length">待办事项空空如也</div>
    </div>
    <script>
        var vm = new Vue({
            el: "#box",
            data: {
                dataList: ["111", "222", "333", "444"],
                mytext: ""
            },
            methods: {
                handleAdd() {
                    console.log("添加值：", this.mytext)
                    this.dataList.push(this.mytext)
                    this.mytext = ""
                },
                handleDel(index) {
                    console.log("删除索引：", index)
                    this.dataList.splice(index, 1)
                }
            }
        })
    </script>
</body>
</html>
```

效果：

![chrome-capture-2025-12-17](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20251217163722.gif)

### 2.2 style | class

vue2与vue3中这两个属性的动态拦截区别：

* vue3默认就能拦截到属性和值。
* vue2中需要使用 `Vue.set()` 去拦截，或者使用 `数组`的方式去操作。



示例：

```vue
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./lib/vue.js"></script>
    <style>
        .aa {
            background: red;
        }
        .bb {
            background: yellow;
        }
        .cc {
            background: green;
        }
        .dd {
            background: blue;
        }
    </style>
</head>

<body>
    <!-- vue3默认就拦截到到属性，如dd样式的动态生效 -->
    <div id="box">
        <div :class="classObj">动态切换class-1：对象方式</div>
        <button @click="handleClick1()">Vue2的后补方案1-对象</button>
        <div :class="classArr">动态切换class-1：数组方式</div>
        <button @click="handleClick2()">Vue2的后补方案2-数组</button>
        <hr>
        <div :style="styleObj">动态切换style-1：对象方式</div>
        <button @click="handleClick3()">Vue2的后补方案1-对象</button>
        <div :style="styleArr">动态切换style-1：数组方式</div>
        <button @click="handleClick4()">Vue2的后补方案2-数组</button>
    </div>
    <script>
        var vm = new Vue({
            el: "#box",
            data: {
                classObj: {
                    aa: true,
                    bb: true,
                    cc: false
                },
                classArr: ["aa", "bb"],
                styleObj: {
                    backgroundColor: "orange"
                },
                styleArr: [{backgroundColor: "orange"}]
            },
            methods: {
                handleClick1() {
                    //vue2解决方案：Vue.set(对象, 属性, true) - 即动态拦截属性
                    Vue.set(this.classObj, "dd", true)
                },
                handleClick2() {
                    //vue2解决方案：操作数组
                    this.classArr.push("dd")
                },
                handleClick3() {
                    //vue2解决方案：Vue.set(对象, 属性, true)
                    Vue.set(this.styleObj, "fontSize", "32px")
                },
                handleClick4() {
                    //vue2解决方案：操作数组
                    this.styleArr.push({fontSize: "40px"})
                }
            }
        })

    </script>
</body>

</html>
```



vue3 书写方式和默认解决属性拦截问题：

```vue
    <!-- vue3 -->
    <script src="./lib/vue.global.js"></script>
    <div id="box">
        {{10+20}}-{{myname}}
        <input type="text" v-model="mytext">
        <button @click="handleAdd()">添加</button>
        <div>{{mytext}}</div>
    </div>
    <script>
        // vue2 初始化
        // new Vue({
        //     el: "#box"
        // })

        // vue3 初始化
        var obj = {
            data() {                     //②函数式 data() {}
                return {                 //③返回对象{}
                    myname: "jerry",
                    mytext: "aaa"
                }
            },
            methods: {
                handleAdd() {
                    console.log("add", this.mytext)
                }
            }
        }
        Vue.createApp(obj).mount("#box")  //①创建并绑定节点
    </script>
```



#### 案例：点击变色

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./lib/vue.js"></script>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        ul{
            list-style: none;
            display: flex;
        }
        ul li{
            flex: 1;
            text-align: center;
        }
        ul .active{
            background: green;
        }
    </style>
</head>
<body>
    <div id="box">
        <ul>
            <li v-for="(item, index) in dataList" :class="current === index ? 'active' : ''" @click="handleClick(index)">
                {{item}}
            </li>
        </ul>
    </div>

    <script>
        new Vue({
            el: "#box",
            data: {
                dataList: ["首页", "列表", "我的"],
                current: 0
            },
            methods: {
                handleClick(index) {
                    console.log(index)
                    this.current = index
                }
            }
        })
    </script>
</body>
</html>
```

效果：

![chrome-capture-2025-12-17 (1)](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20251217170141.gif)





### 2.3 条件渲染 v-if

`v-if`  后面跟条件表达式

`v-else-if` 后面跟条件表达式

`v-else` 无需条件表达式

`<template>` 包装元素，**标签自己本身默认不会创建在页面上**，vue提供的一个标签

示例：

```vue
    <div id="box">
        <div v-if="isCreated">111111</div>
        <!-- <div v-if="!isCreated">222222</div> -->
        <div v-else>222222</div>

        <ul>
            <li v-for="item in dataList">
                {{item.status}}-
                <span v-if="item.status === 0">未付款</span>
                <span v-else-if="item.status === 1">已付款</span>
                <span v-else-if="item.status === 2">已发货</span>
                <span v-else>已完成</span>
            </li>
        </ul>
    </div>
    <script>
        var vm = new Vue({
            el: "#box",
            data: {
                isCreated: true,
                dataList: [
                    {
                        title: "111",
                        status: 0
                    },
                    {
                        title: "222",
                        status: 1
                    },
                    {
                        title: "333",
                        status: 2
                    }
                ]
            }
        })
    </script>
```

template示例：

```vue
    <div id="box">
        <template v-if="isCreated">
            <div>111111</div>
            <div>222222</div>
            <div>333333</div>
        </template>
    </div>
    <script>
        var vm = new Vue({
            el: "#box",
            data: {
                isCreated: true,
            },
        })
    </script>
```



### 2.4 列表渲染

`v-for`  遍历使用，如 `v-for="(item, index) in dataList"`

* in 与 of 没有区别，key / index  键 或 索引没有区别
* 特殊 `v-for="n in 10"`

`key` 属性，用法`:key="唯一标识"`在v-for遍历时`必须给 key 添加一个唯一id字段值`，vue diff算法可提升性能

* 跟踪每个节点的身份，从而复用和重新排序现有元素，利用vue的**虚拟dom**进行对比和标记和最小补丁更新
* 理想的key值是每项都有的且唯一的id，如`item.id`

`数组更新检测` - 用于页面动态渲染

* 使用以下方法`会`修改原数组，即可以检测变动
  * push() / pop() / shift() / unshift() / splice() / sort() / reverse()
* 使用以下方法`不会`修改原数组，所以需要**重新赋值给原数组**，就可以被检测到
  * filter() / concat() / slice() / map() 
* 不能检测以下变动的数组：
  * vm.items[index] = newValue，检测变动解决方案 - vue2中可用（vue3无需解决）：
    1. **Vue.set(items, index, newValue)**
    2. **splice(index, 1, newValue)**

示例：

```vue
    <div id="box">
        <!-- 遍历数组，in与of没有区别 -->
        <ul>
            <li v-for="(item, index) in dataList">
                {{index}}-{{item}}
            </li>
        </ul>
        <!-- 遍历对象，key与index没有区别 -->
        <ul>
            <li v-for="(item, key) of obj">
                {{key}}-{{item}}
            </li>
        </ul>
        <!-- 快速造假数据-临时自用 -->
        <ul>
            <li v-for="item in 10">{{item}}</li>
        </ul>
    </div>
    <script>
        var vm = new Vue({
            el: "#box",
            data: {
                dataList: ["111", "222", "333"],
                obj: {
                    name: "jerry",
                    age: 20,
                    location: "china"
                }
            }
        })
    </script>
```



#### 案例：显示过滤结果 - 模糊查询 ×2

解决回删不生效方式一：es5 filter

```vue
    <div id="box">
        <input type="text" @input="handleInput()" v-model="inputText">
        <ul>
            <li v-for="item in dataList" :key="item">
                {{item}}
            </li>
        </ul>
    </div>
    <script>
        new Vue({
            el: "#box",
            data: {
                dataList: ["aaa", "bbb", "ccc", "ddd", "eee", "abc"],
                // 配合 es5 filter：为了不破坏原始数据，解决回删时不搜索的问题
                sourceList: ["aaa", "bbb", "ccc", "ddd", "eee", "abc"],
                inputText: ""
            },
            methods: {
                handleInput() {
                    console.log("input", this.inputText)
                    // es5 filter
                    this.dataList = this.sourceList.filter(item => item.includes(this.inputText))
                }
            }
        })
    </script>
```

解决回删不生效方式二：**函数表达式** - 简单好用【`推荐`】

```vue
    <div id="box">
        <input type="text" v-model="inputText">
        <ul>
            <!--  -->
            <li v-for="item in getList()" :key="item">
                {{item}}
            </li>
        </ul>
        <!-- 可以放函数执行，拿到的是函数的返回值 -->
        <!-- {{ getList() }} -->
    </div>
    <script>
        new Vue({
            el: "#box",
            data: {
                dataList: ["aaa", "bbb", "ccc", "ddd", "eee", "abc"],
                inputText: ""
            },
            methods: {
                getList() {
                    // filter 不会改变原数组 dataList，所以 v-for 中拿到的数据临时变化，但不影响原数组，因此能够支持回删继续展示原数组内容
                    return this.dataList.filter(item => item.includes(this.inputText))
                }
            }
        })
    </script>
```

效果：

![chrome-capture-2025-12-17 (2)](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20251217194450.gif)



### 2.5 事件处理



### 2.6 表单控件 | 双向绑定



### 2.7 计算属性





## 3. fetch | axios





## 4. 组件

### 4.1 创建组件



### 4.2 父子组件通信



### 4.3 引用



### 4.4 动态组件



### 4.5 插槽slot



### 4.6 过渡效果



### 4.7 生命周期



## 5. 指令



## 6. 过滤器



## 7. 单文件组件



## 8. 路由



## 9. vuex持久化





## 10. 组件库

### 10.1 elementUI



### 10.2 vant



## 11. 实战

### 11.1 项目



### 11.2 betterScroll



### 11.3 300ms以及手势问题



### 11.4 git



### 11.5 nginx























