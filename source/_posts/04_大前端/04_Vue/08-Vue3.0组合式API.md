---
title: 08-Vue3.0组合式API
date: 2018-5-22 21:36:21
tags:
- Vue
- vue3
categories: 
- 04_大前端
- 04_Vue
---

![image-20200723170734421](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200723170735.png)

参考资料：

* 官网：https://cn.vuejs.org/
* vue2 官方教程：https://v2.cn.vuejs.org/v2/guide/
* vue3 官方教程：https://cn.vuejs.org/guide/introduction.html
* 说明：`Vue 2.0 在 2023 年 12 月 31 日停止更新`。


> 本文全部基于 vue3。
>
> vue3插件：
>
> * VSCode 插件：`Vue（Offical）`   *语法格式检查和着色*
>
> * Chrome 插件：`Vue.js devtools 7.7.7`  *监控组件、路由等数据流*




## 一、vue3组合式API

> 组合式api中已经没有了 this (当前对象实例)，但是可以通过 getCurrentInstance() 方法获取，特殊用法，一般不需要。
>
> *import { getCurrentInstance } from 'vue'*
>
> ```js
> setup() {
>     const _this = getCurrentInstance()
>     // 使用 _this. 就和 vue2 的用法一样了
> }
> ```

起初定义的是 Vue-Function-API, 后经过社区意见收集，更名为 Vue-Composition-API（`VCA`）

### 1\. reactive

**作用**：创建`响应式对象`，非包装对象，可以认为是模板中的状态。

**导入**：*import { reactive } from "vue"*

*   template 可以放兄弟节点
*   reactive 类以useState, 如果参数是字符串，数字，会报警告，value cannot be made reactive, 所以应该设置`对象`，这样可以数据驱动页面。

```vue
<template>
  <div>{{ state.count }}-<button @click="add">add</button></div>
</template>

<script>
import { reactive } from "vue"
export default {
  setup() {
    const state = reactive({
      count: 0,
    })
    const add = () => {
      state.count++
    }
    return {
      state,
      add,
    }
  },
}
</script>
```



![image-20260102163605787](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260102163607397.png)



### 2\. ref

**作用**：创建一个包装式对象，含有一个响应式属性`value`，取值或赋值时使用 `.value` 

**导入**：*import { ref } from "vue"*

* 它和reactive的差别，就是reactive没有包装属性value
* const count = ref(0),可以接收普通数据类型，操作示例 `count.value++`

```vue
<template>
  <div>{{ count }}-{{ myname }}<button @click="add">add</button></div>
</template>

<script>
import { ref } from "vue"
export default {
  setup() {
    const count = ref(0)        // new Proxy({value: 0})
    const myname = ref("jerry") // new Proxy({value: "jerry"})
    const add = () => {
      count.value++
    }
    return {
      count,
      myname,
      add,
    }
  },
}
</script>
```

#### 2.1 ref嵌套在reactive中

ref 嵌套在 reactive 对象中后，就可以整体统一风格使用 state. 进行访问。

```vue
<template>
  <div class="home">
    home - {{ count }}--{{ state.count }}
    <button @click="add">click</button>
  </div>
</template>

<script>
import { ref, reactive } from "vue"
export default {
  name: "Home",
  setup() {
    const count = ref(0)
    const state = reactive({ count })
    const add = () => {
      state.count++        // state.count跟前面count都会更新
    }
    return { count, state, add }
  },
}
</script>
```




#### 2.2 toRef | toRefs

* `toRef()` 可以把 reactive 对象转为 ref 对象，如 toRef(state, 'count')
* `toRefs()` 默认直接展开state，那么此时reactive数据变成普通数据。通过`...toRefs()`可以把reactive的每个属性展开并转化为对象, 这样就变成多个对象，依然具有响应式特性。同时 dom 可以直接访问。

```vue
<template>
  <div class="home">
    <!-- ...toRefs(state)后，dom就可以直接访问 count -->
    home - {{ count }}
    <button @click="add">click</button>
  </div>
</template>

<script>
import { reactive, toRefs } from "vue"
export default {
  name: "Home",
  setup() {
    const state = reactive({ count: 1 })
    const add = () => {
      state.count++
    }
    return {
      ...toRefs(state),  //展开 state 对象，dom中就可以不需要加 state. 就可以直接访问属性
      add,
    }
  },
}
</script>
```

#### 2.3 ref访问dom或者组件

```vue
<input type="text" ref="myinput"/>
//js
const myinput = ref(null)
console.log(myinput.value.value)
```



### 3. computed 计算属性

`computed(() => 逻辑代码)` vue3中的计算属性，逻辑代码中不能加大括号。且只能`同步`。

导入：*import { computed } from "vue"*

```vue
<template>
  <div>app-{{ myname }}-{{ computedName }}</div>
</template>

<script>
import { reactive, toRefs, computed } from "vue"
export default {
  setup() {
    const obj = reactive({
      myname: "jerry",
    })
    const computedName = computed(
      () => obj.myname.substring(0, 1).toUpperCase() + obj.myname.substring(1)
    )
    return {
      ...toRefs(obj),
      computedName,
    }
  },
}
</script>
```

#### 自定义hooks-函数封装复用(★)

search.js

```js
import { computed, ref } from "vue"

// 自定义hooks
function useSearch(list) {
    const mytext = ref("") //ref 访问使用 .value
    const computedList = computed(() =>
        list.value.filter(item => item.includes(mytext.value))
    )
    return {
        mytext,
        computedList
    }
}

export default useSearch
```

App.vue

```vue
<template>
  <div>
    <input type="text" v-model="mytext" />
    <ul>
      <li v-for="item in computedList" :key="item">
        {{ item }}
      </li>
    </ul>
  </div>
</template>

<script>
import { ref } from "vue"
import useSearch from "./search"

export default {
  setup() {
    const datalist = ref([]) //更推荐使用 ref，直接就是响应式属性，dom可以直接用
    // 模拟取数据延时
    setTimeout(() => {
      datalist.value = ["aaa", "abc", "abb", "acc"]
    }, 2000)

    const {mytext, computedList} = useSearch(datalist)
    return { mytext, computedList }
  },
}
</script>

```



### 4. watch 监听

计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM,或是根据`异步操作`的结果去修改另一处的状态。在组合式API中，我们可以使用watch在每次响应式状态发生变化时触发回调函数。

监听器watch是一个方法，它包含参数如下：

* 第一个参数是监听的值，当值发生变化就会触发监听器的回调函数（`推荐监听 ref 创建的响应式数据`）
* 第二个参数是回调函数，可以执行监听时候的回调
* [可选]第三个参数 `{ immediate: true }` 页面访问时会立即执行一次，且当监听的值改变时再次执行

```vue
<template>
  <div>
    <input type="text" v-model="text">
  </div>
</template>

<script>
import { ref, watch } from "vue";
export default {
  setup() {
    const text = ref("")
    //写法1, 如果监听多个使用数组 watch([text1, text2], ...)
    watch(text, (val) => {
      console.log(`1-> text is ${val}`)
    })
    //写法2
    watch(text, (newVal, oldVal) => {
        console.log(`2-> oldVal is ${oldVal}, newVal is ${newVal}`)
      },
      //页面访问时会立即执行一次，且当'text'改变时再次执行
      { immediate: true }
    )
    //写法3: 用于 const text = reactive({ value: '' }) 创建的响应式对象，就可以监听其中包含的具体属性。否则就会监听冗余了。
    watch(() => text.value, (val) => {
        console.log(`3-> text is ${val}`)
      }
    )
    return {
      text
    }
  },
}
</script>
```

结合 async 和 await 使用：

```js
watch(text, async (val) => {
  let res = await axios(`http://xxx/api?search=${val}`)
  console.log(res.data)
})
```

#### 案例：watch+async+await+封装

数据 test.json 使用 json-server 启动模拟db的数据：`json-server --watch .\test.json`

> 全局 json-server: `npm i json-server -g`

```json
{
    "news": [
        {
            "id": 1,
            "author": "jerry",
            "content": "jerry-1111"
        },
        {
            "id": 2,
            "author": "jerry",
            "content": "jerry-2222"
        },
        {
            "id": 3,
            "author": "jerry",
            "content": "jerry-3333"
        },
        {
            "id": 4,
            "author": "tom",
            "content": "tom-1111"
        },
        {
            "id": 5,
            "author": "tom",
            "content": "tom-2222"
        },
        {
            "id": 6,
            "author": "tom",
            "content": "tom-3333"
        },
        {
            "id": 7,
            "author": "spike",
            "content": "spike-1111"
        },
        {
            "id": 8,
            "author": "spike",
            "content": "spike-2222"
        },
        {
            "id": 9,
            "author": "spike",
            "content": "spike-3333"
        }
    ]
}
```

App.vue - 调用方（`currentSelect 因为 v-model 双向绑定，因此选中的值就会被赋值为 option 的 value` ）

```vue
<template>
  <div>
    <select v-model="currentSelect">
      <option v-for="item in optionList" :key="item" :value="item">
        {{ item }}
      </option>
    </select>
    <input type="text" v-model="mytext" />
    <ul>
      <li v-for="item in computedList" :key="item.id">{{ item.content }}</li>
    </ul>
  </div>
</template>

<script>
import { ref } from "vue"
import useList from "./useList"
import useSearch from "./useSearch"
export default {
  setup() {
    const optionList = ref(["jerry", "tom", "spike"])
    const currentSelect = ref("jerry")
    const mytext = ref("")
    const { contentList } = useList(currentSelect)
    const { computedList } = useSearch(mytext, contentList)

    return {
      optionList,
      currentSelect,
      contentList,
      mytext,
      computedList,
    }
  },
}
</script>
```

useList.js - 封装函数方法

```js
import axios from "axios"         // npm i axios
import { ref, watch } from "vue"

function useList(selectVal) {
    const contentList = ref([])
    watch(selectVal,
        async val => {   // async+await 使异步模拟同步，必定能拿到数据进行赋值
            let res = await axios.get(`http://localhost:3000/news?author=${val}`)
            console.log("res.data->", res.data)
            contentList.value = res.data
        },
        {
            immediate: true,
        }
    )
    return { contentList }
}

export default useList
```

useSearch.js - 封装函数方法

```js
import { computed } from "vue"

// 自定义hooks: 注意ref的访问是.value，以及遍历中的 item 对应是字段值匹配
function useSearch(text, list) {
    const computedList = computed(() => list.value.filter(item => item.content.includes(text.value)))
    return {
        computedList
    }
}

export default useSearch
```

效果：

![chrome-capture-2026-01-02](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260102192908626.gif)



### 5. watchEffect() 函数

#### (1) watch

*   具有一定的惰性lazy第一次页面展示的时候不会执行，只有数据变化的时候才会执行 或 设置 {immediate: true} 第一次才会执行
*   参数可以拿到当前值和原始值
*   可以侦听多个数据的变化，用一个侦听器承载

```js
const todoId = ref(1) 
const data = ref(null)

watch(todoId, async () => {
    const response = await fetch(
        'https://jsonplaceholder.typicode.com/todos/${todoId.value}\ )
    data.value = await response.json()
}, { immediate: true })
```

#### (2) watchEffect

*   `立即执行`，没有惰性，页面的`首次加载就会执行`。
*   自动检测内部代码，代码中有依赖便会执行
*   不需要传递要侦听的内容会`自动感知代码依赖`，不需要传递很多参数，只要传递一个`回调函数`
*   不能获取之前数据的值**只能获取当前值**
*   一些异步的操作放在这里会更加合适

```js
watchEffect(async () => {
    const response = await fetch(
        'https://jsonplaceholder.typicode.com/todos/${todoId.value}\
    )
    data.value = await response.json()
})
```

写法对比：

```js
import axios from "axios"
import { ref, watchEffect } from "vue"

function useList(selectVal) {
    const contentList = ref([])
    // watch(selectVal, async val => {   // async+await 使异步模拟同步，必定能拿到数据进行赋值
    //         let res = await axios.get(`http://localhost:3000/news?author=${val}`)
    //         console.log("res.data->", res.data)
    //         contentList.value = res.data
    //     },{immediate: true,})
    watchEffect(async () => {
        let res = await axios.get(`http://localhost:3000/news?author=${selectVal.value}`)
        console.log("res.data->", res.data)
        contentList.value = res.data
    })
    return { contentList }
}

export default useList
```



### 6. props & emit

```js
export default {
  setup(props, context) {
    console.log(context.attrs)   // 透传 Attributes (非响应式的对象，等价于 $attrs)
    console.log(context.slots)   // 插槽(非响应式的对象，等价于 $slots)
    console.log(context.emit)    // 触发事件(函数，等价于 $emit)
    console.log(context.expose)  // 暴露公共属性(函数)
  }
}
```

如解构 props 和 emit：

```js
props: ["mytitle"],
setup({mytitle}, {emit}) {
    console.log(mytitle)    //mytitle可以用于计算属性等
    emit("myevent")         //emit触发父组件事件myevent
}
```



### 7. provide & inject

`组件之间跨级通信，而且是响应式的。`

在父组件中： 

* 首先导入 provide 函数：*import { provide, ref } from 'vue';*

* 在 setup 函数中使用 provide 提供一个值。例如，提供一个名为 message 的字符串：

```js
import { provide, ref } from 'vue';
export default {
  setup() {
    const message = ref('This is a provided message');
    provide('message-key', message);
    return {
      message  //如果有需要，可以将message暴露给模板或者其他地方使用
    };
  }
};
```

> 这里的 'message-key' 是一个自定义的键，用于在子孙组件中识别要注入的值。

**在子孙组件中：**

*   导入 inject 函数：*import { inject } from 'vue';*


* 在 setup 函数中使用 inject 注入父组件提供的值：

```vue
<template>
  <div> {{ injectedMessage }} </div>
</template>

<script setup>
import { inject } from 'vue';
const injectedMessage = inject('message-key');
</script>
```



### 8. 生命周期

生命周期图示vue3：

每个Vue组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM,以及在数据改变时更新DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。

1.  `beforeCreate()` 会在实例初始化完成、props解析之后、data()和computed等选项处理之前立即调用。
2.  `created()` 当这个钩子被调用时，以下内容已经设置完成：响应式数据、计算属性、方法和侦听器。然而，此时挂载阶段还未开始，因此$el属性仍不可用。
    - 场景：*初始化*

3.  `beforeMount()` 当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建DOM节点。它即将 首次执行DOM渲染过程。
4.  `mounted()` 所有同步子组件都已经被挂载。这个钩子通常用于执行需要**访问组件所渲染的DOM树**相关的作用。—— `最常用`
    - 场景：*订阅发布、ajax、setInterval、访问dom*

5.  `beforeUpdate()` 这个钩子可以用来在Vue更新DOM之前访问DOM状态。在这个钩子中更改状态也是安全的。
6.  `updated()` 这个钩子会在组件的任意DOM更新后被调用，这些更新可能是由不同的状态变更导致的。如果你需要在某个特定的状态更改后访问更新后的DOM，请使用 `nextTick()` 作为替代。
    - 场景：*echarts的resize()操作等*

7.  `beforeUnmount()` 当这个钩子被调用时，组件实例依然还保有全部的功能。
8.  `unmounted()` 在一个组件实例被卸载之后调用。
    - 场景：*解绑事件如窗口大小变动监听window.onresize=null*

![img](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20251219180625.png)


| vue2              | vue3                      |
| ----------------- | ------------------------- |
| **beforeCreate**  | `setup(()=>{})`           |
| **created**       | `setup(()=>{})`           |
| beforeMount       | onBeforeMount(()=>{})     |
| mounted           | onMounted(()=>{})         |
| beforeUpdate      | onBeforeUpdate(()=>{})    |
| updated           | onUpdated(()=>{})         |
| **beforeDestroy** | `onBeforeUnmount(()=>{})` |
| **destroyed**     | `onUnmounted(()=>{})`     |

总结： 

* Vue2和Vue3钩子变化不大，beforeCreate 、created 两个钩子被 setup() 钩子来替代。
* 生命周期钩子函数一般都写在 setup() {...} 中。

```js
import { onUnmounted, onMounted } from 'vue'
setup() {
    ...
	onMounted(() => {
		console.log('onMo unted')
	})
    ...
}
```



### 9. setup 语法糖(★)

`<script setup> ... </script>`

* 更少的样板内容，更简洁的代码
* 能够使用纯 TypeScript 声明 props 和 自定义事件
* 更好的运行时性能（其模版会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象）
* 更好的 IDE 类型推导性能（减少了语言服务器从代码中抽取类型的工作）

#### 9.1 顶层绑定

声明的顶层的绑定（包括变量、函数、以及 import 导入的内容）都能在模版中直接使用（`无需 return`）：

```vue
<template>
    <div>
        app-{{ msg }}-{{ myname }}-{{ myage }}
        <button @click="handleClick">click</button>
    </div>
</template>

<script setup>
import { reactive, ref, toRefs } from 'vue';

const msg = ref("hello,message")
const state = reactive({
    myname: 'jerry',
    myage: 18
})
const {myname, myage} = {...toRefs(state)}
const handleClick = () => {
    msg.value = "hello,world"
    myage.value = 22
}
// 不需要return返回了，直接使用响应式变量和方法
</script>
```



#### 9.2 响应式

响应式状态需要明确使用响应式 api 来创建，和 setup() 函数的返回值一样，ref 再模版中使用的时候会自动解包。

```vue
<template>
    <div>
        <button @click="count++">{{ count }}</button>
    </div>
</template>

<script setup>
import { ref } from 'vue';
const count = ref(0)
</script>
```



#### 9.3 使用组件

```vue
<template>
    <MyComponent />
</template>

<script setup>
import MyComponent from './MyComponent.vue'
</script>
```



#### 9.4 动态组件

```vue
<template>
    <component :is="Foo" />
    <component :is="someCondition ? Foo : Bar" />
</template>

<script setup>
import Foo from './Foo.vue'
import Bar from './Bar.vue'
</script>
```



#### 9.5 指令

必须遵守 `vNameDirective` 这样的小写开头驼峰命名规范，驼峰`大写` 使用时转为 `-小写`。

```vue
<template>
    <h1 v-my-directive>This is a Head.</h1>
</template>

<script setup>
const vMyDirective = {                          //局部指令
    beforeMount: (el) => {
        el.style.backgroundColor = 'yellow'     //在元素上做的操作
    }
}
</script>
```



#### 9.6 通信 defineProps | defineEmits

> 推荐`<script setup>` 中使用。

`props`在子组件中：

* 导入 ` defineProps` 函数：*import { defineProps } from 'vue';*

* 使用 defineProps 来定义接收的 props：

```js
const props = defineProps({
  message: String
});
```

* 在子组件的模板中可以使用这个 props：

```vue
<template>
  <div>{{ props.message }}</div>
</template>
<!-- <div>{{ props.message }}</div>    直接写成    <div>{{ message }}</div>    也可以正常显示  -->
```

`emit`在子组件中：

* 导入 `defineEmits` 函数：*import { defineEmits } from 'vue';*

*   使用 defineEmits 定义要发出的事件：


```js
const emits = defineEmits(['custom-event']);
```

*   当满足某个条件时，触发事件并传递参数：


```js
const someFunction = () => {
  const dataToSend = 'Some data from child';
  emits('custom-event', dataToSend);
};
```

**在父组件中：**

在使用子组件时监听子组件发出的事件：

```vue
<template>
  <ChildComponent @custom-event="handleChildEvent" />
</template>
<script setup>
    import { ref } from 'vue';
    import ChildComponent from './ChildComponent.vue';
    const handleChildEvent = (data) => {
      console.log('child传过来的数据:', data);
    };
</script>
```



### 10. 路由

> **背景**：Vue等单页面应用的优缺点
>
> **优点**
>
> 1.  单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。
> 2.  单页应用没有页面之间的切换，就不会出现“白屏现象”，也不会出现假死并有“闪烁”现象
> 3.  单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。
> 4.  良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。
>
> **缺点**
>
> 1.  首次加载耗时比较多。
> 2.  SEO问题，不利于百度，360等搜索引擎收录。
> 3.  容易造成CSS命名冲突。
> 4.  前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。

#### 10.1 vue-router

1. 安装：*npm i vue-router@4*
   - 注意1：写 style 记得安装 sass：*npm i sass*   使用 `<style lang="scss" scoped>`
   - 注意2：style.css 全局样式记得注释或删除（临时）

2. 创建 router/index.js

```js
import { createRouter, createWebHashHistory, createWebHistory } from 'vue-router'
import Films from '../views/Films.vue'
import Cinemas from '../views/Cinemas.vue'
import Center from '../views/Center.vue'

const routes = [
    { path: '/films', component: Films },
    { path: '/cinemas', component: Cinemas },
    { path: '/center', alias: '/wode', component: Center },   // alias 别名，也可访问
]

const router = createRouter({
    // history: createWebHistory(),     // 路由模式:history 模式，url 路径不带 #
    history: createWebHashHistory(),    // 路由模式:hash 模式，url 路径带 #
    routes,                             // routes: routes, 的缩写
})

export default router
```

3. 项目入口 main.js 中导入并使用 router

```js
import { createApp } from 'vue'
import './style.css'
// import App from './App.vue'
import App from './vueRouter/App.vue'
import router from './vueRouter/router'  //导入路由插件

createApp(App)
.use(router)                             //使用路由插件
.mount('#app')
```

4. App.vue 中使用全局路由容器组件

```vue
<template>
  <div>
    app
    <!-- 全局路由容器组件 -->
    <router-view></router-view>
  </div>
</template>
```

#### 10.2 redirect 重定向

router/index.js

```js
const routes = [
    { ... },
    { path: '/',  redirect: '/films' },                  // 通过 path 路径重定向
    //{ path: '/',  redirect: { name: 'films' } },       // 通过 name 属性重定向
]
```



#### 10.3 404 NotFound

router/index.js

```js
const routes = [
    { ... },
    { path: '/:pathMath(.*)*',  component: NotFound }, // 前面都未匹配上时，即路径最终不匹配则加载404组件
]
```



#### 10.4 router-view 路由容器标签

```vue
<template>
  <div>
    <!-- 全局路由容器组件 -->
    <router-view></router-view>
  </div>
</template>
```



#### 10.5 router-link 声明式导航

`声明式导航` ：和 a 标签一样的效果，但 `router-link` 可以自动匹配路由模式，不会渲染为 a 标签，且更便于设置高亮显示。

声明式导航使用方式（v-solt 插槽方式自动处理点击高亮）：

```vue
<router-link custom to="/films" v-slot="{isActive, navigate}">
    <li :class="isActive ? 'jerry-active' : ''" @click="navigate">电影</li>
</router-link>
```

如 Tabbar.vue

```vue
<template>
  <div class="tabbar">
    <ul>
      <router-link custom to="/films" v-slot="{isActive, navigate}">
        <li :class="isActive ? 'jerry-active' : ''" @click="navigate">电影</li>
      </router-link>
      <router-link custom to="/cinemas" v-slot="{isActive, navigate}">
        <li :class="isActive ? 'jerry-active' : ''" @click="navigate">影院</li>
      </router-link>
      <router-link custom to="/center" v-slot="{isActive, navigate}">
        <li :class="isActive ? 'jerry-active' : ''" @click="navigate">我的</li>
      </router-link>
    </ul>
  </div>
</template>

<style lang="scss" scoped>
.tabbar {
  position: fixed;
  bottom: 0;
  width: 100%;
  height: 50px;
  line-height: 50px;
  text-align: center;
  ul {
    display: flex;
    li {
      flex: 1;
    }
  }
}
.jerry-active{
  color: red;
}
</style>

```



#### 10.6 嵌套路由

路由中通过 `children` 属性进行配置，需要通过 `router-view` 路由容器标签在 dom 中使用。

```js
const routes = [
    {
        path: '/films',
        component: Films,
        name: 'films',
        children: [
            {
                path: '/films/nowplaying',  //必须加父路径
                component: Nowplaying
            },
            {
                path: '/films/comingsoon',
                component: Comingsoon
            },
            {
                path: '/films',
                redirect: '/films/nowplaying'  //组件内部重定向，默认进入此路径
            }
        ]
    },
    ...
]
```

dom使用：

```vue
<template>
  <div>
    films
    <!-- 对应路由: /films/nowplaying 或 /films/comingsoon -->
    <router-view></router-view>
  </div>
</template>

```

示例：

```vue
<template>
  <div>
    <ul>
      <router-link custom to="/films/nowplaying" v-slot="{ isActive, navigate }">
        <li @click="navigate">
            <!-- 高亮样式拆解到 span 上，更具灵活性 -->
            <span :class="isActive ? 'jerry-active' : ''">正在热映</span>
        </li>
      </router-link>
      <router-link custom to="/films/comingsoon" v-slot="{ isActive, navigate }">
        <li @click="navigate">
            <span :class="isActive ? 'jerry-active' : ''">即将上映</span>
        </li>
      </router-link>
    </ul>

    <!-- 对应路由配置: /films/nowplaying 或 /films/comingsoon -->
    <router-view></router-view>
  </div>
</template>


<style lang="scss" scoped>
ul {
    display: flex;
    height: 50px;
    line-height: 50px;
    text-align: 50px;
    li{
        flex: 1;
        text-align: center;
    }
}
.jerry-active{
    color: red;
    border-bottom: 2px solid red;
    padding-bottom: 10px;
}
</style>
```

效果：

![chrome-capture-2026-01-05](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20260105124632161.gif)

#### 10.7 router.push() 编程式导航

| 声明式(:to 动态跳转)      | 编程式             |
| ------------------------- | ------------------ |
| `<router-link :to="...">` | `router.push(...)` |

```js
router.push('/path')  //字符串路径
router.push({ path: '/path' })  //带有路径的对象
router.push({ name: 'name', params: { key: 'value' } })  //命名的路由，并加上参数，让路由建立url
router.push({ path: '/path', query: { key: 'value' } })  //待查询参数，结果是 /path?key=value
```



#### 10.8 动态路由匹配(★)

同一个路由中设置多个路径参数，它们会映射到 `$router.params` 相应的字段。如：

| 匹配模式                       | 匹配路径               | $router.params                       |
| ------------------------------ | ---------------------- | ------------------------------------ |
| /users/:username               | /users/jerry           | `{username: 'jerry'}`                |
| /users/:username/posts/:postId | /users/jerry/posts/123 | `{username: 'jerry', postId: '123'}` |

router/index.js

```js
const routes = [
    {
        name: 'Detail'          //用于跳转带参数时的【对象方式】
        path: '/detail/:myid',  //动态匹配 myid 字段: /detail/123456，接参时使用 myid
        component: Detail
    },
    ...
]
```

跳转带参-选项式写法：

```js
this.$router.push(`/detail/${id}`)  //路径方式
this.$router.push({ name:'Detail', params: { myid: id }})   //对象方式&params
this.$router.push({ path:'/detail', query: { myid: id }})   //对象方式&query - (匹配路由格式 path:'/detail' )
```

页面接参-选项式写法：

```js
this.$route.params.myid  //接参数对应：路径方式 or 对象方式&params
this.$route.query.myid   //接参数对应：对象方式&query
```

前进返回-选项式写法：

```js
this.$router.back()     //返回上一页：等价于 this.$router.go(-1)
this.$router.forward()  //前进下一页：等价于 this.$router.go(1)   -- 条件：有历史记录时
```

> **特殊情况**：
>
> 比如 详情页的猜你喜欢，是 `详情页跳转详情页` 时，因为 mounted 只会触发一次，会导致新的 详情id 无法拿到。
>
> 原因：组件没有销毁，即没有重新加载，所以不会重新出发 mounted
>
> 解决方案：
>
> ```vue
> <template>
>   <div>电影详情页（ID：{{ currentId }}）</div>
> </template>
> 
> <script setup>
> import { ref, watch } from 'vue'
> import { useRoute } from 'vue-router' // 导入路由工具
> 
> const route = useRoute()  // 1. 获取路由实例（响应式）
> const currentId = ref(route.params.id)  // 2. 存储当前详情ID
> 
> // 3. 监听路由中id的变化
> watch( () => route.params.id,  // 监听目标：路由参数里的id（用函数返回响应式值）
>   (newId, oldId) => {          // 变化后的回调（新id、旧id）
>     if (newId) {
>       currentId.value = newId
>       fetchMovieData(newId)    // 核心逻辑：id变化后重新请求详情数据（示例用console模拟）
>     }
>   },
>   { immediate: true }          // 可选：初始化时立即执行一次（避免首次进入不触发）
> )
> // 模拟：根据id请求详情数据的函数
> const fetchMovieData = (id) => {      
>   console.log('axios请求电影详情，ID：', id)
> }
> </script>
> ```
>
> 



#### 10.9 路由模式 hash | history

```js
const router = createRouter({
    // history: createWebHistory(),     // 路由模式:history 模式，url 路径不带 #
    history: createWebHashHistory(),    // 路由模式:hash 模式，url 路径带 #
    routes,
})
```

> 使用 history 模式理由有二：
>
> 1. 路径好看，专业
> 2. 分享url时，路径不会被截断。
>
> **风险问题**（官方说明）：
>
> 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 `http://oursite.com/user/id` 就会返回 404，这就不好看了。
>
> 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 `index.html` 页面，这个页面就是你 app 依赖的页面。
>
> 【总结】如果后端没有配置默认返回index.html，就可能会出现404的情况。
>
> 【解决】`nginx` 配置加这一句：
>
> ```nginx
> location / {
>   try_files $uri $uri/ /index.html;
> }
> ```



#### 10.10 路由拦截/守卫

**全局拦截**（全局守卫）

* `router.beforeEach()` 前置钩子，多用于登陆认证
* `router.afterEach()`  后置钩子，多用于用户行为数据上传用于分析

```js
const router = createRouter({...})
//全局拦截：next() 放行继续执行
router.beforeEach( async (to, from, next) => {
    let isAuthenticated = await localStorage.getItem("token")
    //console.log(to.fullPath)  // to.fullPath 可以用于放行路径的白名单-即未登录可访问路径（不推荐）
    //如果路由 name不是Login 并且 未登陆认证 并且 需要认证
    if (to.name !== 'Login' && !isAuthenticated && to.meta.isLoginRequired /* && to.fullPath不在白名单内 */) {
        next({ name: 'Login' })
    } else {
        next()
    }
})
```

meta 标签：

```js
const routes = [
  ...
  {
    path: '/center',
    component: Center,
    meta: {
      isLoginRequired: true // 自定义字段，自行命名，标记拦截使用
    }
  },
  ...
]
```



**局部拦截**（[组件内守卫](https://router.vuejs.org/zh/guide/advanced/composition-api.html#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB)）

```vue
<script setup>
import { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'
import { ref } from 'vue'

// 与 beforeRouteLeave 相同，无法访问 `this`
onBeforeRouteLeave((to, from) => {
  const answer = window.confirm("你确定要离开页面吗？确定-离开, 取消-停留当前页面")
  if (!answer) return false    // 取消导航并停留在同一页面上
})

const userData = ref()

// 与 beforeRouteUpdate 相同，无法访问 `this`
onBeforeRouteUpdate(async (to, from) => {
  //仅当 id 更改时才获取用户，例如仅 query 或 hash 值已更改
  if (to.params.id !== from.params.id) {
    userData.value = await fetchUser(to.params.id)
  }
})
</script>
```

组合式api中没有 `beforeRouteEnter(to, from) {...}` 因此可以结合起来，如果真的需要，可以写两个 script（一个普通的选项式的，一个组合式）。



#### 10.11 路由懒加载

当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。——`属于一种项目变大时的优化方案`

router/index.js

```js
// 将
// import UserDetails from './views/UserDetails.vue'
// 替换成(方式1)
const UserDetails = () => import('./views/UserDetails.vue')

const routes = [
    // 方式1：使用
    { path: '/users/:id', component: UserDetails }
    // 方式2：在路由定义里直接使用它
    { path: '/users/:id', component: () => import('./views/UserDetails.vue') },
]
```



#### 10.12 路由-组合式api写法(★)

路由组合式api：https://router.vuejs.org/zh/guide/advanced/composition-api.html

路由跳转：

```vue
<script setup>
import { useRouter, useRoute } from 'vue-router'

const router = useRouter()
const route = useRoute()
const pushWithQuery = (query) => {
  router.push({
    name: 'search',
    query: {
      ...route.query,
      ...query,
    },
  })
}
</script>
```

监听参数更改：

```vue
<script setup>
import { useRoute } from 'vue-router'
import { ref, watch } from 'vue'

const route = useRoute()
const userData = ref()
// 当参数更改时获取用户信息
watch(
  () => route.params.id,
  async newId => {
    userData.value = await fetchUser(newId)
  }
)
</script>
```























