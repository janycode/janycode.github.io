---
title: 14-面试题杂项整理
date: 2017-5-3 00:09:33
tags:
- 面试题
categories: 
- 20_收藏整理
- 01_面试题
---



## 理论相关

### MySQL数据库引擎及其区别

MYISAM & InnorDB，事务、外键、锁级别、并发性能、占用空间

### MySQL数据库索引种类、索引原则

主键、唯一、普通、全文

### 数据库三大范式

3条：行不可再分、主键约束、外键约束

### SQL语句优化

不*、不子查询、不IN/NOT IN、不OR、不!=、不null判断、DISTINCT与ORDER BY结合

### 常见的垃圾回收算法

标记-整理/标记-清除/复制算法/分代算法

---

### JVM内存模型

PC/堆/栈/元空间，1.8-元数据区方法区变为本地内存元空间

### OOP四大特性五大原则

封装继承多态抽象，单一职能/开放关闭/里式替换/接口隔离/依赖倒置

### 并发事务带来的问题

脏读、丢失修改、不可重复读、幻读

### 大表如何优化？

限定查询数据范围、读写分离、垂直分区

### 数据库并发策略

乐观锁、悲观锁、时间戳

### 过滤器和拦截器的区别

①拦截器是基于java的反射机制的，而过滤器是基于函数回调。
②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。
⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。

⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。

⑦过滤器和拦截器触发时机不一样:过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。

⑧拦截器是spring容器的，是spring支持的。

![image-20200722090735621](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200722090737.png)

---



### 乐观锁、悲观锁的理解

乐观每次拿数据判断再上锁-CAS-高吞吐量，悲观每次拿数据直接上锁

### 三种线程创建方式和四种线程池创建方式

Thread/Runnable/Callable、固定数量/动态缓存/周期/单线程

### 如何安全的终止线程方式

共享变量/中断异常

### volatile

可见性/有序性/单次读写原子性、用于状态标记量如终止线程和单例模式双检锁

### 死锁条件与如何避免

资源分配不当/线程推进顺序不当，避免：打破 互斥/不可抢占/占有且申请/循环等待

### 线程同步的方法-阻塞与线程间同步的方式-锁、线程状态-JDK5-6/JDK8-5

---

### synchronized & ReentrantLock

synchronized-悲观/可重入 & ReentrantLock-可重入锁 区别-层面、灵活性、高级方法、场景

### 不同锁的原理

乐观锁&悲观锁-判断、可重入锁递归锁-外内层、公平锁&非公平锁-排队、读写锁、共享锁&独占锁-单与多、分段锁-思想

### 阻塞队列xxxBlockingQueue

实现原理-空读取等待/满插入等待

### 死锁、活锁、饥饿

死：互相等待释放资源、活：无阻塞重复尝试、饥饿：无发获取资源而无法执行

### Java线程调度算法

时间片轮转，可设优先级

### 不可变对象类和特点

String、基本类型包装类、BigInteger&BigDecimal - 天生线程安全

---

### 分库分表后id主键如何处理？

UUID-效率低、自增不同步长id-成本高、redis生成-可用性低、美团Leaf分布式id生成系统-全局唯一高可用高性能

### AUTO_INCREMENT

达最大值情况止增,报错、最后一次插入的自动增量-LAST_INSERT_ID主键回填

### TIMESTAMP列情况更改,时间戳

Unix和MySQL时间戳转换UNIX_TIMESTAMP/FROM_UNIXTIME

### 索引的增删改查

INDEX 对表操作，CREATE/DELETE/UPDATE/SELECT、ALTER

### 数据库货币类型

NUMERICM,D 等价于 DECIMALM,D ： M代表总位数，D代表小数点后的位数

### Spring/SpringMVC/SpringBoot区别、各自常用注解

Spring-开源容器框架，配置bean，维护bean之间关系，核心为 IOC 和 AOP
SpringMVC-Web层MVC框架，替代 Servlet，相当于 Struts2 + Spring
SpringBoot-快速开发框架，延续核心 IOC/AOP，简化开发、配置、部署
SpringBoot > Spring > SpringMVC

---

### 锁的优化策略？

读写分离、分段加锁、减少锁持有时间、多线程同顺序加锁-效率优化

### 数据库日增5万条，预计运维3年，如何优化？

库结构避免冗余、适当的索引、主从读写分离、规律分表、缓存机制、静态页面、高效的SQL语句

### 索引的底层原理和优化？

原理：在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。

优化：结构优化、查询优化

### 如何正确使用索引？

explain、表扫描类型：all、index、range、ref、eq_ref、const、system

### MySQL在实践中的优化？

按顺序：sql语句和索引、表结构、系统配置、硬件
优化：减少字段宽度、not null、enum、join代替子查询、事务、锁定表、外键、索引、sql语句写法

### 数据库存储过程？如何调用？

预编译SQL语句，允许模块化的设计，创建一次可调多次；类似函数写法。create procedure xx/ call xx

---

### RESP协议

redis的服务器与客户端之间的通信协议，Redis 序列化协议的简写，它是⼀种直观的文本协议。
实现简单、解析快、人类可读的特点，底层是TCP连接方式，通过tcp进行数据传输，根据解析规则解析相应信息，完成交互。

### Redis淘汰策略

内存已经满的时候，添加1个新数据，会执行淘汰机制：

* no-enviction: 禁止驱逐数据，内存不足，读取正常，写入报错，保证数据不丢失 --> 默认策略
* volatile-lru: 已设置过期时间 + 最近最少使用 --> 淘汰
* volatile-ttl: 已设置过期时间 + 将要过期 --> 淘汰
* volatile-random: 已设置过期时间 + 任意随机 --> 淘汰
* volatile-lfu: 已设置过期时间 + 使用频率最低 --> 淘汰
* allkeys-lru: 最近最少使用 --> 淘汰
* allkeys-lfu: 使用频率最低 --> 淘汰
* allkeys-lru: 任意随机 --> 淘汰

### Redis为什么快

①内存数据库，纯内存操作；②单线程，避免频繁的上下文切换；③多路IO复用(NIO)-并发请求

### Redis持久化

RDB-快照写入磁盘dump.rdb文件 & AOF-追加到appendonly.aof文件

### Redis穿透/击穿/雪崩/倾斜

穿透：查不到，缓存层+持久层压力增大 - 解决：布隆过滤器、缓存空对象

击穿：并发下，key大量过期导致直接访问持久层 - 解决：热点数据永不过期、分布式锁

雪崩：并发下，key大量过期导致缓存层+持久层宕机 - 解决：集群、限流降级、数据预热

倾斜：某个缓存服务器压力过大而宕机 - 解决：集群

### Redis的删除策略

定期删除：默认100ms查看3个过期的key，定期删除

惰性删除：查询时，redis检查是否过期，过期则删除key，返回空值

> * 采用定期删除+惰性删除就没其他问题了么?
>
> 不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的`内存会越来越高`。那么就应该采用`内存淘汰机制`。在redis.conf中有一行配置
>
> ```sh
> maxmemory-policy volatile-lru
> ```

### Redis为什么采用跳表SkipList而不是红黑树？

SkipList：链表中加上多级索引的结构，就叫做跳表，查询效率会进一步提升。

原因：代码简单！在已查找到的起点开始顺序遍历的性能略微高于红黑树。

### Redis scan代替keys的原因？

由于 keys 命令会影响 redis 性能，所以将 keys 命令改为 scan。

scan命令用于迭代当前数据库中的数据库键，最重要的是 scan 不会阻塞服务器。

### SDS和C字符串的比较？

① sds 简单动态字符串，是一个C语言结构体，包含三个属性 int len, int free, char buf[];

② 获取字符串长度操作的复杂度从O(n)降到O(1)

③ 采用空间预分配策略杜绝缓冲区溢出（字符串增长操作），同时可以减少连续执行字符串增长操作所需的内存重分配次数

④ 采用惰性空间释放策略杜绝内存泄漏（字符串删除操作），同时可以减少删除后又对同一字符串增加所需的内存重分配次数

⑤ 二进制安全，确保 Redis 可以适用于各种不同的使用场景。C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据

⑥ 兼容部分 C 字符串函数

### Redis其他数据类型：BitMap、Geo、HyperLogLogs

BitMap：通过一个 bit 位来表示某个元素对应的值或者状态

Geo：将用户给定的地理位置信息储存起来， 并对这些信息进行操作

HyperLogLogs：Redis 的基数统计，这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV）、在线用户数等。

### Redis数据类型和应用场景

String：value可以是String也可以是数字，可用于复杂的计数功能的缓存；

Hash：可用于单点登录，设置过期时间，模拟出session的效果；

List：可用于做简单的消息队列、lrange做基于redis的分页功能时性能极佳、生产者消费者场景实现FIFO；

Set：可用于全局去重，以及利用交集、并集、差集操作计算共同喜好、全部喜好、独特喜好等；

Sorted Set：权重参数 score 可以用于排行榜应用，取top n操作。

总结：redis 的使用场景：会话缓存、全页缓存、队列、排行榜/计数器、发布/订阅

### Redis的同步机制？

Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### MySQL里有2000w条数据，redis只存20w条数据，如何保证redis都是热点数据？

① redis sortSet 即 zset 数据类型（自动排序）存放对应的数据，数据被查询或写入过则 zadd 一次，已存在则覆盖时间戳(时间戳做score)；

② 计算20W数据大概占用的内存，限定 redis 的占用内存，配置淘汰策略。

---

### 线程的状态及状态之间的转换

NEW --> start --> READY --> 系统调度 --> RUNNING --> 执行完成 --> TERMINATED
 线程同步wait/join --> WAITING 、锁阻塞synchronized --> BLOCKED

### 有哪些树结构？B+树的特点

二叉树、满二叉树、完全二叉树、二叉搜索树、平衡二叉树、平衡二叉搜索树、红黑树、B树、B+树、哈夫曼树

B+树特点：关键字数和子树相同、非叶子节点仅用作索引、叶子节点用指针连在一起

### BTree和B+Tree

BTree是平衡搜索多叉树，可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。

B+Tree是BTree的一个变种，B+Tree磁盘读写代价更低，数据库存储引擎对B+Tree进行了优化，添加了相邻叶节点的指针，查询速度更加稳定高效。

### HTTP的工作流程

客户端浏览器请求 →  TCP 连接 → 服务器收到请求 → 服务器响应请求报文（文档）→ 客户端浏览器解析响应

### HTTPS的工作流程

Client发起一个HTTPS（https:/demo.linianhui.dev）的`请求`，根据RFC2818的规定，Client知道需要连接Server的`443`（默认）端口。

Server把事先配置好的`公钥证书`（public key certificate）返回给客户端。

Client`验证公钥证书`：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。

Client使用伪随机数生成器生成加密所使用的`会话密钥`，然后用证书的公钥加密这个会话密钥，发给Server。
Server使用自己的`私钥（private key）解密`这个消息，得到会话密钥。至此，Client和Server双方都持有了相同的会话密钥。

Server使用`会话密钥加密“明文内容A”`，发送给Client。

Client使用`会话密钥解密响应的密文`，得到“明文内容A”。

Client再次发起HTTPS的请求，使用会话密钥加密请求的“明文内容B”，然后Server使用会话密钥解密密文，得到“明文内容B”。

### Ribbon负载均衡策略

随机、轮询、重试、最低并发、可用过滤、响应时间权重、区域权重

---

### Spring 中有多少种IOC容器？IOC原理？IOC的理解？

BeanFactory-懒加载、ApplicationContext-即时加载,国际化

IOC原理：工厂模式 + 反射。

IOC理解：控制反转，将创建对象的控制权交给 Spring。

IOC的三种注入方式：构造、setter、注解

### Spring AOP的理解？

面向切面编程，横向抽取，取代重复代码、性能监视、事务管理、安全检查、缓存，纯Java实现，底层原理是 动态代理机制。

如果类实现了 InvocationHandler 接口，则使用JDK动态代理生成对象；反之，则使用CGLib生成代理对象。

### Spring 中使用的设计模式？

工厂、单例、代理、观察者、模板方法。

### 你更倾向于那种事务管理类型？

大多数Spring开发者选择声明式事务管理：对代码影响小、无代码侵入、轻量级容器

---

### Redis 事务的命令？

MULTI, EXEC, DISCARD, WATCH

### Spring Bean 生命周期？

实例化 → 依赖注入 → init-method → destory-method

### Spring Bean 作用域？

singleton、prototype、request、session、global-session

### Spring注入的区别？

构造注入-强制依赖、setter方法注入-可选依赖、注解注入

### Spring框架中的 单例 bean是线程安全的吗？

不是。Spring框架并没有对单例bean进行任何多线程的封装处理。

一般情况下Spring bean没有可变的状态，可以理解为线程安全的。如果Bean有多种状态变化的话（如 View Model对象），就需要自行保证线程安全。

最浅显的解决办法：配置为 prototype 多例

### Spring Bean 配置方式？

基于XML配置、基于注解配置、基于Java配置（如@Configuration, @Bean）

---

### 常见缩写概念

QPS:查询请求数量/s，即并发量

TPS:事务执行数量

DUV:日活，每日活跃用户量

MUV:月活，每月活跃用户量

DPV:日页面浏览量

MPV:月页面浏览量

### 小张看最近的大米价格，他打开百度，进行了一番操作，最后获得最近的大米价格。请问上述过程中参与的硬件、软件、中间件、涉及到的技术、流程，参与者都有哪些？

答：http → 接口 → ip → 机器 → 端口 → 进程 → 服务 → 线程 → 代码逻辑 → 数据库 → 原路返回

### 做过的项目，并发量/日均pv最大的是哪个？部署了多少台机器？如果服务器流量激增，你认为会遇到什么问题？如何处理，有什么思路？

答：按实际情况回

### 举个例子，说明自己学习能力很强？以及坚持最久的一件事情？

答：写博客

### 如何设计一个可以抗高并发的项目？

① 快速进行扛量 --> 加机器(负载均衡) Nginx

② 合理设计项目 -->

* A.缓存：对冗余请求的数据，需要做缓存处理，主流方案 NoSQL Redis
* B.MQ：异步消息队列，对复杂的逻辑方法进行解耦，异步处理 主流方案 RabbitMQ
* C.业务逻辑优化

③ 架构 -->

* A.单体架构
* B.分布式架构（SOA）
* C.微服务架构 - Spring Cloud Alibaba：Nacos/Gateway/OpenFeign/Ribbon/Sentinal/Sleuth+ZipKin

---

### MyBatis的理解？

半自动 ORM 框架，XML或注解来配置和映射原生信息，消除JDBC冗余，与Spring集成，专注于SQL，灵活的DAO层解决方案。

### Java IO有哪些？NIO多路复用的实现原理？

```
通道（Channel）
通常们nio所有的操作都是通过通道开始的，所有的通道都会注册到统一个选择器(Selector)上实现管理，在通过选择器将数据统一写入到 buffer中。

缓冲区(Buffer)
Buffer本质上就是一块内存区，可以用来读取数据，也就先将数据写入到缓冲区中、在统一的写入到硬盘上。

选择器(Selector)
Selector可以称做为选择器，也可以把它叫做多路复用器，可以在单线程的情况下可以去维护多个Channel，也可以去维护多个连接。 
```

### 强引用、软引用、弱引用、虚引用？

String s = "abc"; // 强引用。

软引用：有用但非必需的对象。

弱引用：有用但非必需的对象，更短的生命周期。

虚引用：没有生命周期，也没有用的对象，在回收队列中还未被回收，准备回收的对象。

### 创建对象的方式？

new、反射、clone、序列化。

### Enumeration 与 Iterator 的区别？

Enumeration 速度是 Iterator 的 2倍，且占用更少的内存。但 Iterator 更安全。

### 字符串常量池存在内存中的哪里？

jdk 1.6 常量池在方法区（方法区可以看做是堆中的永久区）

jdk 1.7 常量池在堆空间中（JVM规范中不再声明方法区）

jdk 1.8 常量池在元空间中（JVM规范声明了元空间）

### JDK 1.8新特性？

Lambda表达式、Stream API、函数是接口、接口default方法、接口static方法

### 批量删除10个数据如何删除？

DELETE FROM table WHERE id IN(1, 2, 3);

DELETE FROM table WHERE id=1 OR id=2 OR id=3;

---

### ArrayList 源码分析？

① 变长集合，基于定长数组，jdk1.7 默认初始化数组长度10，jdk1.8后第一次调用add时才初始化；

② 允许控制和重复元素，扩容因数为 1.5 倍；

③ 增删慢（需要数组其他元素拷贝移动），查询快（有下标索引,复杂度O(1)）

④ 线程不安全

⑤ Integer.MAX_VALUE-8 是最大的安全取值下标（因不同的JVM会加入一些数据头）

### HashMap 源码分析？

jdk1.8 之前为 数组+链表

jdk1.8 之后为 数组+链表+红黑树（链表长度>8时转为红黑树）

扩容因子0.75，也就是浪费1/4的空间，达到扩容因子会扩容，0.75是时间与空间的一个平衡值

### ConcurrentHashMap源码分析？

初识容量默认为16段(Segment)，使用分段锁设计；

不对整个Map加锁，而是为每个Segment加锁；

当多个对象存入同一个Segment时，才需要互斥；

最理想状态为16个对象分别存入16个Segment，并行线程数量16个；

使用方式与HashMap无异。

// JDK1.7: 分段锁设计 Segment

// JDK1.8: CAS交换算法（CAS比较和交换） + 同步锁 synchronized（锁的是表头）

### 如何设计一个高并发的项目？

（1）`系统拆分`，将一个系统拆分为多个子系统，然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以抗高并发么。

（2）`缓存`，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。

（3）`MQ`，必须得用MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用redis来承载写那肯定不行，人家是缓存，数据随时就被LRU了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的，这个之前还特意说过。

（4）`分库分表`，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。

（5）`读写分离`，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。

（6）`Elasticsearch`，可以考虑用es。es是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来抗更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用es来承载，还有一些全文搜索类的操作，也可以考虑用es来承载。

---

### 谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？

① 一次编写，到处运行

② GC 垃圾回收器（自动回收，不需要让开发者关心内存回收问题）

JVM >> JRE >> JDK

.class 字节码文件 + JVM 实现了跨平台的到处运行。

### 请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？  

都继承自 Throwable 类

Exception 可抛出、可捕获、可处理，NPE、下标越界异常、类型转换异常

Error 不可处理，OutOfMemoryError

受查异常，编译期检查

运行异常，不会在编译期要求，但在运行时会导致程序终止退出，因此需要捕获处理异常

### 谈谈 final、finally、 finalize 有什么不同？

① final 修饰词

* final修饰类：最终类，不能被继承，如String、Math、System均为final修饰的类
* final修饰方法：最终方法，不能被覆盖
* final修饰变量：基本类型变量，值不可变；引用类型变量，地址不可变
* final作为形参使用的好处：拷贝引用，为了避免引用的地址值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。

② finalize() 方法

当对象被判定为辣鸡对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列。

* 自动回收机制：JVM的内存耗尽，一次性回收所有辣鸡对象。
* 手动回收机制：使用 System.gc() 通知JVM触发垃圾回收。

③ finally 关键字

作为异常处理的一部分，它只能用在try-catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常/不管是否有return），经常被用在需要释放资源的情况下。

### String、StringBuffer、StringBuilder区别？

String: final 修饰的类，不可继承；属性也是 final修饰，拼接字符串操作都会产生新的 String 效率低些

StringBuilder: 可变长字符串，JDK5.0提供，运行效率快、线程不安全。

StringBuffer: 可变长字符串，JDK1.0提供，运行效率慢、线程安全。

---

### 谈谈Java反射机制,动态代理是基于什么原理?

反射是Java语言在程序运行时获取和操作类和对象的一种特殊的机制。

获取：对象的类对象Class，类的属性和方法，调用方法或者构造对象，获取类或方法的注解信息等..

动态代理，是程序在运行时动态构建代理对象，用于动态增强方法的调用的机制。

JDK自身提供的有动态代理，还有更高性能的CGLib代理等..

### int和Integer有什么区别?谈谈Integer的值缓存范围。

int，基本数据类型，占4个字节。

Integer，包装数据类型，拥有一个int字段存储数值，和基本的数值操作、运算方法。

缓存值范围 -128~127存储在一个static final常量cache中 JDK1.5后提供，赋值时调valueOf()方法会重用这些缓存的常用数，显著提高性能。

### 对比Vector、ArrayList、 LinkedList 有何区别?

都继承自List接口，都属于有索引值的集合类型。

Vector：线程安全(synchronized)，底层为数组，初始长度10，扩容因子1

ArrayList：非线程安全(查询快,增删慢-较LinkedList)，底层为数组，初始长度10，扩容因子0.5

LinkedList：非线程安全(查询慢,增删快-较ArrayList)，底层为双向链表，初始长度为0，根据元素数量递增长度，静态内部类Node来作做数据节点

### 对比Hashtable、HashMap、 TreeMap 有什么不同?谈谈对HashMap的理解？

都继承自Map接口，键值对形式存储和操作。

Hashtable：线程安全(synchronized)，无序，不允许null值，子类Properties也是线程安全主要用于配置文件

HashMap：非线程安全，无序，key唯一，允许null键和值，初始容量16，扩容因子0.75（jdk1.7 数组+单向链表；jdk1.8 数组+链表+红黑树[链表>8时链表转为红黑树]）

TreeMap：基于红黑树实现的Map，实现了SortedMap接口，key会自动排序

### 如何保证集合是线程安全的？ConcurrentHashMap如何实现高效的线程安全？

保证线程安全：synchronized 修饰集合的方法操作，或者 ReentrantLock 对公共代码区域加锁

线程安全的集合：

* Collections工具类下的静态方法，以synchronized开头的线程安全方法
* CopyOnWriteArrayList、CopyOnWriteSet、ConcurrentLinkedQueue(CAS算法+无锁)、ConcurrentHashMap(CAS算法+同步锁)
* ConcurrentHashMap：
  * jdk1.7 使用分段锁设计，为每个 Segment 加锁
  * jdk1.8 使用CAS交换算法（比较和交换）+同步锁（锁Map中的表头-16容量，每个容量的Segment加锁）

---

### Java提供了哪些IO方式? NIO如何实现多路复用?

Java的IO流，比如文件的输入输出流，属于同步、阻塞方式，代码简单，但效率和扩展有局限性；

网络通信的Socket相关IO流，也是同步、阻塞的流；

* jdk1.4引入了NIO，同步非阻塞，使用Channel、Selector、Buffer三个核心对象构建多路复用；
* jdk1.7引入了AIO，异步非阻塞，NIO的升级，加入了事件和回调来异步非阻塞处理数据。

### Java有几种文件拷贝方式?哪一种最高效?

① java.io 下 FileInputStream读取文件、FileOutputStream写入文件。

② java.nio 下 transferFrom或transferTo实现拷贝文件，NIO机制拷贝效率更高。

③ 工具类静态方法：File.copy() 或 Files.copy()

### 接口和抽象类的区别？

① 接口 interface 声明，抽象类 abstract 声明

② 接口 可以 implements 多实现，抽象类 只能 extends 单继承

③ 接口没有构造方法，抽象类 可以有构造方法

④ 接口的方法默认为公开抽象方法，属性默认为公开静态常量，抽象类方法和字段可以任意

⑤ 接口目的：接口声明 和 实现分离；抽象类目的：方法和属性代码重用

### 谈谈你知道的设计模式? 

设计模式：

① 创建型模式：工厂模式、单例模式、建造者模式、原型模式

② 结构型模式：装饰者模式、代理模式、桥接模式、适配器模式、组合模式、外观模式、享元模式

③ 行为型模式：策略模式、解释器模式、命令模式、观察者模式、迭代器模式、模板方法模式、访问者模式

### Spring等框架中使用了哪些设计模式?

① BeanFactory 和 ApplicationContext 使用了 `工厂模式`

② Bean的创建，不同的scope对象，使用了 `单例模式` 和 `原型模式`

③ AOP 面向切面编程 使用了 `代理模式、装饰器模式、适配器模式`

④ 各种事件的监听 使用了 `观察者模式`

⑤ 类似 JdbcTemplate 等 xxxTemplate 使用了 `模板方法模式`

---

### synchronized 和ReentrantLock有什么区别?有人说synchronized最慢,这话靠谱吗?

synchronized：Java原生互斥锁、JVM获取/释放锁、无需手动释放锁、锁方法或代码块、`低并发下性能高一些`，可读性也好。

ReentrantLock：jdk1.5后提供的api层面的互斥锁、必须手动加锁/释放锁、可超时中断或interrupt()中断方法中断、拥有更多的方法监听锁的信息、`在高并发下性能最好`。

### synchronized底层如何实现?什么是锁的升级、降级?

synchronized底层是有 monitorenter、monitorexit指令实现的。Monitor对象是同步的基本单元。

JDK1.6以后对其进行改进，提供三种Monitor，即三种锁：偏斜锁、轻量级锁、重量级锁，提高了性能。

**锁的升级、降级**：`就是JVM对synchronized运行机制的优化，当JVM检测到不同的竞争状况时，自动切换到适合的锁的实现`。

### 一个线程两次调用start() 方法会出现什么情况? 谈谈线程的生命周期和状态转移。

Java线程不允许启动两次，第二次抛出 IllegalThreadStateException 非法的线程状态异常。-运行时异常。

jdk1.5以后，线程状态：NEW创建 -> RUNNABLE就绪 -> BLOCKED阻塞 -> WAITING等待 -> TIMED_WAIT超时等待 -> TERMINATED终止
![image-20200813232208798](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200813232210.png)

### 什么情况下Java程序会产生死锁?如何定位、修复、预防?

两个或多个线程，由于互相持有对方需要的锁，而一直等待对方释放锁的永久阻塞状态。

定位死锁：

① 使用ps命令或任务管理器获取进程id，使用 jstack 命令工具(win>`jstack PID`)获取线程栈，找到 BLOCKED(on object monitor)，进而找到死锁位置进行修复。

② Java提供的API ThreadMXBean，直接提供了 findDeadlockedThreads() 方法用于定位。

预防：

① 避免使用多个锁，确保需要时才持有锁；

② 多个锁时设计好锁的获取顺序(如银行家算法)；

③ 使用带超时的方法更有可控性。

---

### 接口超时的原因、排查步骤和解决方案？

参考资料：https://blog.csdn.net/mingyundezuoan/article/details/95020326

```
* 可能原因：
  ①网络延迟或丢包；
     	②接口的服务调用延迟；
     	③多线程代码执行延迟；
     	④代码本身问题,如RestTemplate没有设置超时时间、tcp连接超时、nginx读取后端服务默认60s等
* 排查步骤：
  ①网络问题排查：查看tomcat中请求超时的日志；
     	②依赖应用排查：查看是否依赖其他应用导致的超时；
     	③线程栈信息获取：jstack PID 查看线程是否有死锁或睡眠或其他阻塞等；
     	④其他方向：服务器配置、服务器软件、DNS解析时间、网络最小带宽、网页大小、数据库操作、页面大量特效JS/大图片等元素
* 解决方案：
  ① 网络或依赖应用的问题，需要第三方解决；
     	② 线程问题，需要解决死锁或其他阻塞问题；
     	③ RestTemplate设置超时时间，如 setConnectTimeout 和 setReadTimeout 均为 1s或3s
     	④ 如果设置了请求超时时间，可再多调用一次；
     	⑤ 异步机制，使用线程单独调用需要的远程接口，不影响主流程逻辑执行；
     	⑥ 缓存机制，专门配置缓存服务器，如redis，优先调用缓存服务器里的数据，快速调用解决超时
```

### Java 并发包提供了哪些并发工具类？

并发包，也就是 java.util.concurrent 包及其子包。

① 提供了比 synchronized 更高级的同步结构，比如 CountDownLatch-同步计数器、CyclicBarrier-循环屏障、Semaphore-信号量等...

② 提供了线程安全的容器，如 ConcurrentHashMap、ConcurrentLinkedQueue、CopyOnWriteArrayList等...

③ 提供了各种并发队列，如各种BlockedQueue实现，比如 ArrayBlockingQueue、 LinkedBlockingQueue 等...

④ 提供了强大的 Executor 框架，可以创建各种不同类型的线程池、调度任务运行等。

### 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别?

java.util.concurrent 并发包下主要是三类容器，Concurrent开头、CopyOnWrite开头、Blocking开头

ConcurrentLinkedQueue 基于CAS算法即比较交换算法的无锁技术，即不需要在操作时使用锁而达到并发时的线程安全；

LinkedBlockingQueue 内部则是基于锁(ReentrantLock重入锁)实现，并提供了 BlockQueue 等特性方法。如果不指定容量，则为Integer的最大值，也就是 无界队列。

### CAS比较并交换算法是什么？优缺点？

CAS包含3个参数：`内存值  V`　|　`旧的预期值  A`　|　`新值  B`

[当且仅当V值等于A值时，将V的值改为B值，如果V值和A值不同，说明已经有其他线程做了更新，则当前线程什么都不做，最后返回当前V的真实值。]()CAS操作是抱着乐观的态度进行的（乐观锁），它总是认为自己可以成功地完成操作。

优点：CAS由于是在硬件层面保证的原子性，不会锁住当前线程，它的效率是很高的。

缺点：

① ABA问题。即操作数据时从内存取出、在下一个时刻比较并替换，那么时间差可能导致数据发生变化。部分乐观锁的实现通过 携带 `版本号/时间戳` 来解决ABA问题。

② 循环时间长开销大。自选CAS如果长时间不成功，会给CPU带来非常大的执行开销。因此CAS不适合竞争十分频繁的场景。

③ 只能保证一个共享变量的原子操作。多个共享变量时就得考虑使用锁。

### ABA问题

![微信图片_20220207214324](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20220207214538.jpg)

---

### Java并发类库提供的线程池有哪几种?分别有什么特点?

![image-20200816235205299](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200816235206.png)

阿里巴巴嵩山版 建议使用：`ThreadPoolExecutor`（七个参数）。

```java
 public ThreadPoolExecutor (
     int corePoolSize,                   // 1 核心线程池大小
     int maximumPoolSize,                // 2 最大线程池大小
     long keepAliveTime,                 // 3 线程最大空闲时间
     TimeUnit unit,                      // 4 时间单位
     BlockingQueue<Runnable> workQueue,  // 5 线程等待队列
     ThreadFactory threadFactory,        // 6 线程创建工厂
     RejectedExecutionHandler handler    // 7 拒绝策略
 ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
}
```

### 高并发，处理时间短，使用哪种线程池？低并发，处理时间长，使用哪种线程池？高并发，处理时间长，如何处理？

![高并发与线程池面试题](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200822133859.png)



### Map类集合K/V不能存储 null 值的情况：

![image-20200817080949963](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200817080952.png)

### 阿里巴巴Java开发规范-嵩山版，并发模块强制注意事项

① 获取单例对象和单例的方法需要保证`线程安全`

② 线程资源必须通过线程池提供，且不能使用 Executors 创建，要使用 ThreadPoolExecutor 的方式，规避资源耗尽(原因：固定线程数/单线程数/缓冲动态线程数 均可能堆积大量的线程，导致OOM[OutOfMemory])

③ SimpleDateFormat是线程不安全的类,一般不要定义为static变量,如果定义为static 必须加锁,或者使用DateUtils工具类

### Redis分布式锁、持久化、缓存击穿解决？

分布式锁：
https://www.cnblogs.com/moxiaotao/p/10829799.html

分布式锁一般有三种实现方式：

1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。

持久化：RDB,AOF

缓存击穿解决：缓存到期大量并发访问数据库造成数据库宕机。

解决① 热点数据永不过期；② 添加分布式锁来控制。

### 秒杀流程

限流、缓存。

---

### AtomicInteger底层实现原理是什么?如何在自己的产品代码中应用CAS操作?

AtomicIntger是对int类型的一个封装,提供原子性的访问和更新操作,其原子性操作的实现是基于CAS ( compare-and-swap)技术。

即：`AtomicInteger是一个提供原子操作的Integer类，通过线程安全的方式(CAS算法)操作加减。`

从AtomicInteger的属性可以看出,它依赖于Unsafe提供的一些底层逻辑进行底层操作; 以volatile的value字段记录数值，以保证可见性。

① CAS ,表征的是一些列操作的集合,获取当前数值,进行一些运算 ,利用CAS指令试图进行更新。如果当前数值未变,代表没有其他线程进行并发修改,则成功更新。否则,可能出现不同的选择,要么进行重试,要么就返回-一个成功或者失败的结果。

② **volatile** 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略。（`可见性，值被修改线程立即可见；有序性，禁止指令重排序；原子性，保证单次读写的原子性`）

### 类加载过程？什么是双亲委派模型？

类加载三个步骤：加载、链接、初始化。

加载：将字节码加载到JVM中。

链接：将类信息链接到JVM中运行。

初始化：执行类的初始化的逻辑，如静态字段赋值、静态代码块执行等...

双亲委派模型：如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。

目的：使用委派模型的目的是`避免重复加载Java类型`。

 

### 有哪些方法可以在运行时动态生成一个Java类?

① 普通的开发过程，编写java代码，javac编译成class文件，然后通过类加载加载进入JVM，就成为程序运行时的java类。

② 还可以使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能

③ 还利用 Java 字节码操纵工具和类库来实现，比如 ASM，Javassist，cglib等...

### 谈谈JVM内存区域的划分,哪些区域可能发生 OutOfMemoryError?

PC程序计数器、虚拟机栈、本地方法栈、堆、方法区

常见发生OOM错误信息的原因：

* 堆内存不足、
* 递归调用无退出条件不停压栈JVM去扩展栈空间的时候、
* 老版本JDK上永久代回收内存不及时在大量动态类型生成时、
* 直接内存不足时。

![image-20200819225845864](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200819225847.png)

### 监控和诊断JVM堆内和堆外内存？

① Java自带的 JConsole  图形化工具，连接到java进程，看到各内存使用情况

② 命令行工具 jstat 和 jmap 都提供了选项参数查看堆、方法区等数据

③ tomcat、weblogic 这样的 JavaEE 服务器，提供的有内存管理功能

④ GC日志的输出，也包含了内存丰富的信息

### Java常见的垃圾收集器？

Oracle JDK中  

① Serial GC 单线程老年代垃圾收集器；

② ParNew GC 新生代垃圾收集器，多线程版本；

③ CMS GC 标记-清除算法；

④ Parrallel GC 吞吐量优先的GC

---

### GC调优思路？

1. 确定调优目标：内存占用、延时、吞吐量
2. 掌握JVM和GC的状态，定位问题，jstat查看GC状态，开启GC日志
3. 分析确定具体调整的参数或软硬件配置
4. 验证是否达到调优目标，否则重复上述步骤

### Java内存模型中的happen-before是什么？

happen-before关系，是Java内存模型中保证多线程操作可见性的机制。

### Java程序运行在Docker等容器环境有哪些新问题？

如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生 OOM。

错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。

### Java应用开发中的注入攻击？

① SQL 注入攻击，常见于登陆功能，where条件后加 or 1=1; 就可以添加其他sql语句进行攻击

② 操作系统命令注入，如Java的 Runtime.exec(...) 的API，可以执行命令，拼接 ;rm -rf /* 就玩玩了

③ XML 注入攻击，XML本身是可以包含动态内容的，例如XPATH，可能会被恶意访问内容

### 后台服务明显变慢，谈谈诊断思路？

区分：突然变慢、长时间运行变慢

频率：是否重复出现

慢的定义：请求的延时时间变长，还是其他？

诊断工具：

① JMC+JFR 监控应用是否出现大量某种类型的异常

② jstat 查看GC日志

③ 任务管理器/top命令，找到对应的Java进程id，通过 jstack 获取进程的线程栈

④ JVM层面的性能分析：JMC、JConsole进行运行时监控，GC日志等

### 有人说Lambda表达式让Java程序慢30倍，你怎么看？

基准测试、自动装箱拆箱、启动过程变慢

### JVM优化Java代码时都做了什么？

运行时优化、即时编译器优化。

运行时优化：解释执行和动态编译通用的一些机制，如锁机制、内存分配机制等...

即时编译器优化：代码以方法为单位转换为机器码，直接运行在底层硬件上。

---

### MySQL事务隔离级别，悲观锁和乐观锁原理和应用场景？

读未提交：一个事务可以看到其他事务未提交的修改。`允许脏读`

读已提交：一个事务能看到其他事务已经提交的修改。`允许不可重复读和幻读`

可重复读：保证同一个事务多次读取的数据是一致的。`MySQL innoDB默认隔离级别，不会出现幻读`

串行化：并发事务之间是串行化。`读取需要获取共享锁，更新需要获取排它锁————最高隔离级别`

* 脏读：一个事务读到了另一个事务未提交的数据
* 不可重复读：一个事务读到了另一个事务已经提交的数据，导致前后不一致
* 幻读：select 某记录是否存在，结果是不存在，准备插入此记录，但执行 insert 时发现此记录已存在（因刚好被另一个事务 insert），无法插入，此时 select 过程发生幻读。

### Spring Bean 生命周期和作用域？

生命周期：实例化Bean对象 → 设置Bean属性 → 调用 Bean 定义的 init 方法 → 销毁：即Bean定义的destroy方法

作用域：Singleton 单例。Prototype 多例。Request 为每个HTTP请求创建Bean示例。Session 会话。GlobalSession 全局的HTTP Session。

### Spring、Spring MVC、Spring Boot、Spring Cloud关系？

Spring 已经成为了一个庞大的生态系统，内部包含了依赖注入、事件机制等核心模块，也包括事务、O/R Mapping 等功能组成的数据访问模块，以及 Spring MVC 等Web 框架和其他基础组件。

Spring Boot，通过整合通用实践，更加自动、智能的依赖管理等，Spring Boot 提供了各种典型应用领域的快速开发基础，所以它是以应用为中心的一个框架集合。

Spring Cloud，可以看作是在 Spring Boot 基础上发展出的更加高层次的框架，它提供了构建分布式系统的通用模式，包含服务发现和服务注册、分布式配置管理、负载均衡、分布式诊断等各种子系统，可以简化微服务系统的构建。当然，还有针对特定领域的 Spring Security、Spring Data 等。

### Netty如何实现高性能的吗？

灵活的线程模型，高效管理Channel

充分利用 java 的 Zero-copy 机制，降低内存分配和回收的开销，大大提高性能

使用更多本地代码

通信协议、序列化等其他角度的优化

### 常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？  

基于 Twitter 早期开源的Snowflake雪花算法（以及微信的 seqsvr、美团Leaf分布式id生成系统）：

![image-20200821233030907](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200821233032.png)

整体 64 位，适合使用 long 类型来存储。算法本身大多依赖 System.currentTimeMills()的时间毫秒值

### Java 多线程在什么情况下使用？

数据同步比较慢的时候；

异步调用第三方接口的时候；

服务器需要同时接受多个客户端连接，有无需实时等待的服务处理的时候；

单线程处理很慢的时候，需要多线程并行执行的时候。

---

### 问springboot自动配置和运行流程

`自动配置`：spring和springMVC需要配置大量的参数，springboot提供了应用程序和框架所需的基本配置，这个就是自动配置，而且约定大于配置。
SpringBoot主配置类只要标注上`@SpringBootApplication`的注解，Spring就会帮我们自动配置各个组件和实例化Bean。

> 核心：启动类注解 → 自动配置注解 → 自动配置包注解(扫描包) → @Import注解导入组件 → 完成自动配置

* `@SpringBootApplication`
    这个类是 SpringBoot 的主配置类，而且也是一个组合注解。
    SpringBoot 就应该运行这个类的 main 方法来启动 SpringBoot 应用。
    * `@EnableAutoConfiguration`
        包含一个 `@AutoConfigurationPackage` 注解就是将主配置类（@SpringBootConfiguration标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器中。

        * `@AutoConfigurationPackage`
            自动配置包，主要是使用的@Import来给Spring容器中导入一个组件 ，这里导入的是Registrar.class。可以用debug模式在这个类的方法中加断点，可以看到扫描包的路径。

        > 说白了就是将主配置类（即@SpringBootApplication标注的类）的所在包及子包里面所有组件扫描加载到Spring容器。

        * `@Import`
            这个注解就是给Spring容器中导入组件使用的。

        > Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们完成了。

    * `@SpringBootConfiguration`
        该注解表示这是一个 SpringBoot 的配置类，其实它就是一个 @Configuration 注解，也是一个Spring组件

    * `@ComponentScan`
        开启组件扫描。

`运行流程`：

首先进入SpringAplication类run方法。
run方法新建SpringApplication对象。 创建并启动计时监控类。
通过configureHeadlessProperty设置java.awt.headless的值
prepareEnvironment根据运行监听器和参数准备spring环境
调用createApplicationContext方法创建应用上下文
refreshContext方法刷新上下文
调用started发布应用上下文启动完成事件
callRunners方法执行所有runner运行器
调用running发布应用上下文就绪事件
最后返回应用上下文

### MySQL行级/表级锁的使用和单例模式，分布式锁和分布式失误的实际运用。

* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

![image-20200825001253519](https://jy-imgs.oss-cn-beijing.aliyuncs.com/img/20200825001254.png)

### Redis的用户名和密码怎么设置？

* 没有用户名，只能配置密码

### 问redis中String底层怎么实现？

* SDS simple dynamic string
    * len：记录buf数组中已使用的字节的长度。
    * alloc：已分配的空间，不包含头和空终止符。
    * flags：前三位表示不同的sds结构体的类型，后五位预留。
    * buf：字节数组，用于保存字符串。

1、获取字符串长度的复杂度降低

2、避免内存溢出

3、空间预分配

4、惰性删除

### hashmap跟redis的区别

hashmap是集合数据结构，只能运行在内存中。

redis是key-value的数据结构存储

* 每一个命令都是原子操作
* 可以持久化存储
* 可以实现分布式锁
* 可以缓存数据
* 其中 zset 可以自动根据 score 排序做榜单

### hash的性能优化。hashmap性能优化

* 一是当预估出hashmap大小时，可以设置初始值。初始值遵循下面原则：2的整数次幂；初始值=预估值/0.75
* 二是当hashmap查询效率要求高时，可以把加载因子设置小点。原因是加载因子小，空间充足，发生哈希冲突的几率小，那么就不会出现链表和红黑树；
* 三是当hashmap对空间要求比较节省时，就可以把加载因子设置大点。这样node数组空间利用比较充分。因为加载因子大，边界值就大，node数组就会更容易占满，空间利用比较充分；

### 工厂模式里面的普通工厂，和抽象工厂的区别

* 简单工厂模式(又叫静态工厂模式)，本质是通过传入不同的参数来实现多态，达到实例化不同对象的目的。
* 抽象工厂模式是对工厂模式又进行了一层抽象，不单单是像工厂模式只生成一类产品，而是一系列产品，并且可以像零件一样灵活配置给各工厂。
* 简单工厂模式 
    * 【优点】：
    * 1、客户端创建对象时只需要记住特定的参数，而不需要记住复杂的类名，也不用关注实现的过程。(实现了封装和部分解耦)
    * 2、创建对象不需要单独实例化，而是通过工厂类直接获取示例(实现复用)
    * 【缺点】：
    * 1、实例化对象的逻辑全部封装在一个工厂类里，每次需求变化都要单独修改工厂类(违反了开闭原则)，而且出了异常可能没法正常工作。
    * 2、不方便扩展子类
    * 【应用场景】：适合业务简单或者产品较少的情况
* 工厂模式
    * 【优点】：1、在简单工厂的基础上遵循了开闭原则，又进行了解耦，工厂类分为具体的工厂类
    * 【缺点】：1、每增加一个工厂，就要额外开发一个工厂
    * 【应用场景】：正文中符合工厂模式的情况，多由于解耦

* 抽象工厂模式
  * 【优点】：1、正是由于复杂的抽象关联关系使得在类的内部对一系列产品组的管理很方便
  * 【缺点】：1、扩展很费力，每次要修改很多类。
  * 【应用场景】：待创建的对象是一系列相互关联或相互依赖的产品族时

11 基本上都是问多线程

12 都是场景问题，都是情景问题。

13 问redis安装流程。

14 hashmap的key有什么要求？可以是什么类型。

15 一直问token和jwt，token为啥要放Redis。

16 问了mybatis你是用配置xml的形式，还是注解。还问了Oauth2.0。

17 springcloud alibaba组件

18 openfeign实现原理

19 string源码

20 hashmap源码

21 springboot自动装配原理

22 springmvc运行流程

23 过滤器&拦截器

24 nacos注册中心实现原理

25 多线程

26 分布式锁

27 数据库索引

28 数据库引擎

29 sql优化

30 hashmap和hashtable 区别

31 这个一定要会concurrenthashmap和hashtable的区别。

32 的是hashset跟table的区别。

33 反正hashmap是回回，问完就开始往hashtable上问。对了，还有个就是原生的springcloud和springcloud alibaba的区别。

34 今天早上问微服务的RPC。

35 怎么排查死锁

36 建立索引字段a,b和b,a有什么区别

37 sql优化

38 mysql存储过程。

39 redis锁的执行流程。

40 springcloud 网络协议 早上问的。

41 负载均衡轮训算法怎么实现的。

42 RPC :Remote Produce call ,自定义数据格式，基于tcp通讯，速度快效率高。

43 http网络传输协议，基于tcp，规定了传输协议格式，目前服务通信，客户端浏览器都采用，也可服务调用，缺点：消息臃肿

rest风格基于HTTP。

44 int的包装类和long包装类，有啥区别？

45 网络传输七层协议，TCP/IP协议，IPC和RPC，进程和线程之间的通信，二叉树为啥比B+树查询效率高。

46 其他的都是经常用的jvm，hashmap，锁，springboot源码什么的。

数据查询题：

a、表名为T，字段：id（学号，主键）、m（数学）、p（物理）、c（化学），类型都是整数。写一条SQL语句，求每个同学的总分，并按总分倒序排列。

b、使用MySQL语法写出查询前10条记录的SQL语句？

==号比较字符串有什么结果

==号左右两边有几个对象

在ArrayList中放入100个对象，这些对象中有相同的name，怎么用Hashmap去重复

怎么处理浮点类型的数

在A方法上加一个事务，在B方法上加一个事务，用A方法去调B方法，会报错吗，如果报错，会报什么异常错误，如果去掉B方法上的事务，还会报错吗？？  （事务之类的3次）

装饰着模式用到哪里（3次）

单例模式的应用场景（3次）

你项目中那些地方用到SpringAOP（3次）

创建线程的方法（2次）

线程池一系列的问题（2次）

多线程和锁（2次）

springMVC工作流程（2次）

MyBites plus 和 mybites有什么区别（1次）

mybites二级缓存（1次）

mybites 分页原理（1次）

mysql 的搜索引擎有哪些（2次）

mysql的存储引擎（2次）

mysql的优化（3次）

你项目中用到了那些设计模式（3次）

（说工厂模式的注意了，工厂模式中的普通工厂，和抽象工厂的区别，还有装饰着模式，3次）

AOP动态代理 几种代理模式（3次）

IOC（3次）

spring的注解 有哪些 分别干什么用的（2次）

springboot的注解 有哪些 分别干什么用的（2次）

spring Cloud Alibaba 的组件 注意负载均衡的那个组件，和服务之间相互调用的那个组件（3次）

redis数据结构（4次）

redis多路复用（2次）

redis淘汰策略（2次）

redis删除策略（2次）

redis主从复制（2次）

redis 为什么快（4次）

事务的分类

spring默认那个事务（2次）

spring常用事务注解（2次）

spring中@Autowire和@Resource的区别（3次）

springIOC的注入方式（3次）

拦截器和过滤器的区别（3次）

到底什么是代理模式（3次）

分布式事务（1次）

分布式锁怎么实现（1次）

DI的实现（3次）

spring boot的定时任务（1次）

springboot热部署方式（1次）

springboot项目启动时如何执行特定代码（1次）

多线程定时任务（1次）

java类初始化顺序（1次）

jdk1.8对hashmap做了什么样的优化（1次）

服务之间用什么调用，工作原理是什么（要说代码）（1次）

jvm性能调优（1次）

类加载器（1次）

gc垃圾回收机制（1次）



## 专业技能

### 【后端】 

1. 熟练 Java `面向对象`编程(OOP)，常用`数据集合`和 `IO`，熟悉 python/shell 编程写过工具一直在用；

    ```
    【面向对象】
    1.什么是面向对象 / 什么是OOP？
    	面向对象的方法主要是把事物给对象化，包括其属性和行为。贴近实际生活，万物皆对象。
    2.面向对象的四大特征五大原则
    	4大特征：封装、继承、多态、抽象。
    	5大原则：
    	单一职能：每个模块、每个类、每个方法都只负责一件事情。
    	开放关闭：对功能扩展开放，对修改源码关闭。Java世界里最基础的设计原则。
    	里式替换：任何父类可以出现的地方，子类一定可以出现。子类可以无障碍地替换父类 - 多态
    	接口隔离：多个专门的接口比使用单一的总接口要好。
    	依赖倒置：面向抽象进行编程，高层不依赖底层，抽象不依赖细节实现。
    3.接口回调
    	类A调用类B的方法b()，类B再回调类A的方法a()，其中方法a()是定义在接口中的，由类A来实现。这是一个双向调用的过程。
    
    【数据集合】
    1.List、Set、Map、Queue的各种集合和特点？
    	>>>List<<<
    	ArrayList：数组,线程不安全,查询快,增删慢,jdk1.2。jdk1.7无参默认长度为10,jdk1.8懒加载add才有10,扩容因子1.5倍,懒加载
    	Vector：数组,线程安全。方法与ArrayList相同，synchronized修饰所有操作方法。
    	LinkedList：链表,增删快,查询慢。无需开辟连续空间。
    	
    	>>>Set<<<
    	HashSet：不重复+无序,hashCode -> == -> equals 实现不重复
    	LinkedHashSet：记录保留元素插入顺序，不重复
    	TreeSet：不重复+自动排序
    	
    	>>>Map<<<
    	HashMap：效率快,线程不安全,value允许null值,初识容量16,负载因子0.75。jdk1.7数组+链表,jdk1.8数组+链表+红黑树(链表>8,此时时间复杂度为O(logN))
    	LinkedHashMap：HashMap子类,记录插入顺序
    	Hashtable：效率慢,线程安全,value不允许null值,所有方法synchronized修饰
    	TreeMap：实现SortedMap接口，对key自动排序
    	
    	>>>Queue<<<
    	BlockingQueue：阻塞队列,空时读取等待,满时插入等待 -> 生产者消费者问题
    	ArrayBlockingQueue：数组,有界阻塞队列,可构造设置上限
    	LinkedBlockingQueue：链表,无界阻塞队列,默认上限Integer最大值
    	LinkedTransferQueue：链表,无界阻塞队列
    	PriorityBlockingQueue：优先级,无界阻塞队列，直到系统资源耗尽
    	SynchronousQueue：无缓冲的等待队列,无界
    
    	>>> 线程安全的集合 <<<
    	Collections工具类：synchronizedXXX静态方法，性能没有提升
    	CopyOnWriteArrayList：写有锁,读无锁,读写不阻塞
    	CopyOnWriteArraySet：底层为CopyOnWriteArrayList,add时查重元素,会遍历数组
    	ConcurrentHashMap：分段锁×16,每个Segment加锁,jdk1.7分段锁,jdk1.8为CAS比较交换算法+同步锁(锁表头)
    	ConcurrentLinkedQueue：无锁设计,CAS比较交换算法
    
    int a = 128;
    Integer b = 128;
      a == b 结果：true
      b.equals(a) 结果：true
    Integer a = 127;
    Integer b = 127;
      a == b 结果：true
    Integer a = 128;
    Integer b = 128;
      a == b 结果：false  // 缓存cache的 -128~127
    Integer i = new Integer(100);
    Integer j = new Integer(100);
    int k = 100;
      i == j 结果：false //构造方法没有使用缓存cache的 -128~127
      i == k 结果：true
    
    【IO流】
    1.IO分类
    	输入/输出,字节(8bit)/字符(16bit),节点/处理
    	InputStream/Reader: 所有的输入流的基类，InputStream字节输入流，Reader字符输入流
    	OutputStream/Writer: 所有输出流的基类，OutputStream字节输出流，Writer字符输出流
    2.IO / NIO
    	NIO比IO效率高,IO单向会阻塞(面向流),NIO双向非阻塞(面向缓冲)
    	NIO：Channel(通道) <=> Buffer(缓冲), Selector(事件监听-连接/读/写)
    	● NIO 比原生 socket 性能要高，但代码比 Netty 框架要臃肿
    3.BIO / NIO / AIO
    	BIO 同步阻塞,TCP/UDP,同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成
    	NIO 同步非阻塞-多路复用,适用于连接数目多且连接比较短（轻操作）的架构,比如聊天服务器
    	AIO 异步非阻塞,即NIO2,适用于连接数目多且连接比较长（重操作）的架构,比如相册服务器
    
    【序列化&反序列化】
    1.实现Serializable接口
    2.Transient 关键字阻止该变量被序列化到文件中
    3.序列化：Java对象 转换为 字节序列
      反序列化：字节序列 恢复为 Java对象
    
    【注解】
    1.四种元注解（自定义注解@interface）：
        @Target 修饰的对象范围 
        @Retention 被保留的时间长短 
        @Documented 描述javadoc 
        @Inherited 标注类是被继承的
    
    【多线程】
    1.创建：继承Thread类,实现Runnable接口,实现Callable接口,线程池（线程状态：新建-就绪-运行-阻塞-死亡）
    	多文件上传：Callable判断 call 方法的返回值
    2.线程B知道线程A修改了变量：volatile修饰变量 -> synchronized修饰方法 -> wait/notify -> while轮询
    3.终止线程：正常运行结束,退出标志,interrupt方法结束,stop方法终止(线程不安全)
    4.线程池：降低资源消耗、提高响应速度、提高线程的可管理性
    5.线程池工作原理和参数：线程池主要避免了线程的频繁创建和销毁,消耗系统资源和导致系统不稳定
    	ThreadPoolExecutor(7个参数)
        ①corePoolSize:最小线程数（核心线程数量）
        ②maximumPoolSize:最大线程数（≥核心线程数）
        ③keepAliveTime:空闲线程存活时间
        ④unit：存活时间单位,比如秒:TimeUnit.SECONDS
        ⑤workQueue：一个阻塞队列，提交的任务将会被放到这个队列里
        ⑥threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认名：pool-1-thread-3
        ⑦handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。
        	1>丢弃并抛异常  2>丢弃任务  3>丢弃前面的提交新的  4>调用线程来处理
    6.线程池类型：缓冲线程池、固定大小线程池、单线程线程池、默认线程池
    7.java线程调度算法：时间片轮转
    8.多线程上下文切换：轮转竞争CPU的时间片，不同的线程切换使用CPU发生的切换数据就是上下文切换
    9.线程池工作过程：
    线程任务队列通过参数传入，执行execute添加任务方法会判断队列的情况，一个线程完成就进入下一个线程，总数不会超过参数传入的最大线程数。
    
    【线程锁】
    0.并发包 java.util.concurrent 简称 juc
    1.synchronized
    	悲观锁,抢占式,阻塞（同步代码块-锁对象 / 同步方法-锁类实例 / 同步静态方法-锁类对象Class）
    	实现原理：Java对象头 + Monitor(存储线程的数据结构)
    2.volatile：多线程共享变量可见性,有序性,单次读写原子性 - 状态标记量和单例模式的双检锁
    3.锁的分类：
    	1>乐观锁：乐观认为不会发生线程安全,读多写少,先判断再上锁
    	2>悲观锁：悲观认为总会有线程安全,写多读少,直接上锁
    	3>可重入锁：递归锁,同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已经获取过还没释放而阻塞。不仅判断锁有没有被锁上，还会判断锁是谁锁上的，当就是自己锁上时，那么他依旧可以再次访问临界资源，并把加锁次数state+1(优点:一定程度避免死锁), 如 synchronized和ReentrantLock
    	4>不可重入锁：若当前线程执行某个方法获取了该锁，那么在方法中尝试再次获取锁时，就会因获取不到而阻塞。
    	5>公平锁：按顺序分配给请求的线程需要的锁
    	6>非公平锁：JVM 按随机,就近原则分配锁的机制,抢占,直接尝试加锁,则称为不公平锁(效率高于公平锁)
    	● ReentrantLock构造中 boolean fair 可以指定是否为公平锁(FairSync)或非公平锁(NonFairSync-默认)
    	● ReentrantLock主要利用 CAS+AQS 队列来实现。
    	● AQS：AbstractQueuedsynchronizer 构建锁和同步容器的框架,使用一个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态 waitStatus.
    	7>共享锁：允许多个线程同时获取锁,并发访问共享资源,一种乐观锁,如 ReentrantReadWriteLock中ReadLock
    	8>独占锁：(独享锁=排它锁=同步锁=互斥锁)每次只能有一个线程持有锁,如 synchronized和ReentrantLock
    	9>自旋锁：先让当前线程自旋等待,不是阻塞,是为了减少线程切换
    	10>适应性自旋锁：jdk1.6新增,默认开启自旋锁,自旋时间不固定,JVM决定 - JVM参数可设
    		如 AtomicInteger 中的 TicketLock/CLHlock/MCSlock
    	● 锁的状态 4 种：无锁、偏向锁、轻量级锁、重量级锁
    	11>无锁：不使用锁实现线程安全，如CAS
    	12>偏向锁：如果一个线程多次获取锁,就会引起偏向锁,不再参与竞争,直接获取锁(提高性能)-JVM参数可设
    	13>轻量级锁：偏向锁被另外的线程访问则升级到轻量级锁
    	14>重量级锁：轻量级锁进一步升级为重量级锁,直接阻塞访问该锁的其他线程
    4.锁优化：
    	jdk1.6之后对 synchronized 优化：自旋锁,适应性自旋锁,锁消除,锁粗化,偏向锁,轻量级锁等技术减少锁操作的开销
    5.synchronized和ReentrantLock的区别：
    	synchronized 锁方法和代码块,JVM底层实现,不够灵活,不可中断,低并发时效率高；
    	ReentrantLock 锁指定区域,比较灵活,可以通过interrupt()方法中断,封装有线程高级方法,高并发时效率高
    6.jdk1.5之后对 synchronized 锁的优化：
    	1>减少锁持有时间,只在有线程安全要求的程序上加锁
    	2>减小锁粒度,降低锁的竞争,触发偏向锁,轻量级锁成功率才高
    	3>锁分离,根据功能进行分离成读锁和写锁
    	4>锁粗化,锁持有的时间尽量短,使用完后立即释放
    	5>锁消除,编译器级别的工作,编译时发现不能被共享的对象,则消除对象的锁操作
    7.CAS算法：
    	3个核心值 当前内存值V、旧的预期值A、即将更新的值B。
    	当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。
    	原子类，如 AtomicInteger, AtomicLong... AtomicReference(操作多个值)
    	关键字 volatile 来保证当前单次读写操作的原子性不可分割和打断，以及线程可见性
    	类 Unsafe 用来获取当前原子操作的内存数据
    	● ABA问题和解决：
    	当第一个线程执行CAS操作，尚未修改为新值之前，内存中的值已经被其他线程连续修改，使得变量值经历 A -> B -> A的过程。
    	解决方案：添加版本号作为标识，每次修改变量值时，对应增加版本号； 做CAS操作前需要校验版本号。JDK1.5之后，新增 AtomicStampedReference 类来处理这种情况。
    8.ThreadLocal
    	ThreadLocal是用来维护线程中的变量不被其他线程干扰而出现的一个结构。
    	内部是1个 ThreadLocalMap 类，它的 key 为 ThreadLocal 对象自身，value 为要存储的对象
    	这样在不同线程中，持有的都是当前线程的变量副本，与其他线程完全隔离，以此来保证线程执行过程中不受其他线程的影响。
    
    
    【网络编程】
    1.OSI网络七层模型：物理层 - 数据链路层 - 网络层 - 传输层 - 会话+应用+表示层
    2.TCP和UDP区别：
    	TCP面向连接,可靠,字节流,点对点传输,头部开销20字节,保证正确性和顺序;
    	● ServerSocket - 服务端, Socket - 客户端
    	UDP面向报文,无连接的,连接方式多样化,头部开销8个字节,不保证正确性且可能丢包。
    	● DatagramPacket - 数据报包(接收/发送), DatagramSocket - 数据报套接字
    3.TCP三次握手&四次挥手：
    	3握手:客户端 -> SYN -> 服务器 -> SYN+ACK -> 客户端(Established) -> ACK -> 服务器(Established)
    	4挥手:客户端 -> FIN -> 服务器 -> ACK、FIN 按顺序发 -> 客户端 -> ACK
    4.HTTP工作流程：
    	域名解析 -> TCP3次握手 -> 发起HTTP请求 -> 服务器响应HTTP请求 -> 解析响应的HTML代码 -> 渲染代码
    5.HTTPS工作流程：
    	浏览器 -> 443端口发起请求 -> 服务器
    	浏览器 <- 发送公钥证书 <- 服务器
    	浏览器：①验证公钥证书 ②伪随机数生成会话密钥 ③公钥加密会话密钥
    	浏览器 -> 发送加密后的密文 -> 服务器
    	服务器：①私钥解密接收的密文出会话密钥 ②通过会话密钥加密要发送的明文内容
    	浏览器 <- 发送加密明文后的密文 <- 服务器
    	后续就以该 会话密钥 进行信息请求和响应
    6.SSL协议特性：私密性、确认性、可靠性
    7.HTTP请求报文：请求行、请求头、请求体
    8.GET与POST：
    	GET：参数拼在链接地址上,最大1024字节,主要用于获取/查询
    	POST：请求正文中,更安全,可传大数据,主要用于更新数据/上传文件
    9.Nettry：
    	提供一个易于使用的 API 的客户端/服务器 Java 网络编程框架。
    	依赖 Jar 包：netty-all
    	Netty封装。
    
    【JDK8新特性】
    1.接口：支持 default 方法，static 静态方法 均可以有方法体
    2.Lambda：函数做为方法的参数，使用->简写方式简化代码
    3.函数式接口：@FunctionalInterface注解修饰的单个方法的接口
    	Predicate断言,返回真假;Consumer消费,有去无回;Supplier创造,无中生有;Function传递,返回数据
    4.Stream：聚合操作，查找、过滤、映射，包含基本操作、中间操作、终止操作
    ```

    

2. 熟练 JavaWeb 编程 Servlet/JSP 以及 Java 常用框架 Spring、SpringMVC、SpringBoot、Mybatis、Mybatis-Plus、Dubbo、WebMagic等; 

    ```
    【中文乱码】
    1.GET请求中文乱码：服务器IOS-8859-1,浏览器UTF-8 ①编解码 ②String方法编解码 ③server.xml配置编码方式
    2.POST请求中文乱码：request.setCharacterEncoding("UTF-8")来解决
    3.响应中文乱码：
    	①响应头 response.setHeader("Context-Type", "text/html;charset=utf-8");
    	②响应内容类型 response.setContentType("text/html;charset=utf-8");
    4.数据库中文乱码：url追加?useUnicode=true&characterEncoding=utf8&useSSL=false
    
    【JavaWeb】
    1.session和cookie：
    	session:存储在服务器,生命周期跟随服务器周期,或过期(默认30min)
    	cookie:存储在客户端,浏览器关闭则销毁,会话cookie存在浏览器内存,持久化cookie存储在客户端磁盘
    2.servlet是什么？生命周期？：
    	servlet是一个可以处理客户端浏览器传来的HTTP请求并返回响应的对象。
    	生命周期：加载、实例化、初始化、服务、销毁
    3.转发和重定向：
    	转发：服务器,1次请求,地址不变,跳转后信息不丢失,只能转发同一个web项目内的资源
    	重定向：客户端,2次请求,地址改变,跳转后信息会丢失,可以重定向到任何web资源
    4.JSP 9大内置对象和作用：
    	page,pageContext,  request,response,  session,  application,out,config,exception
    5.JSP 四大作用域：
    	pageContext(当前页面),request(1次请求),session(1次会话),application(整个项目)
    6.JSP 防止表单重复提交：
    	①点击后按钮失效 ②重定向到指定页面 ③自定义重复提交过滤器
    7.过滤器与拦截器：
    	过滤器：实现Filter接口,java反射,不依赖servlet,只对action请求有效,只能被调用一次
    	拦截器：实现HandlerInterceptor接口,函数调用,依赖servlet,所有请求有效,spring容器的,可被多次调用
    8.监听器：对象创建/销毁,对象属性改变,对象绑定情况（事件源、监听器、绑定、事件）
    9.启动顺序：Listener 理 Filter 发 Servlet 师 （不会因为标签在配置文件中的先后顺序而改变）
    
    
    【Spring】
    1.Spring工作原理：
    	IOC将创建对象和管理对象交给Spring容器来管理，动态注入，原理是反射实现
    	AOP面向切面编程，对某一类对象或方法来进行监督和控制，来扩充模块的功能
    	Spring目的就是让对象与对象之间不通过代码来关联，通过配置来管理
    
    
    【SpringMVC】
    1.SpringMVC工作流程（回顾那张图即可）
    	请求 → 前端控制器 DispatcherServlet → 处理器映射器 → 适配器 → 匹配处理器 → 返回modelAndView → 前端控制器转给视图解析器 → 解析视图 → 将视图返回响应给用户
    2.Spring中IOC容器：BeanFactory与ApplicationContext
    	BeanFactory：Spring原始的Factory，无法支持AOP,web应用等
    	AppliationContext：具备资源访问、事件传播、国际化消息访问等...
    3.IOC方式：构造、set、注解 （IOC控制反转,DI依赖注入,依赖注入实现了控制反转）
    4.IOC:Spring创建/管理/装配/配置对象，并管理对象的生命周期
    5.AOP:静态代理、动态代理（JDK动态代理-实现接口,CGLIB动态代理-继承）
    6.Bean生命周期:实例化 → 属性赋值 → 初始化init方法 → 销毁destory方法
    7.Bean作用范围:Singleton,Prototype,Request,Session,Globalsession
    8.Spring用到的设计模式：代理/单例/工厂/模板方法...
    9.Spring自动装配：xml bean标签 autowire="byName", byType, autodetect
    10.Spring事务:编程式事务,声明式事务(事务管理与业务代码分离,使用注解或xml配置来管理)
    11.AOP原理和通知类型：
    	面向切面编程的思想。一系列方法和通知的组合。
    	针对业务处理过程进行横向切面提取，优化重复代码。
    	如日志、事务、权限等...形成日志切面、事务切面、权限切面...
    	场景：缓存、权限、内容传递、错误、懒加载、日志记录、优化、同步管理、事务...
    	● 通知类型：方法执行的之前、之后、之后未出现异常、之后出现异常、之前和之后 5种。
    12.SpringMVC和Struts2的区别：
    	拦截机制：SpringMVC是方法级别拦截,Struts2是类级别拦截
    	底层框架：SpringMVC底层是Servlet实现，Struts2底层是Filter实现
    	性能方面：SpringMVC效率高于Struts2
    	配置方面：SpringMVC和Spring是无缝集成的，项目管理和安全上比Struts2高
    13.@Autowire和@Resource：@Autowire按照类型装配,@Resource按照名称装配
    14.spring事务传播行为：7种。①不存在事务就新建 ②不存在事务就不使用 ③不存在事务就抛异常 ④存在事务则挂起创建新的 ⑤存在事务挂起当前事务 ⑥存在事务则抛异常 ⑦存在事务则嵌套事务
    15.spring事务隔离级别：5种。①默认数据库的隔离级别 ②读未提交 ③读已提交 ④可重复读 ⑤序列化
    	MySQL 默认 可重复读，生产中使用的是读已提交，原因：死锁/锁表概率低以及update并发高；Oracle 默认 读已提交
    16.脏读：1个事务读到另1个事务未提交的数据
    	不可重复读：1个事务读到另1个事务已经提交的数据，导致事务多次查询不一致
    	幻读/虚读：select 某记录是否存在，结果是不存在，准备插入此记录，但执行 insert 时发现此记录已存在（因刚好被另一个事务 insert），无法插入，此时 select 过程发生幻读。
    17.spring启用注解自动装配：<context:annotation-config />
    18.@Required 修饰实体类的 setter 方法，xml中必须提供注入该方法的配置，否则会抛异常
    19.@Autowaire & @Qualifie & @Resource
    	@Autowaire 自动按照类型注入
    	@Qualifie 自动按照类型注入并可以起别名，按照别名注入
    	@Resource 直接按照bean的id注入，等价于 @Autowaire + @Qualifie
    
    【SpringBoot】
    1.SpringBoot自动装配原理
    	启动类上的 @SpringBootApplication 注解：
    	● @EnableAutoConfiguration 中 
    		@AutoConfigurationPackage 自动配置包，可以找到调用的 Registrar.class 然后在这个类里加断点，可以看到扫描的包的路径。
    		@Import 导入组件使用，该注解会在启动时将 META-INF/spring.factories 文件中指定的约定配置的值全部导入到容器中，自动配置类就能生效了。
    	● @SpringBootConfiguration 即 SpringBoot 的配置类，本质也只是一个 @Configuration 注解
    	● @ComponentScan 即 开启注解扫描。
    2.SpringBoot运行流程
    	SpringApplication 的 run 方法 → 
    	新建 SpringApplication 对象，并启动计时监控类 →
    	调用 createApplicationContext 方法创建应用上下文 → 刷新上下文 → 发布应用上下文 →
    	最后返回应用上下文
    3.SpringBoot优点
    	独立运行、简化配置、自动配置、无代码生成和XML配置、应用监控
    4.SpringBoot日志框架
    	默认日志框架：logback
    	支持日志框架：logging、log4j2、logback
    5.SpringBoot打包war包：
    	① maven编译插件 ②packaging打包为war
    
    
    【Mybatis】
    0.Mybatis原理：
    	Mabatis使用XML或注解用于配置和原始映射，主要都是使用SqlSessionFactory实例的，一个SqlSessionFactory实例可以通过 SqlSessionFactoryBuilder 获得。用xml文件构建SqlSessionFactory实例。
    	MyBatis有一个实用类----Resources，它有很多方法，可以方便地从类路径及其它位置加载资源。
    1.Mybatis与Hibernate区别：
    	Mybatis：面向sql,半自动ORM,xml动态配置sql更灵活
    	Hibernate：面向对象,全自动ORM(根据对象关系模型直接映射字段),支持级联操作,完整的日志系统
    2.Mybatis优点：基于SQL语句,消除JDBC冗余,数据库兼容,与Spring继承,提供灵活的映射标签
    3.Mybatis缺点：依赖数据库,移植性差,sql语句工作量大
    4.resultMap和resultType：
    	resultMap:标签映射sql查询结果字段到dto自定义的类,适用于连表查询
    	resultType：指定映射返回值的类的类型对应实体类,适用于单表查询
    5.#{}和${}区别：#{}是预编译-可以防止SQL注入攻击,${}是字符串替换
    6.Mybatis缓存：
    	一级缓存：sqlSession 默认开启
    	二级缓存：sqlSessionFactory 需要配置开启 <setting name="cacheEnabled" value="true"/>
    7.Mybatis主键回填：
    	① xml usegeneratedkeys="true" keyproperty="id"
    	② @Option(usegeneratedkeys="true", keyproperty="id")
    8.Mybatis主键生成：
    	@SelectKey(keyProperty = "userBase.id",resultType = String.class, before = true,
                statement = "select replace(uuid(), '-', '')")
    9.Mybatis对象映射：<association ...> 即1对1关系映射
      Mybatis集合映射：<conllection ...> 即1对多关系映射
    
    【Mybatis-Plus】
    1.Mybatis-Plus是对Mybatis框架的一种增强，简化开发、提高效率。
    2.核心注解：
    	@TableName @TableId @TableField 
    	@Version-乐观锁标记 @EnumValue-枚举 @TableLogic-逻辑删除
    
    【Dubbo】
    1.什么是Dubbo？
    	Dubbo是Alibaba开源的分布式服务框架,它最大的特点是按照分层的方式来架构,使用这种方式可以使各个层之间解耦合。一款高性能、轻量级的开源Java RPC框架。
    	三大核心：面向接口的远程方法调用、智能容错和负载均衡、以及服务自动注册和发现。
    2.Dubbo角色：
    	①Provider暴露服务 
    	②Consumer调用远程服务的消费者 
    	③Registry服务注册与发现 
    	④Monitor监控中心
    	⑤Container服务运行容器
    3.Dubbo负载均衡策略：随机、轮询、最少活跃调用、一致性hash
    4.Dubbo默认通信框架：Netty
    5.Dubbo服务调用是阻塞的吗？Dubbo是基于NIO的同步非阻塞方式实现的，客户端不需要启动多线程即可并行调用多个远程服务。
    6.Dubbo的核心配置有哪些？
    	服务、引用、协议、应用、模块、注册中心、监控中心、提供者、消费者、方法、参数 配置。
    7.Dubbo流程协议：
    	提供者 → 注册到注册中心 → 注册中心通知消费者 → 消费者远程调用提供者 → 服务运行容器监控消费者和提供者
    8.Dubbo遇到过的问题：
    	1.注册不上nacos，检查所有扫描路径的地方
    	2.消费者与服务者均需要打包为 war 包
    	3.所有传输的类对象，如 pojo，dto，R结果集 等都需要实现 序列化
    	4.公共模块 maven 编译插件
    
    【WebScoket】
    一种计算机通信协议，单个 tcp 连接提供前双攻通信信道。
    双向+全双工，可以实现客户端与服务器的双向消息发送。
    初始连接使用 HTTP 然后将此连接升级到基于套接字的连接，然后用于未来的通信。
    ```
    

    
3. 精通 Git、SVN、禅道等版本控制、敏捷开发服务的部署和使用； 

    
   
4. 熟练 MySql、Oracle 关系型数据库，具备常见 SQL 优化相关经验； 

    ```
    Mysql 与 Oracle 区别：
    MySQL是轻量型数据库，并且免费，没有服务恢复数据。分页 limit
    Oracle是重量型数据库，收费，Oracle公司对Oracle数据库有任何服务。分页 rownum 嵌套查询
    
    【MySQL】
    
    【Oracle】
    
    【SQL调优】
    1.SQL优化方法
    	步骤：定位、启用慢查询日志(slow_query_log)、Druid SQL监控
    	mysql> set global slow_query_log='ON';
    	细节：不*、不子查询、不IN/NOT IN、不OR、不!=、不null判断、DISTINCT与ORDER BY结合、limit 1、explain要控制带range和以内
    2.SQL优化工具
    	● SQL Tuning Expert for MySQL  ● EverSQL
    ```

    

5. 熟练 Redis 非关系型数据库，包括 Redis 持久化、主从复制、哨兵模式、雪崩与击穿、分布式锁； 

    ```
    【Redis】
    1.Redis为什么快？C语言实现、单线程NIO、内存数据库、RESP客户端与服务器通信协议、string使用SDS更快
    2.Reids持久化？RDB-快照一定时间多少次请求/AOF-每修改/每秒-容灾性好
    3.Redis数据结构和应用场景？
    	str-token, list-消息队列/分页, hash-单点登录, set-去重, zset-排序, bitmap, geo...
    4.Redis事务实现？mutil、exec、discard
    5.Redis淘汰策略？过期时间：1.接近 2.次数最少 3.随机  没有过期时间：1.次数最少 2.随机 最严：禁止驱逐
    6.Redis缓存穿透、击穿、雪崩、倾斜和解决方案？
    	● 穿透, 查不到————布隆过滤器/缓存空对象
    	● 击穿, 瞬时访问量大穿过缓存————热点永不过期/添加互斥锁
    	● 雪崩, 同一时间大面积失效————集群/限流降级/数据预热/过期时随机时间范围失效
    	● 倾斜, 某个服务器压力大导致宕机————集群
    7.Redis如何实现高并发？高可用？
    	高并发：一主多从，主从复制，主写从读
    	高可用：集群、哨兵、主备切换
    8.Redis的操作为什么是原子性的，怎么保证原子性？————单线程
    9.Redis主从复制的过程？————sync同步命令、bgsave（非阻塞）、offset同步新增的数据不需全量同步
    10.Redis哨兵机制和作用？————高可用，监控、通知、自动故障转移
    11.Redis性能问题和解决方案？————主机不做持久化备份，从机做AOF备份每秒同步，主从在局域网内
    12.Redis的String底层结构
    	SDS（simple dynamic string） buff+free+len
    	获取字符串复杂度为 O(1), 不会造成缓冲器溢出, 减少修改字符串的内存重新分配次数, 内存预分配机制
    13.Redis的RESP协议
    	客户端与服务端的序列化通信协议，Redis Serialization Protocol (Redis序列化协议)
    ```

    

6. 熟练 Nginx、Linux、Docker 常用环境搭建，如集群搭建等； 

    ```
    【Nginx】
    1.Apache、Tomcat配置
    2.Nginx负载均衡策略
    	轮询、权重、ip hash、最少连接、最小响应时间
    3.Nginx的原理
    	● master 进程：
    	● worker 进程：
    4.Nginx常用配置
    	压缩、统一错误处理、C10K问题（如何处理大量he护短连接<10000+>）
    ```

    

7. 熟练常用的开发工具和项目构建，如 IDEA、Eclipse、Maven 等，以及常见设计模式和JVM调优； 

    ```
    【设计模式】
    1.单例模式：
    2.代理模式：
    	能够创建一个增强方法的类的对象，增强一些指定的方法逻辑功能。
    3.工厂模式
    	● 简单工厂：传入不同的参数实现多态，实例化不同的对象。
    	● 抽象工厂：工厂模式的一层抽象，可以生产一系列产品(对象)，灵活配置给各工厂。
    
    【JVM调优】
    0.JVM监视工具：jdk下自带的 jvisualvm.exe
    1.JVM加载器多少种
    	● 加载过程：加载 → 链接(验证<文件格式,元数据,字节码,符号引用验证>) → 初始化
    	● 加载器：默认3个类加载器 BootstrapClass / ExtClassLoader / SystemClassLoader / 自定义加载器
    		URL[] urls = Launcher.getBootstrapClassPath().getURLs(); //获取根目录下所有的依赖jar路径
    		URL url = ClassLoader.getSystemClassLoader().getResource(pathName);
    	● 双亲委派模型：
    		类加载的时候，递归加载父类，当父类加载器无法完成这个请求时，子类才会尝试加载。保证不重复加载类
    2.JVM的构成（五大区域）
    	PC程序计数器、堆、栈、本地方法栈、元空间
    3.JVM堆：
    	● 年轻代（伊甸区<默认为堆大小的1/15>,幸存者区<FromSpace + ToSpace>）
    	● 老年代（幸存者区每熬过一次GC年龄+1，15岁时成为老年代）
    	● 永久代（jdk1.8遗弃，改为元空间）
    	新创建对象先存到年轻代 → 伊甸区：
    	1>如果伊甸区满了，会触发GC(Minor GC)会对伊甸区进行回收，如果存活下来，会转移到幸存者区，依次类推。
    	2>如果幸存者区满了，会触发GC(Minor GC)进入幸存者区的 ToSpace。
    	3>如果 ToSpace 满了触发GC(Minor GC)，会将存活的对象转移到老年代。
    	4>老年代满了，触发GC(Major GC)清理。
    	5>Full GC，清理整个堆空间，包括年轻代+老年代。(如果触发了 Full GC 说明程序就出了问题)
    4.JVM幸存者区为什么是2块？ 内存有碎片化可以充分利用内存 + 便于管理年轻代的对象
    5.强引用+软引用+弱引用+虚引用
    	强引用：Object o = new Object();
    		————只要引用还在就不会被GC回收
    	软引用：SoftReference<T> sr = new SoftReference<>(new Object()); Object o = sr.get();
    		————内存不足时，GC强制清理软引用
    	弱引用：WeakReference<T> wr = new WeakReference<>(new Object(), new ReferenceQueue()); Object o = wr.get();
    		————只要GC运行就清理弱引用对象
    	虚引用：PhantomReference<T> pr = new PhantomReference<>(new Object(), new ReferenceQueue()); Object o = pr.get();
    		————幽灵引用,幻影引用：最弱引用，无法获取对象实例。虚可达对象
    		————直接重写finalize方法，方法中记录时间，用于标记GC运行状态和次数，验证JVM调优
    6.final, finally, finalize
    	final常量，finally配合try用于释放资源，finalize配合虚引用来触发GC回收对象
    7.GC回收原则
    	1>引用计数法 - 简单，但如果对象相互引用，计数不准确，会导致内存泄露
    	2>可达性分析算法 - GC ROOT，根节点向下分析引用关系，找到没有引用的对象，不能包含本地方法栈
    8.GC回收算法
    	● 标记-清除：标记并统一回收
    	● 复制：内存分为2块，存活的复制到另一块上，清理掉
    	● 标记-整理：存活的向一端移动，清理到边界以外的
    	● 分代收集：新生代使用复制、老年代使用标记-清除
    9.GC垃圾回收器
    	● 串行  ● 并行  ● CMS  ● G1
    10.JVM调优参数
    	● -Xms 初始堆大小   ● -Xmx 最大堆大小   ● -Xmn 年轻代大小 ...
    	通过调整参数降低 Full GC 的触发。
    11.为什么出现OOM？
    	1> 老年代存储不下幸存者区的内容
    	2> 永久代(元数据空间)内存不足
    	3> bug GC 无法回收内存 -XX:+HeapDumpOnOutOfMemoryError 堆栈快照 -XX:+PrintGCDetails GC日志
    ```

    

8. 熟悉 RabbitMQ、Quartz/SpringTask、WebMagic、EasyExcel、ECharts、Elasticsearch 的使用； 

    ```
    【RabbitMQ】
    1.virtual-host：/
    	broker逻辑分组，虚拟的 Broker，独立：queue、exchange、binding 权限隔离
    2.RabbitMQ 消息如何传输？
    	信道 channel 进行数据传输，没有使用TCP
    	是建立在真实 tcp 上的虚拟连接，每个 tcp 上的信道没有限制
    3.RabbitMQ 如何保证消息不丢失？
    	生产者发送丢失、消费者接收丢失
    	● 消息确认机制
    		生产者发送：转发到队列,返回ACK+消息唯一ID,生产者收到ACK,消息发送成功,如果是NACK,则重新发送
    		消费者接收：1.自动确认-发送ACK给生产者  2.手动确认-手动ACK给生产者  3.不确认-ackXXX=none
    	● 事务,确保消息一致性
    	● 开启消息持久化
    4.RabbitMQ 如何保证消息不重复消费？
    	● 消息唯一ID(内部生成/外部生成)
    	● Redis set(value不重复)，保证消息的幂等性
    5.RabbitMQ 死信队列和延迟
    	● 死信机制实现延迟消息处理：延迟队列 → 消息超时 → DLX死信交换器 → 路由Key → 死信队列1,2...
    
    【Quartz】
    两个注解：@EnableScheduling @Scheduled(cron = 定时器表达式)
    ```

    

9. 熟悉接口开发规范和测试经验，如 Swagger2、Jmeter 等。 

     

10. 熟悉微服务 Spring Cloud Alibaba 微服务框架各种组件和分布式中间件(缓存/锁/消息队列)的基本使用。

    ```
    【微服务】
    1.微服务的认知
    	高扩展性，甲方对并发和扩展性有要求（总用户数百万级，日增5W），所以最终选择了 SpringCloudAlibaba
    2.SpringCloud的各种区别
    	dubbo、gRPC、SpringCloudNetflex、SpringCloudAlibaba主流-阿里双11验证、Servicecomb
    3.SpringCloud的常用组件
    	Nacos服务注册与发现和配置中心、Ribbon负载均衡（+远程调用）、Feign远程调用、Sentinel服务容错、RocketMQ消息队列、GateWay网关、链路监控
    	● Nacos 服务注册中心+统一配置中心
    	● Ribbon和Fegin区别：都可以做远程服务调用，Ribbon可以做负载匀衡/限流降级，实现类与否
    4.服务间通信
    	声明式 REST 调用服务。
    5.最擅长/印象最深的两个模块
    	Nacos & Ribbon
    	Nacos 调试和测试必然会用到，而且统一配置中心也是它最强大的动能之一。
    	Ribbon 使用 RestTemplate 【模板方法】来进行远程服务调用。
    6.微服务项目中遇到的问题：
    	● 服务注册不上————检查IP地址或者配置服务的Nacos IP 和 port
    	● 服务有注册但是请求发送不成功的问题————请求方式不对，HTTP头加入消息类型为JSON
    ```

    

## 其他方面

```
1.接口安全
	● 验证签名
2.接口盗刷
	过滤器、黑白名单(IP限制)、云服务器的防御措施(DDOS防护、堡垒机、访问控制)
3.线上问题排查
	● CPU 100% ： ①查出CPU占用最高的pid ②根据pid找出消耗最高的线程 ③jstack查日志
	● 内存 100% ： ①top -H -p找最高的pid ②jstack打印堆栈信息
4.版本控制器 git svn
5.场景分析：实现思路 → 优化思路
```