---
title: 11-并发调用服务接口
date: 2017-6-28 23:09:27
tags:
- 算法题
categories: 
- 20_收藏整理
- 02_算法题
---

并发调用100个服务接口，控制总体超时时间 60 秒，并打印耗时：

```java
import java.util.concurrent.*;

public class MultiThreadedServiceCall {
    
    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newFixedThreadPool(100);
        CompletionService<String> completionService = new ExecutorCompletionService<>(executorService);
        
        //提交 100 个任务以同时执行
        for (int i = 0; i < 100; i++) {
            completionService.submit(new Callable<String>() {
                @Override
                public String call() throws Exception {
                    //模拟在 100 到 900 毫秒之间随机花费时间的服务调用
                    Thread.sleep((long) (Math.random() * 900 + 100));
                    return "Service call success! ThreadName:" + Thread.currentThread().getName();
                }
            });
        }
        
        long start = System.currentTimeMillis();
        //将所有服务调用的总超时设置为 60 秒
        long timeoutInMilliseconds = 60000;
        int completedTasks = 0;
        boolean allTasksCompletedSuccessfully = true;
        while (completedTasks < 100 && allTasksCompletedSuccessfully) {
            Future<String> future = completionService.poll(timeoutInMilliseconds - (System.currentTimeMillis() - start), TimeUnit.MILLISECONDS);
            
            if (future != null) {
                try {
                    String result = future.get();
                    //这里的 result 用于其他逻辑
                    System.out.println("拿到线程中服务调用结果：result = " + result);
                    completedTasks++;
                } catch (InterruptedException | ExecutionException e) {
                    allTasksCompletedSuccessfully = false;
                    e.printStackTrace();
                }
            } else {
                allTasksCompletedSuccessfully = false;
                System.out.println("在完成所有服务调用之前总超时 " + timeoutInMilliseconds + " 毫秒！");
            }
        }
        long end = System.currentTimeMillis() - start;
        System.out.println("总耗时： " + (end / 1000) + "s");
        executorService.shutdown();
    }
}

```

具体实现过程如下：

1. 创建一个具有 100 个线程的线程池。
2. 创建一个已完成服务的 CompletionService，它会在每个服务执行完毕时给出 Future 对象。
3. 使用 for 循环将 100 个服务提交到 CompletionService 中以并行执行。
4. 记录开始时间并设置整体超时时间为 60 秒（即 60000 毫秒）。
5. 在 while 循环中检查完成的任务数是否小于 100，同时检查所有任务是否都已成功完成。
6. 使用 `completionService.poll()` 方法从 CompletionService 中取出已经完成的 Future 对象。这个方法`会等待 timeoutInMilliseconds - (当前时间 - 开始时间) 的时间来等待结果`。如果超时，则返回 null。
7. 如果返回了 Future 对象，则表示该服务已经执行完毕。使用 future.get() 方法获取服务结果，并进行相应操作。累加已完成任务的数量。
8. 如果返回 null，则表示任一服务超时，跳出 while 循环并输出信息。
9. 关闭线程池。